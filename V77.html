<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gacha Anime Ultime</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <style>
    @keyframes rainbow {
      0% { color: #ff0000; } 14% { color: #ff9900; } 28% { color: #33cc33; } 42% { color: #00ccff; }
      57% { color: #3333ff; } 71% { color: #cc00cc; } 85% { color: #ff3399; } 100% { color: #ff0000; }
    }
    @keyframes rainbow-border {
      0% { border-color: #ff0000; box-shadow: 0 0 10px #ff0000; } 14% { border-color: #ff9900; box-shadow: 0 0 10px #ff9900; }
      28% { border-color: #33cc33; box-shadow: 0 0 10px #33cc33; } 42% { border-color: #00ccff; box-shadow: 0 0 10px #00ccff; }
      57% { border-color: #3333ff; box-shadow: 0 0 10px #3333ff; } 71% { border-color: #cc00cc; box-shadow: 0 0 10px #cc00cc; }
      85% { border-color: #ff3399; box-shadow: 0 0 10px #ff3399; } 100% { border-color: #ff0000; box-shadow: 0 0 10px #ff0000; }
    }
    @keyframes glowing-red {
      0% { border-color: #ff0000; box-shadow: 0 0 12px #ff0000; } 25% { border-color: #e60000; box-shadow: 0 0 12px #e60000; }
      50% { border-color: #cc0000; box-shadow: 0 0 12px #cc0000; } 75% { border-color: #e60000; box-shadow: 0 0 12px #e60000; }
      100% { border-color: #ff0000; box-shadow: 0 0 12px #ff0000; }
    }
    @keyframes glowing-red-text {
      0% { color: #ff0000; text-shadow: 0 0 12px #ff0000; } 25% { color: #e60000; text-shadow: 0 0 12px #e60000; }
      50% { color: #cc0000; text-shadow: 0 0 12px #cc0000; } 75% { color: #e60000; text-shadow: 0 0 12px #e60000; }
      100% { color: #ff0000; text-shadow: 0 0 12px #ff0000; }
    }
    .text-secret { animation: glowing-red-text 2s ease-in-out infinite; }
    .border-secret { animation: glowing-red 2s ease-in-out infinite; }
    .rainbow-border { animation: rainbow-border 3s linear infinite; }
    .rainbow-text { animation: rainbow 3s linear infinite; }
    .selected-character { border: 2px solid #ff0000; box-shadow: 0 0 10px #ff0000; }
    .selected-for-battle { border: 4px solid #00ff00; box-shadow: 0 0 12px #00ff00; }
    .selected-for-fusion { border: 2px solid #ffd700; box-shadow: 0 0 10px #ffd700; }
    .dark-theme { background: linear-gradient(to bottom right, #4b0082, #191970, #0000ff); }
    .light-theme { background: linear-gradient(to bottom right, #f0f0f0, #d3d3d3, #ffffff); }
    .light-theme .bg-white { background-color: #f5f5f5; }
    .light-theme .text-white { color: #333; }
    .light-theme .bg-gray-800 { background-color: #e0e0e0; }
    .light-theme .bg-gray-700 { background-color: #d0d0d0; }
    .light-theme .bg-blue-600 { background-color: #2563eb; }
    .light-theme .bg-blue-700 { background-color: #1d4ed8; }
    .light-theme .bg-green-600 { background-color: #16a34a; }
    .light-theme .bg-green-700 { background-color: #15803d; }
    .light-theme .bg-red-500 { background-color: #ef4444; }
    .light-theme .bg-red-600 { background-color: #dc2626; }
    .light-theme .bg-yellow-500 { background-color: #eab308; }
    .light-theme .bg-yellow-600 { background-color: #ca8a04; }
    .light-theme .bg-pink-500 { background-color: #ec4899; }
    .light-theme .bg-pink-600 { background-color: #db2777; }
    .unowned-character { filter: grayscale(100%); background-color: #1a1a1a; opacity: 0.5; }
    .no-scroll { overflow: hidden; }
    .container { margin: 0 auto; padding: 1rem; max-width: 1280px; width: 100%; box-sizing: border-box; }
    .modal-scroll-list-pb-8 { padding-bottom: 8rem !important; }

    /* --- MODAL STYLING REFACTOR START --- */
    .modal-content-wrapper { display: flex; flex-direction: column; }
    .modal-content-wrapper:not([class*="max-h-"]) { max-height: 85vh; }
    .modal-scroll-list-container { flex-grow: 1; overflow: hidden; min-height: 50px; position: relative; }
    .modal-scroll-list { height: 100%; overflow-y: auto; padding-right: 10px; scrollbar-width: none; -ms-overflow-style: none; }
    .modal-scroll-list::-webkit-scrollbar { display: none; }
    .modal-scroll-list-pb-7 { padding-bottom: 7rem !important; }
    .modal-sticky-footer { position: sticky; bottom: 0; left: 0; right: 0; padding: 1rem; z-index: 100; flex-shrink: 0; }
    /* --- MODAL STYLING REFACTOR END --- */
    
    /* Autofuse Modal specific styles (minimal, as Tailwind and .modal-content-wrapper handle most) */
    #autofuse-modal .bg-gray-800 > div:first-of-type { flex-shrink: 0; }
    #autofuse-character-grid { overflow-y: auto; min-height: 100px; padding-right: 10px; padding-bottom: 7rem; scrollbar-width: none; -ms-overflow-style: none; gap: 8px; }
    #autofuse-character-grid::-webkit-scrollbar { display: none; }

    /* Z-index for modal buttons and list items */
    #confirm-selection, #cancel-selection, #confirm-fusion, #cancel-fusion, #confirm-give-items, #cancel-give-items,
    #confirm-evolution, #cancel-evolution, #confirm-preset, #cancel-preset, #confirm-autofuse, #cancel-autofuse,
    #confirm-pull-method, #cancel-pull-method { position: relative; z-index: 9999; }

    .modal-scroll-list > div, #autofuse-character-grid > div { position: relative; z-index: 10; }
    
    .selected-for-giving { border: 2px solid #00b7eb; box-shadow: 0 0 10px #00b7eb; }
    .selected-for-evolution { border: 2px solid #ff00ff; box-shadow: 0 0 10px #ff00ff; }

    /* Common styling for images within various displays and lists */
    #character-display img, #index-display img, #evolution-display img, .modal-scroll-list img, 
    #autofuse-character-grid img, #curse-selected-character-display img, #curse-character-selection-grid img,
    #trait-selected-character-display img, #trait-character-selection-grid img, #trait-available-list img,
    #limit-break-selected-char-display img, #limit-break-char-selection-grid img { 
      max-height: 150px; max-width: 100%; object-fit: contain; margin: 0 auto; display: block;
    }

    /* Common styling for character card divs within various displays and lists */
    #character-display > div, #index-display > div, #evolution-display > div, .modal-scroll-list > div,
    #autofuse-character-grid > div, #curse-character-selection-grid > div, 
    #trait-character-selection-grid > div, #trait-available-list > div,
    #limit-break-char-selection-grid > div { 
      padding: 10px; min-height: 150px; display: flex; flex-direction: column;
      justify-content: space-between; align-items: center; box-sizing: border-box;
    }
    
    /* Common gap for various character grids */
    #character-display, #index-display, #evolution-display, .modal-scroll-list,
    #autofuse-character-grid, #curse-character-selection-grid, #trait-character-selection-grid, 
    #trait-available-list, #limit-break-char-selection-grid { 
      gap: 8px;
    }

    #curse-selected-character-display, #trait-selected-character-display, #limit-break-selected-char-display { 
      padding: 10px; min-height: 150px; display: flex; flex-direction: column;
      justify-content: center; align-items: center;
    }

    #battle-result-modal .bg-gray-800 { animation: fadeInOut 3s ease-in-out; }
    @keyframes fadeInOut {
      0% { opacity: 0; transform: scale(0.8); } 10% { opacity: 1; transform: scale(1); }
      90% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(0.8); }
    }
    
    #standard-probabilities img, #special-probabilities img { width: 64px; height: 64px; object-fit: contain; display: block; }
    .selected-for-curse { border: 2px solid #e53e3e; box-shadow: 0 0 10px #e53e3e; }
    .stat-target-ranks-disabled label, .stat-target-ranks-disabled input[type="checkbox"] { opacity: 0.5; cursor: not-allowed; }
    .selected-for-trait { border: 2px solid #34d399; box-shadow: 0 0 10px #34d399; }
    @keyframes glowing-gold-text {
      0% { text-shadow: 0 0 5px rgba(250,204,21,0.7), 0 0 10px rgba(250,204,21,0.5); }
      50% { text-shadow: 0 0 10px rgba(250,204,21,0.9), 0 0 15px rgba(250,204,21,0.7); }
      100% { text-shadow: 0 0 5px rgba(250,204,21,0.7), 0 0 10px rgba(250,204,21,0.5); }
    }
    .text-gold-brilliant { color: #facc15; font-weight: 600; animation: glowing-gold-text 2s ease-in-out infinite; }
    
    body.dark-theme #curse { background-color: #1a0000; background-image: radial-gradient(circle, rgba(80,0,0,0.5) 1px, transparent 1.5px); background-size: 8px 8px; }
    body.dark-theme #curse h2, body.dark-theme #curse h3 { animation: glowing-red-text 2s ease-in-out infinite; }
    body.dark-theme #curse p, body.dark-theme #curse label,
    body.dark-theme #curse span:not(#cursed-token-count):not(.rainbow-text):not(.text-secret):not(.text-yellow-400):not(.text-purple-400):not(.text-gray-400):not(.text-green-400):not(.text-red-400):not(.text-blue-400) { color: #d1c4c4; }
    body.dark-theme #curse .text-gray-400 { color: #7a6b6b; }
    body.dark-theme #curse input[type="text"], body.dark-theme #curse input[type="number"] { background-color: #2a1a1a; border-color: #800000; color: #ffb3b3; box-shadow: inset 0 1px 3px rgba(0,0,0,0.5); }
    body.dark-theme #curse input[type="text"]:focus, body.dark-theme #curse input[type="number"]:focus { border-color: #ff0000; box-shadow: 0 0 8px #ff0000, inset 0 1px 3px rgba(0,0,0,0.5); }
    body.dark-theme #curse #apply-curse-button:not(:disabled) { background-color: #8c0000; animation: glowing-red 2s ease-in-out infinite; }
    body.dark-theme #curse #apply-curse-button:not(:disabled):hover { background-color: #660000; }
    body.dark-theme #curse #apply-curse-button:disabled { background-color: #5c1f1f; opacity: 0.6; }
    body.dark-theme #curse #curse-character-selection-grid > div { background-color: rgba(40, 10, 10, 0.7); border-color: #5c1f1f; }
    body.dark-theme #curse #curse-character-selection-grid > div:hover:not(.selected-for-curse) { border-color: #b30000; background-color: rgba(60, 10, 10, 0.85); }
    body.dark-theme #curse #curse-selected-character-display { background-color: rgba(30, 5, 5, 0.8); border: 2px solid #750000; box-shadow: 0 0 15px rgba(117, 0, 0, 0.5); }
    body.dark-theme #curse #curse-selected-character-display .text-gray-400 { color: #997777; }
    body.dark-theme #curse .my-4.p-3.bg-gray-700 { background-color: rgba(50, 20, 20, 0.5) !important; border: 1px dashed #800000; }
    body.dark-theme #curse #curse-keep-better-toggle + span { color: #ffcccc; }
    body.dark-theme #curse #curse-min-percentage:disabled { background-color: #402020; border-color: #601010;}
    body.dark-theme #curse .my-4.p-3.bg-gray-700 .text-xs.text-gray-400 { color: #b3a2a2; }
    body.dark-theme.curse-tab-active-bg { background-image: radial-gradient(ellipse at center, #4d0000 0%, #1a0000 40%, #000000 100%); background-size: cover; background-attachment: fixed; background-repeat: no-repeat; transition: background-image 0.5s ease-in-out; }
    .trait-target-disabled label, .trait-target-disabled input[type="checkbox"] { opacity: 0.5; cursor: not-allowed; }
    .non-selectable-for-battle { opacity: 0.5; cursor: not-allowed !important; }
    @keyframes vanguard-text {
      0%, 100% { color: #ec4899; text-shadow: 0 0 8px #ec4899, 0 0 12px #ec4899; } 
      50% { color: #fbcfe8; text-shadow: 0 0 10px #fbcfe8, 0 0 15px #fbcfe8; } 
    }
    @keyframes vanguard-border {
      0%, 100% { border-color: #ec4899; box-shadow: 0 0 10px #ec4899, 0 0 5px #ec4899 inset; }
      50% { border-color: #fbcfe8; box-shadow: 0 0 15px #fbcfe8, 0 0 8px #fbcfe8 inset; }
    }
    .text-vanguard { animation: vanguard-text 2.5s ease-in-out infinite; }
    .border-vanguard { animation: vanguard-border 2.5s ease-in-out infinite; }
    .hide-scrollbar::-webkit-scrollbar {
      display: none; /* Safari, Chrome, Edge, Opera */
    }

    #stats-modal > .bg-gray-800,
    #character-selection-modal > .modal-content-wrapper,
    #fusion-modal > .bg-gray-800,
    #settings-modal > .bg-gray-800,
    #reset-confirm-modal > .bg-gray-800,
    #give-items-modal > .bg-gray-800, /* Cible la div externe de la modale Donner des objets */
    #evolution-modal > .bg-gray-800,   /* Cible la div externe de la modale Évolution */
    #preset-selection-modal > .bg-gray-800,
    #autofuse-modal > .modal-content-wrapper,
    #pull-method-modal > .bg-gray-800,
    #probabilities-modal > .bg-gray-800,
    #stat-rank-probabilities-modal > .bg-gray-800,
    #curse-confirm-continue-modal > .bg-gray-800,
    #stat-change-confirm-continue-modal > .bg-gray-800,
    #trait-probabilities-modal > .bg-gray-800,
    #trait-action-confirm-modal > .bg-gray-800 {
        scrollbar-width: none;
        -ms-overflow-style: none;
    }

    #stats-modal > .bg-gray-800::-webkit-scrollbar,
    #character-selection-modal > .modal-content-wrapper::-webkit-scrollbar,
    #fusion-modal > .bg-gray-800::-webkit-scrollbar,
    #settings-modal > .bg-gray-800::-webkit-scrollbar,
    #reset-confirm-modal > .bg-gray-800::-webkit-scrollbar,
    #give-items-modal > .bg-gray-800::-webkit-scrollbar,
    #evolution-modal > .bg-gray-800::-webkit-scrollbar,
    #preset-selection-modal > .bg-gray-800::-webkit-scrollbar,
    #autofuse-modal > .modal-content-wrapper::-webkit-scrollbar,
    #pull-method-modal > .bg-gray-800::-webkit-scrollbar,
    #probabilities-modal > .bg-gray-800::-webkit-scrollbar,
    #stat-rank-probabilities-modal > .bg-gray-800::-webkit-scrollbar,
    #curse-confirm-continue-modal > .bg-gray-800::-webkit-scrollbar,
    #stat-change-confirm-continue-modal > .bg-gray-800::-webkit-scrollbar,
    #trait-probabilities-modal > .bg-gray-800::-webkit-scrollbar,
    #trait-action-confirm-modal > .bg-gray-800::-webkit-scrollbar {
        display: none;
    }

    /* S'assurer que les listes internes scrollables cachent aussi leur scrollbar */
    /* (elles devraient déjà le faire avec .modal-scroll-list, mais pour être sûr) */
    #stat-change-char-selection-grid,
    #curse-character-selection-grid,
    #trait-character-selection-grid,
    #limit-break-char-selection-grid,
    #fusion-selection-list,
    #item-selection-list,
    #preset-selection-list,
    #evolution-selection-list, /* Déjà .modal-scroll-list mais ajout explicite pour test */
    #character-selection-list, /* Déjà .modal-scroll-list mais ajout explicite pour test */
    #autofuse-character-grid { /* Déjà stylé mais ajout explicite pour test */
        scrollbar-width: none;
        -ms-overflow-style: none;
    }

    #stat-change-char-selection-grid::-webkit-scrollbar,
    #curse-character-selection-grid::-webkit-scrollbar,
    #trait-character-selection-grid::-webkit-scrollbar,
    #limit-break-char-selection-grid::-webkit-scrollbar,
    #fusion-selection-list::-webkit-scrollbar,
    #item-selection-list::-webkit-scrollbar,
    #preset-selection-list::-webkit-scrollbar,
    #evolution-selection-list::-webkit-scrollbar,
    #character-selection-list::-webkit-scrollbar,
    #autofuse-character-grid::-webkit-scrollbar {
        display: none;
    }

    body {
      scrollbar-gutter: stable;
    }

    /* --- Mission Tab Styles --- */
    #mission-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); /* Responsive grid */
        gap: 1rem;
    }

    .mission-card {
        background-color: rgba(41, 53, 76, 0.7); /* Darker, slightly transparent blue-gray */
        border: 1px solid #4a5568;
        border-radius: 0.75rem;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        transition: all 0.2s ease-in-out;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        position: relative; /* Pour le badge "Terminé" */
    }

    .mission-card.completed {
        background-color: rgba(22, 78, 99, 0.7); /* Dark cyan for completed */
        border-color: #0891b2;
    }

    .progress-bar-bg {
        background-color: #2d3748; /* Gray-700 */
        border-radius: 9999px;
        height: 0.75rem;
        overflow: hidden;
        width: 100%;
    }

    .progress-bar-fill {
        background-color: #4299e1; /* Blue-400 */
        height: 100%;
        border-radius: 9999px;
        transition: width 0.5s ease-out;
    }

    .mission-card.completed .progress-bar-fill {
        background-color: #2dd4bf; /* Teal-400 for completed */
    }

    .mission-reward {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        background-color: rgba(0,0,0,0.2);
        padding: 0.5rem 0.75rem;
        border-radius: 9999px;
        align-self: flex-start; /* Make the reward bubble only as wide as its content */
    }

    .mission-completed-badge {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
        background-color: #10b981; /* Green-500 */
        color: white;
        padding: 0.25rem 0.5rem;
        border-radius: 9999px;
        font-size: 0.75rem;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }

    @keyframes damage-popup {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-80px) scale(1.5); opacity: 0; }
    }
    .damage-number {
      position: absolute;
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffdd57; /* Jaune/Or */
      text-shadow: 1px 1px 2px black;
      animation: damage-popup 0.7s ease-out forwards;
      pointer-events: none; /* Important pour ne pas bloquer les clics */
      user-select: none;
    }
    #mini-game-boss-image.hit {
      transform: scale(0.98);
      filter: brightness(1.2);
    }
      
  </style>
  <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore-compat.js"></script>
</head>
<body class="bg-gradient-to-br from-purple-900 via-indigo-800 to-blue-900 min-h-screen flex items-center justify-center dark-theme sm:p-4">

  <!-- NOUVEAU: Conteneur pour l'authentification et l'état du jeu -->
  <div id="app-container" class="container mx-auto p-4 sm:p-6">
    <h1 class="text-3xl sm:text-5xl font-extrabold text-white drop-shadow-lg text-center mb-6">Gacha Anime Ultime</h1>

    <!-- Zone d'authentification (visible si non connecté) -->
    <div id="auth-container" class="bg-white bg-opacity-10 backdrop-blur-lg rounded-xl p-4 sm:p-8 max-w-md mx-auto shadow-2xl">
      <div id="login-view">
        <h2 class="text-2xl text-white font-bold mb-4 text-center">Connexion</h2>
        <form id="login-form">
          <!-- MODIFIÉ: Input pour le pseudo -->
          <input type="text" id="login-username" placeholder="Pseudo" class="w-full p-2 mb-3 bg-gray-700 text-white rounded border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
          <input type="password" id="login-password" placeholder="Mot de passe" class="w-full p-2 mb-4 bg-gray-700 text-white rounded border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
          <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Se connecter</button>
        </form>
        <p class="text-center text-gray-300 text-sm mt-4">
          Pas de compte ? <a href="#" id="show-signup" class="text-blue-400 hover:underline">S'inscrire</a>
        </p>
      </div>
      <div id="signup-view" class="hidden">
        <h2 class="text-2xl text-white font-bold mb-4 text-center">Inscription</h2>
        <form id="signup-form">
          <!-- MODIFIÉ: Input pour le pseudo -->
          <input type="text" id="signup-username" placeholder="Pseudo (3-15 caractères)" class="w-full p-2 mb-3 bg-gray-700 text-white rounded border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
          <input type="password" id="signup-password" placeholder="Mot de passe (6 caractères min.)" class="w-full p-2 mb-4 bg-gray-700 text-white rounded border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500" required>
          <button type="submit" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Créer un compte</button>
        </form>
        <p class="text-center text-gray-300 text-sm mt-4">
          Déjà un compte ? <a href="#" id="show-login" class="text-blue-400 hover:underline">Se connecter</a>
        </p>
      </div>
      <p id="auth-error" class="text-red-400 text-center mt-4"></p>
    </div>

    <!-- Zone de statut utilisateur (visible si connecté) -->
    <div id="user-status" class="hidden text-center text-white mb-4">
      <p>Bienvenue, <span id="user-email" class="font-bold"></span> !</p>
      <button id="logout-button" class="mt-2 bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 text-sm rounded-lg">Déconnexion</button>
    </div>
    
    <!-- MODIFIÉ: Le conteneur du jeu est maintenant caché par défaut -->
    <div id="game-container" class="hidden bg-white bg-opacity-10 backdrop-blur-lg rounded-xl p-4 sm:p-8 max-w-full mx-auto shadow-2xl">
      <div class="flex flex-col sm:flex-row justify-between items-center mb-4 gap-4">
        <!-- L'ancien H1 a été déplacé en haut -->
        <!-- Le bouton Paramètres reste ici -->
        <button id="settings-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition transform hover:scale-105">
          Paramètres
        </button>
      </div>

      <div class="flex flex-col sm:flex-row items-center mb-6 gap-4 sm:gap-6 flex-wrap">
        <div class="text-sm sm:text-lg text-white flex flex-wrap items-center gap-2 sm:gap-4">
          <p>Niveau: <span id="level">1</span></p>
          <p>EXP: <span id="exp">0</span>/<span id="exp-needed">100</span></p>
          <p>Gemmes: <span id="gems">1000</span></p>
          <p>Pièces: <span id="coins">0</span></p>
          <p>Tirages: <span id="pull-count">0</span></p>
        </div>
        <div class="flex flex-wrap gap-2 sm:gap-4">
          <button id="pull-button" class="bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 sm:px-6 rounded-lg transition transform hover:scale-105 text-sm sm:text-base">
            Tirer x1 (100 gemmes)
          </button>
          <button id="multi-pull-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 sm:px-6 rounded-lg transition transform hover:scale-105 text-sm sm:text-base">
            Tirer x10 (1000 gemmes)
          </button>
          <button id="special-pull-button" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 sm:px-6 rounded-lg transition transform hover:scale-105 text-sm sm:text-base">
            Bannière Spéciale x1 (150 gemmes)
          </button>
          <button id="special-multi-pull-button" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 sm:px-6 rounded-lg transition transform hover:scale-105 text-sm sm:text-base">
            Bannière Spéciale x10 (1500 gemmes)
          </button>
          <button id="info-button" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition transform hover:scale-105 text-sm sm:text-base">
            i
          </button>
        </div>
        <div class="w-full flex justify-center sm:justify-start text-xs text-gray-300 mt-2 gap-2 sm:gap-4">
          <p>Pity Standard (Mythic): <span id="standard-pity-display">0</span>/10000</p>
          <p>Pity Spéciale (Bannière): <span id="special-pity-display">0</span>/85000</p>
        </div>
      </div>
      <div id="result" class="text-center mb-6 p-4 bg-gray-800 bg-opacity-50 rounded-lg">
        <p class="text-white text-sm sm:text-lg">Tire pour obtenir des personnages légendaires !</p>
      </div>
      <div class="mb-6">
        <div class="flex flex-wrap border-b border-gray-600">
          <button id="tab-play" class="px-4 py-2 text-white font-semibold border-b-2 border-blue-500 focus:outline-none tab-button" data-tab="play">Jouer</button>
          <button id="tab-inventory" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 focus:outline-none tab-button" data-tab="inventory">Inventaire</button>
          <button id="tab-missions" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 focus:outline-none tab-button" data-tab="missions">Missions</button>
          <button id="tab-shop" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 focus:outline-none tab-button" data-tab="shop">Boutique</button>
          <button id="tab-evolution" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 focus:outline-none tab-button" data-tab="evolution">Évolution</button>
          <button id="tab-stat-change" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 focus:outline-none tab-button" data-tab="stat-change">Changer Stat</button>
          <button id="tab-curse" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 focus:outline-none tab-button hidden" data-tab="curse">Curse</button>
          <button id="tab-trait" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 focus:outline-none tab-button" data-tab="trait">Traits</button>
          <button id="tab-limit-break" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 focus:outline-none tab-button" data-tab="limit-break">Limit Break</button>
          <button id="tab-index" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 focus:outline-none tab-button" data-tab="index">Index</button>
        </div>
        <div id="tab-content" class="mt-4">
          <div id="play" class="p-4 bg-gray-800 bg-opacity-50 rounded-lg">
            <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Jouer</h2>
            <div class="flex border-b border-gray-600 mb-4">
              <button id="subtab-story" class="px-4 py-2 text-white font-semibold border-b-2 border-blue-500 subtab-button" data-subtab="story">Histoire</button>
              <button id="subtab-legende" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 subtab-button" data-subtab="legende">Legende</button>
              <button id="subtab-challenge" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 subtab-button" data-subtab="challenge">Challenge</button>
              <button id="subtab-materiaux" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 subtab-button" data-subtab="materiaux">Matériaux</button>
            </div>
            <div id="subtab-content-play">
              <div id="story" class="p-4">
                <div id="level-list" class="grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3"></div>
              </div>
              <div id="legende" class="hidden p-4">
                <div id="legende-level-list" class="grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3"></div>
              </div>
              <div id="challenge" class="hidden p-4">
                <div id="challenge-level-list" class="grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3"></div>
              </div>
              <div id="materiaux" class="hidden p-4">
                <div id="materiaux-level-list">
                  <!-- Le contenu sera entièrement généré par JavaScript -->
                </div>
              </div>
            </div>
          </div>
          <div id="inventory" class="hidden p-4 bg-gray-800 bg-opacity-50 rounded-lg">
            <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Inventaire</h2>
            <div class="flex border-b border-gray-600 mb-4">
              <button id="subtab-units" class="px-4 py-2 text-white font-semibold border-b-2 border-blue-500 subtab-button" data-subtab="units">Units</button>
              <button id="subtab-items" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 subtab-button" data-subtab="items">Items</button>
            </div>
            <div id="subtab-content">
              <div id="units" class="p-4">
                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 mb-6 p-4 bg-gray-700 bg-opacity-30 rounded-lg">
                    <div>
                        <label for="inventory-filter-name" class="text-white mr-2 block mb-1 text-sm">Filtrer par Nom:</label>
                        <input type="text" id="inventory-filter-name" class="bg-gray-600 text-white p-2 rounded w-full text-sm" placeholder="Entrez un nom...">
                    </div>
                    <div>
                        <label for="inventory-filter-rarity" class="text-white mr-2 block mb-1 text-sm">Filtrer par Rareté:</label>
                        <select id="inventory-filter-rarity" class="bg-gray-600 text-white p-2 rounded w-full text-sm">
                            <option value="all">Toutes</option>
                            <option value="Rare">Rare</option>
                            <option value="Épique">Épique</option>
                            <option value="Légendaire">Légendaire</option>
                            <option value="Mythic">Mythic</option>
                            <option value="Secret">Secret</option>
                            <option value="Vanguard">Vanguard</option>
                        </select>
                    </div>
                    <div>
                        <label for="sort-criteria-secondary" class="text-white mr-2 block mb-1 text-sm">Trier par :</label>
                        <select id="sort-criteria-secondary" class="bg-gray-600 text-white p-2 rounded w-full text-sm">
                            <option value="none">Aucun</option>
                            <option value="power">Puissance</option>
                            <option value="rarity">Rareté</option>
                            <option value="level">Niveau</option>
                            <option value="name">Nom</option>
                        </select>
                    </div>
                    <div class="col-span-1 sm:col-span-2 md:col-span-3 grid grid-cols-1 sm:grid-cols-3 gap-3 mt-2">
                        <div>
                            <label class="flex items-center text-white cursor-pointer">
                                <input type="checkbox" id="inventory-filter-evolvable" class="mr-2 h-4 w-4 text-blue-500 border-gray-500 rounded focus:ring-blue-400">
                                <span class="text-sm">Évoluable</span>
                            </label>
                        </div>
                        <div>
                            <label class="flex items-center text-white cursor-pointer">
                                <input type="checkbox" id="inventory-filter-limitbreak" class="mr-2 h-4 w-4 text-blue-500 border-gray-500 rounded focus:ring-blue-400">
                                <span class="text-sm">Limit Break Possible</span>
                            </label>
                        </div>
                        <div>
                            <label class="flex items-center text-white cursor-pointer">
                                <input type="checkbox" id="inventory-filter-canreceiveexp" class="mr-2 h-4 w-4 text-blue-500 border-gray-500 rounded focus:ring-blue-400">
                                <span class="text-sm">Peut recevoir EXP</span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row justify-end mb-4 gap-4">
                  <div class="flex gap-4">
                    <button id="open-preset-modal-button" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition transform hover:scale-105">
                      Enregistrer Preset
                    </button>
                    <button id="delete-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition transform hover:scale-105">
                      Activer le mode suppression
                    </button>
                  </div>
                </div>
                <div id="character-display" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"></div>
              </div>
              <div id="items" class="hidden p-4">
                <div id="item-display" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"></div>
              </div>
            </div>
          </div>
          <div id="missions" class="hidden p-4 bg-gray-800 bg-opacity-50 rounded-lg">
            <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Missions (Renouvellent dans <span id="mission-timer"></span>)</h2>
            <div id="mission-list" class="grid gap-2 grid-cols-1 sm:grid-cols-2"></div>
          </div>
          <div id="shop" class="hidden p-4 bg-gray-800 bg-opacity-50 rounded-lg">
            <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Boutique (Offres renouvellent dans <span id="shop-timer"></span>)</h2>
            <div id="shop-items" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4"></div>
          </div>
          <div id="index" class="hidden p-4 bg-gray-800 bg-opacity-50 rounded-lg">
            <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Index des Personnages</h2>
            <div id="index-display" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"></div>
          </div>

          <div id="evolution" class="hidden p-4 bg-gray-800 bg-opacity-50 rounded-lg">
            <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Évolution des Personnages</h2>
            <div id="evolve-char" class="p-4">
                <div id="evolution-display" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4"></div>
            </div>
          </div>

          <div id="stat-change" class="hidden p-4 bg-gray-800 bg-opacity-50 rounded-lg">
            <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Changer le Rang de Stat
                <button id="stat-rank-info-button" class="ml-2 bg-gray-600 hover:bg-gray-500 text-white font-bold py-1 px-2 rounded-full text-xs transition transform hover:scale-110">
                    i
                </button>
            </h2>
            <p class="text-white mb-2">Stat Chips: <span id="stat-chip-count">0</span></p>
            
            <div class="mb-4">
                <h4 class="text-md text-white font-semibold mb-1">Personnage Sélectionné:</h4>
                <div id="stat-change-selected-char-display" class="p-4 bg-gray-700 bg-opacity-50 rounded-lg min-h-[100px] flex justify-center items-center">
                    <p class="text-gray-400">Aucun personnage sélectionné.</p>
                </div>
            </div>

            <div class="mb-2">
                <label for="stat-change-search" class="text-white mr-2 text-sm sm:text-base">Rechercher par nom:</label>
                <input type="text" id="stat-change-search" class="bg-gray-700 text-white p-2 rounded w-full sm:w-auto text-sm sm:text-base" placeholder="Nom du personnage...">
            </div>

            <div class="mb-4">
                <h4 class="text-md text-white font-semibold mb-1">Choisissez un Personnage:</h4>
                <div id="stat-change-char-selection-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 max-h-[35vh] sm:max-h-[40vh] overflow-y-auto pr-2">
                </div>
            </div>

            <div class="my-4 p-3 bg-gray-700 bg-opacity-30 rounded-lg">
                <label class="flex items-center text-white mb-2">
                    <input type="checkbox" id="stat-keep-better-toggle" class="mr-2 h-5 w-5 text-teal-500 border-gray-500 rounded focus:ring-teal-400">
                    Garder le Stat Chip si le nouveau rang est :
                </label>
                <div id="stat-target-ranks-selection" class="grid grid-cols-3 sm:grid-cols-6 gap-2 mt-1 mb-2 stat-target-ranks-disabled">
                </div>
                <p class="text-xs text-gray-400 mt-1">Si coché, vous pouvez sélectionner les rangs cibles. Le bouton "Changer Stat" restera actif tant qu'un rang cible n'est pas atteint. Un Stat Chip est consommé à chaque tentative. Le nouveau rang obtenu est toujours appliqué.</p>
            </div>

            <button id="apply-stat-change-button" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-lg transition transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Changer Stat (1 Stat Chip)
            </button>
          </div>
          
          <div id="curse" class="hidden p-4 bg-gray-800 bg-opacity-50 rounded-lg">
            <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Curse a Character</h2>
            <p class="text-white mb-4">Cursed Tokens: <span id="cursed-token-count">0</span></p>
            
            <div class="mb-4">
                <h3 class="text-lg text-white font-semibold mb-1">Selectionner un personnage pour le Curse:</h3>
                <div id="curse-selected-character-display" class="p-4 bg-gray-700 bg-opacity-50 rounded-lg min-h-[100px] flex justify-center items-center">
                    <p class="text-gray-400">Pas de personnages selectionner.</p>
                </div>
            </div>

            <div class="mb-2">
                <label for="curse-char-search" class="text-white mr-2 text-sm sm:text-base">Rechercher par nom:</label>
                <input type="text" id="curse-char-search" class="bg-gray-700 text-white p-2 rounded w-full sm:w-auto text-sm sm:text-base" placeholder="Nom du personnage...">
            </div>
        
            <div class="mb-4">
                <h3 class="text-lg text-white font-semibold mb-1">Selectionner un personnage pour le Curse:</h3>
                <div id="curse-character-selection-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 max-h-[35vh] sm:max-h-[40vh] overflow-y-auto pr-2">
                </div>
            </div>
        
            <div class="my-4 p-3 bg-gray-700 bg-opacity-30 rounded-lg">
                <label class="flex items-center text-white mb-2">
                    <input type="checkbox" id="curse-keep-better-toggle" class="mr-2 h-5 w-5 text-red-600 border-gray-500 rounded focus:ring-red-500">
                    Garder la malédiction si meilleure ou égale à :
                </label>
                <div class="flex items-center">
                    <input type="number" id="curse-min-percentage" value="0" min="-20" max="20" step="1" class="bg-gray-600 text-white p-2 rounded w-20 text-center mr-2 appearance-none [-moz-appearance:_textfield] [&::-webkit-outer-spin-button]:m-0 [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:m-0 [&::-webkit-inner-spin-button]:appearance-none" disabled>
                    <span class="text-white">%</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">Si coché, la malédiction ne sera appliquée que si le nouveau pourcentage d'effet est supérieur ou égal à la valeur spécifiée ET supérieur à la malédiction actuelle (si positive) ou moins négative (si négative). Sinon, le token est consommé sans effet.</p>
            </div>

            <button id="apply-curse-button" class="bg-red-700 hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg transition transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Reroll Curse (1 Cursed Token)
            </button>
          </div>

          <div id="trait" class="hidden p-4 bg-gray-800 bg-opacity-50 rounded-lg">
            <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">
                Gérer les Traits du Personnage
                <button id="trait-probabilities-info-button" class="ml-2 bg-gray-600 hover:bg-gray-500 text-white font-bold py-1 px-2 rounded-full text-xs transition transform hover:scale-110">
                    i
                </button>
            </h2>
            <p class="text-white mb-4">Reroll Token: <span id="trait-essence-count">0</span></p>
        
            <div class="mb-6">
                <h3 class="text-lg text-white font-semibold mb-2">Personnage Sélectionné :</h3>
                <div id="trait-selected-character-display" class="p-4 bg-gray-700 bg-opacity-50 rounded-lg min-h-[180px] flex justify-center items-center">
                    <p class="text-gray-400">Aucun personnage sélectionné.</p>
                </div>
            </div>
        
            <div class="mb-6">
                <div class="mb-2">
                    <label for="trait-char-search" class="text-white mr-2 text-sm sm:text-base">Rechercher par nom:</label>
                    <input type="text" id="trait-char-search" class="bg-gray-700 text-white p-2 rounded w-full sm:w-auto text-sm sm:text-base" placeholder="Nom du personnage...">
                </div>
                <h3 class="text-lg text-white font-semibold mb-2">Choisissez un Personnage :</h3>
                <div id="trait-character-selection-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3 max-h-[40vh] sm:max-h-[35vh] overflow-y-auto pr-2">
                </div>
            </div>

            <div class="my-4 p-3 bg-gray-700 bg-opacity-30 rounded-lg">
              <label class="flex items-center text-white mb-2">
                  <input type="checkbox" id="trait-keep-better-toggle" class="mr-2 h-5 w-5 text-emerald-500 border-gray-500 rounded focus:ring-emerald-400">
                  Continuer à appliquer si le nouveau trait est :
              </label>
              <div id="trait-target-selection" class="grid grid-cols-2 sm:grid-cols-3 gap-2 mt-1 mb-2 trait-target-disabled">
              </div>
              <p class="text-xs text-gray-400 mt-1">Si coché, vous pouvez sélectionner des traits/grades cibles. Le bouton "Appliquer Trait Aléatoire" demandera confirmation si un trait cible est déjà actif et que vous souhaitez continuer. Un Reroll Token est consommé à chaque tentative. Le nouveau trait obtenu est toujours appliqué.</p>
            </div>
        
            <div id="trait-actions-container" class="mt-4 pt-4 border-t border-gray-700">
            </div>
          </div>


          <div id="limit-break" class="hidden p-4 bg-gray-800 bg-opacity-50 rounded-lg">
            <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Limit Break (Briser les Limites)</h2>
            <p class="text-white mb-4">Divin Wish : <span id="transcendence-orb-count">0</span></p>

            <div class="mb-4">
                <h3 class="text-lg text-white font-semibold mb-1">Personnage Sélectionné :</h3>
                <div id="limit-break-selected-char-display" class="p-4 bg-gray-700 bg-opacity-50 rounded-lg min-h-[100px] flex justify-center items-center">
                    <p class="text-gray-400">Aucun personnage sélectionné.</p>
                </div>
            </div>

            <div class="mb-2">
                <label for="limit-break-char-search" class="text-white mr-2 text-sm sm:text-base">Rechercher par nom:</label>
                <input type="text" id="limit-break-char-search" class="bg-gray-700 text-white p-2 rounded w-full sm:w-auto text-sm sm:text-base" placeholder="Nom du personnage...">
            </div>

            <div class="mb-4">
                <h3 class="text-lg text-white font-semibold mb-1">Choisissez un Personnage :</h3>
                <div id="limit-break-char-selection-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 max-h-[35vh] sm:max-h-[40vh] overflow-y-auto pr-2">
                </div>
            </div>

            <button id="apply-limit-break-button" class="bg-amber-500 hover:bg-amber-600 text-white font-bold py-2 px-4 rounded-lg transition transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed" disabled>Briser la Limite (1 Divin Wish)</button>
            <p class="text-xs text-gray-400 mt-2">Augmente le niveau maximum du personnage de 5. Nécessite que le personnage soit à son niveau maximum actuel. Le cap ultime est de 100.</p>
          </div>
        </div>
      </div>

      <div id="stats" class="mb-6 p-4 bg-gray-800 bg-opacity-50 rounded-lg">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Statistiques</h2>
        <p class="text-white text-sm sm:text-base">Rare: <span id="rare-count">0</span></p>
        <p class="text-white text-sm sm:text-base">Épique: <span id="epic-count">0</span></p>
        <p class="text-white text-sm sm:text-base">Légendaire: <span id="legendary-count">0</span></p>
        <p class="text-white text-sm sm:text-base">Mythic: <span id="mythic-count">0</span></p>
        <p class="text-white text-sm sm:text-base">Secret: <span id="secret-count">0</span></p>
      </div>
    </div> <!-- Fin de game-container -->

    <!-- Toutes vos modales (stats-modal, character-selection-modal, etc.) restent ici, inchangées -->
    <!-- Modal for Character Stats -->
    <div id="stats-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-md max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Statistiques du Personnage</h2>
        <div id="modal-content" class="text-white text-sm sm:text-base"></div>
        <div class="flex flex-wrap gap-4 mt-4"> 
          <button id="give-items-button" class="bg-purple-500 hover:bg-purple-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Donner des objets</button>
          <button id="fuse-button" class="bg-yellow-500 hover:bg-yellow-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Fusionner</button>
          <button id="lock-button" class="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Verrouiller</button> 
          <button id="close-modal" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Fermer</button>
          </div>
      </div>
    </div>

    <!-- Modal for Character Selection in Story Mode -->
    <div id="character-selection-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="modal-content-wrapper bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <h2 id="character-selection-title" class="text-xl sm:text-2xl text-white font-bold mb-4">Sélectionner 3 Personnages pour le Combat</h2>
        
        <div class="flex flex-col sm:flex-row flex-wrap justify-between items-center mb-4 gap-3">
          <div class="flex-grow sm:flex-grow-0">
            <label for="battle-search-name" class="text-white mr-2 text-sm sm:text-base">Nom:</label>
            <input type="text" id="battle-search-name" class="bg-gray-700 text-white p-2 rounded text-sm sm:text-base w-full sm:w-auto" placeholder="Rechercher...">
          </div>
          <div class="flex-grow sm:flex-grow-0">
            <label for="battle-filter-rarity" class="text-white mr-2 text-sm sm:text-base">Rareté:</label>
            <select id="battle-filter-rarity" class="bg-gray-700 text-white p-2 rounded text-sm sm:text-base w-full sm:w-auto">
              <option value="all">Toutes</option>
              <option value="Rare">Rare</option>
              <option value="Épique">Épique</option>
              <option value="Légendaire">Légendaire</option>
              <option value="Mythic">Mythic</option>
              <option value="Secret">Secret</option>
              <option value="Vanguard">Vanguard</option>
            </select>
          </div>
          <div class="flex-grow sm:flex-grow-0">
            <label for="battle-sort-criteria" class="text-white mr-2 text-sm sm:text-base">Trier par:</label>
            <select id="battle-sort-criteria" class="bg-gray-700 text-white p-2 rounded text-sm sm:text-base w-full sm:w-auto">
              <option value="power">Puissance</option>
              <option value="rarity">Rareté</option>
              <option value="level">Niveau</option>
            </select>
          </div>
        </div>
    
        <div id="character-selection-list-container" class="modal-scroll-list-container max-h-[55vh] sm:max-h-[60vh]">
          <div id="character-selection-list" class="modal-scroll-list modal-scroll-list-pb-7 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mb-4"></div>
        </div>
        <p class="text-white mb-4 text-sm sm:text-base">Personnages sélectionnés: <span id="selected-count">0</span>/3</p>
        <div class="modal-sticky-footer flex gap-4 bg-gray-800 bg-opacity-90 -mx-4 -mb-4 rounded-b-lg">
          <button id="load-preset-button" class="bg-purple-500 hover:bg-purple-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Charger Preset</button>
          <button id="confirm-selection" class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base" disabled>Confirmer</button>
          <button id="cancel-selection" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for Fusion -->
    <div id="fusion-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Fusionner le Personnage</h2>
        
        <!-- NOUVELLE SECTION DE FILTRES POUR FUSION -->
        <div class="flex flex-col sm:flex-row flex-wrap justify-between items-center mb-4 gap-3">
            <div class="flex-grow sm:flex-grow-0">
                <label for="fusion-search-name" class="text-white mr-2 text-sm sm:text-base">Nom:</label>
                <input type="text" id="fusion-search-name" class="bg-gray-700 text-white p-2 rounded text-sm sm:text-base w-full sm:w-auto" placeholder="Rechercher...">
            </div>
            <div class="flex-grow sm:flex-grow-0">
                <label for="fusion-filter-rarity" class="text-white mr-2 text-sm sm:text-base">Rareté:</label>
                <select id="fusion-filter-rarity" class="bg-gray-700 text-white p-2 rounded text-sm sm:text-base w-full sm:w-auto">
                <option value="all">Toutes</option>
                <option value="Rare">Rare</option>
                <option value="Épique">Épique</option>
                <option value="Légendaire">Légendaire</option>
                <option value="Mythic">Mythic</option>
                <option value="Secret">Secret</option>
                <option value="Vanguard">Vanguard</option>
                </select>
            </div>
            <!-- Note: Le tri n'est généralement pas nécessaire pour la sélection de matériaux de fusion, mais pourrait être ajouté ici si désiré -->
        </div>
        <!-- FIN NOUVELLE SECTION -->

        <div id="fusion-selection-list-container" class="max-h-[55vh] sm:max-h-[60vh] overflow-hidden">
          <div id="fusion-selection-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mb-4 max-h-[55vh] sm:max-h-[60vh] overflow-y-auto"></div>
        </div>
        <p class="text-white mb-4 text-sm sm:text-base">Personnages sélectionnés pour la fusion: <span id="fusion-selected-count">0</span></p>
        <div class="flex gap-4 sticky bottom-0 bg-gray-800 bg-opacity-90 p-4 -mx-4 -mb-4 rounded-b-lg">
          <button id="confirm-fusion" class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base" disabled>Confirmer</button>
          <button id="cancel-fusion" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for Settings -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-md max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Paramètres</h2>
        <div class="text-white mb-4 text-sm sm:text-base">
          <label class="flex items-center">
            <input type="checkbox" id="sound-toggle" class="mr-2">
            Activer le son
          </label>
          <label class="flex items-center mt-2">
            <input type="checkbox" id="animations-toggle" class="mr-2">
            Activer les animations
          </label>
          <div class="mt-2">
            <label for="theme-select" class="block">Thème:</label>
            <select id="theme-select" class="bg-gray-700 text-white p-2 rounded w-full text-sm sm:text-base">
              <option value="dark">Sombre</option>
              <option value="light">Clair</option>
            </select>
          </div>
          <div class="mt-4">
            <p class="font-semibold">Vente automatique des personnages :</p>
            <label class="flex items-center mt-2">
              <input type="checkbox" id="autosell-rare" class="mr-2">
              Rare
            </label>
            <label class="flex items-center mt-2">
              <input type="checkbox" id="autosell-epic" class="mr-2">
              Épique
            </label>
            <label class="flex items-center mt-2">
              <input type="checkbox" id="autosell-legendary" class="mr-2">
              Légendaire
            </label>
            <label class="flex items-center mt-2">
              <input type="checkbox" id="autosell-mythic" class="mr-2">
              Mythic
            </label>
            <label class="flex items-center mt-2">
              <input type="checkbox" id="autosell-secret" class="mr-2">
              Secret
            </label>
          </div>
          <button id="autofuse-settings-button" class="mt-4 bg-orange-500 hover:bg-orange-600 text-white py-2 px-4 rounded-lg w-full text-sm sm:text-base">
            Multifusion
          </button>
          <button id="reset-game" class="mt-4 bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg w-full text-sm sm:text-base">
            Réinitialiser la partie
          </button>
        </div>
        <div class="flex gap-4">
          <button id="save-settings" class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Sauvegarder</button>
          <button id="close-settings" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Fermer</button>
        </div>
      </div>
    </div>

    <!-- Modal for Reset Confirmation -->
    <div id="reset-confirm-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-md max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Confirmer la réinitialisation</h2>
        <p class="text-white mb-4 text-sm sm:text-base">Voulez-vous vraiment réinitialiser votre partie ? Toutes vos données seront perdues.</p>
        <div class="flex gap-4">
          <button id="confirm-reset" class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Confirmer</button>
          <button id="cancel-reset" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for Giving Items -->
    <div id="give-items-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Donner des Objets au Personnage</h2>
        <div id="item-selection-list-container" class="max-h-[60vh] overflow-hidden">
          <div id="item-selection-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mb-4 max-h-[60vh] overflow-y-auto"></div>
        </div>
        <p class="text-white mb-4 text-sm sm:text-base">Objets sélectionnés: <span id="item-selected-count">0</span></p>
        <div class="flex gap-4 sticky bottom-0 bg-gray-800 bg-opacity-90 p-4 -mx-4 -mb-4 rounded-b-lg">
          <button id="confirm-give-items" class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base" disabled>Confirmer</button>
          <button id="cancel-give-items" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for Evolution -->
    <div id="evolution-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Évoluer le Personnage</h2>
        <div id="evolution-requirements" class="text-white mb-4 text-sm sm:text-base"></div>
        <div id="evolution-selection-list-container" class="max-h-[60vh] overflow-hidden">
          <div id="evolution-selection-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mb-4 max-h-[60vh] overflow-y-auto"></div>
        </div>
        <p class="text-white mb-4 text-sm sm:text-base">Objets sélectionnés: <span id="evolution-selected-count">0</span></p>
        <div class="flex gap-4 sticky bottom-0 bg-gray-800 bg-opacity-90 p-4 -mx-4 -mb-4 rounded-b-lg">
          <button id="confirm-evolution" class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base" disabled>Confirmer</button>
          <button id="cancel-evolution" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for Battle Result -->
    <div id="battle-result-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-md max-h-[90vh] overflow-y-auto text-center">
        <h2 id="battle-result-title" class="text-2xl sm:text-3xl text-white font-bold mb-4"></h2>
        <p id="battle-result-message" class="text-white mb-4 text-sm sm:text-base"></p>
      </div>
    </div>

    <!-- Modal for Preset Selection -->
    <div id="preset-selection-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <h2 id="preset-selection-modal-title" class="text-xl sm:text-2xl text-white font-bold mb-4">Sélectionner 3 Personnages pour le Preset</h2>
        
        <!-- NOUVELLE SECTION DE FILTRES ET TRI POUR PRESET -->
        <div class="flex flex-col sm:flex-row flex-wrap justify-between items-center mb-4 gap-3">
            <div class="flex-grow sm:flex-grow-0">
                <label for="preset-search-name" class="text-white mr-2 text-sm sm:text-base">Nom:</label>
                <input type="text" id="preset-search-name" class="bg-gray-700 text-white p-2 rounded text-sm sm:text-base w-full sm:w-auto" placeholder="Rechercher...">
            </div>
            <div class="flex-grow sm:flex-grow-0">
                <label for="preset-filter-rarity" class="text-white mr-2 text-sm sm:text-base">Rareté:</label>
                <select id="preset-filter-rarity" class="bg-gray-700 text-white p-2 rounded text-sm sm:text-base w-full sm:w-auto">
                <option value="all">Toutes</option>
                <option value="Rare">Rare</option>
                <option value="Épique">Épique</option>
                <option value="Légendaire">Légendaire</option>
                <option value="Mythic">Mythic</option>
                <option value="Secret">Secret</option>
                <option value="Vanguard">Vanguard</option>
                </select>
            </div>
            <div class="flex-grow sm:flex-grow-0">
                <label for="preset-sort-criteria" class="text-white mr-2 text-sm sm:text-base">Trier par:</label>
                <select id="preset-sort-criteria" class="bg-gray-700 text-white p-2 rounded text-sm sm:text-base w-full sm:w-auto">
                <option value="power">Puissance</option>
                <option value="rarity">Rareté</option>
                <option value="level">Niveau</option>
                </select>
            </div>
        </div>
        <!-- FIN NOUVELLE SECTION -->

        <div id="preset-selection-list-container" class="max-h-[55vh] sm:max-h-[60vh] overflow-hidden">
          <div id="preset-selection-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mb-4 max-h-[55vh] sm:max-h-[60vh] overflow-y-auto"></div>
        </div>
        <p class="text-white mb-4 text-sm sm:text-base">Personnages sélectionnés: <span id="preset-selected-count-display">0/3</span></p>
        <div class="flex gap-4 sticky bottom-0 bg-gray-800 bg-opacity-90 p-4 -mx-4 -mb-4 rounded-b-lg">
          <button id="confirm-preset" class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base" disabled>Confirmer</button>
          <button id="cancel-preset" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for Autofusion -->
    <div id="autofuse-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="modal-content-wrapper bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Multifusion</h2>
        <div class="mb-4">
          <p class="text-white block mb-2 text-sm sm:text-base">Personnage principal sélectionné :</p>
          <div id="autofuse-main-character" class="mb-4"></div>
          <p class="text-white block mb-2 text-sm sm:text-base">Sélectionnez le personnage principal :</p>
          <div id="autofuse-character-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 max-h-[300px] overflow-y-auto pr-2"></div>
        </div>
        <p class="text-white mb-2 text-sm sm:text-base">Sélectionnez les raretés à fusionner automatiquement :</p>
        <div id="autofuse-rarity-selection" class="flex flex-wrap gap-4 mb-4">
          <label class="flex items-center">
            <input type="checkbox" id="autofuse-rare" class="mr-2">
            <span class="text-gray-400 text-sm sm:text-base">Rare</span>
          </label>
          <label class="flex items-center">
            <input type="checkbox" id="autofuse-epic" class="mr-2">
            <span class="text-purple-400 text-sm sm:text-base">Épique</span>
          </label>
          <label class="flex items-center">
            <input type="checkbox" id="autofuse-legendary" class="mr-2">
            <span class="text-yellow-400 text-sm sm:text-base">Légendaire</span>
          </label>
          <label class="flex items-center">
            <input type="checkbox" id="autofuse-mythic" class="mr-2">
            <span class="rainbow-text text-sm sm:text-base">Mythic</span>
          </label>
          <label class="flex items-center">
            <input type="checkbox" id="autofuse-secret" class="mr-2">
            <span class="text-yellow-400 text-sm sm:text-base">Secret</span>
          </label>
        </div>
        <p class="text-white mb-4 text-sm sm:text-base">Personnages à fusionner : <span id="autofuse-count">0</span></p>
        <div class="modal-sticky-footer flex gap-4 bg-gray-800 bg-opacity-90 p-4 -mx-4 -mb-4">
          <button id="confirm-autofuse" class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base" disabled>Confirmer</button>
          <button id="cancel-autofuse" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for Pull Method Selection -->
    <div id="pull-method-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-md max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Choisir la méthode de tirage</h2>
        <p class="text-white mb-4 text-sm sm:text-base">Comment voulez-vous effectuer ce tirage ?</p>
        <div class="flex flex-col gap-4">
          <button id="pull-with-gems" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Utiliser des gemmes</button>
          <button id="pull-with-ticket" class="bg-purple-500 hover:bg-purple-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Utiliser un ticket</button>
          <button id="cancel-pull-method" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Annuler</button>
        </div>
      </div>
    </div>

    <!-- Modal for Pull Probabilities -->
    <div id="probabilities-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Probabilités des Tirages</h2>
        <div class="flex border-b border-gray-600 mb-4">
          <button id="prob-standard-tab" class="px-4 py-2 text-white font-semibold border-b-2 border-blue-500 prob-tab-button" data-tab="standard">Tirage Standard</button>
          <button id="prob-special-tab" class="px-4 py-2 text-white font-semibold border-b-2 border-transparent hover:border-blue-500 prob-tab-button" data-tab="special">Bannière Spéciale</button>
        </div>
        <div id="prob-tab-content">
          <div id="prob-standard" class="p-4">
            <h3 class="text-lg sm:text-xl text-white font-semibold mb-2">Tirage Standard (x1 ou x10)</h3>
            <div id="standard-probabilities" class="grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3"></div>
          </div>
          <div id="prob-special" class="hidden p-4">
            <h3 class="text-lg sm:text-xl text-white font-semibold mb-2">Bannière Spéciale</h3>
            <div id="special-probabilities" class="grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3"></div>
          </div>
        </div>
        <div class="flex gap-4 mt-4">
          <button id="close-probabilities" class="bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Fermer</button>
        </div>
      </div>
    </div>

    <!-- Modal for Stat Rank Probabilities -->
    <div id="stat-rank-probabilities-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-sm max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Probabilités des Rangs de Stat</h2>
        <div id="stat-rank-probabilities-content" class="text-white text-sm sm:text-base space-y-2">
        </div>
        <div class="flex justify-end mt-6">
          <button id="close-stat-rank-probabilities-modal-button" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Fermer</button>
        </div>
      </div>
    </div>

    <!-- Modal for Curse Confirmation -->
    <div id="curse-confirm-continue-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-[9000]">
      <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md shadow-xl">
        <h2 class="text-xl text-white font-bold mb-4">Confirmer l'action</h2>
        <p id="curse-confirm-message" class="text-white mb-6">Message de confirmation ici.</p>
        <div class="flex justify-end gap-4">
          <button id="curse-confirm-yes-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">
            Oui, continuer
          </button>
          <button id="curse-confirm-no-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">
            Non, annuler
          </button>
        </div>
      </div>
    </div>

    <!-- Modal for Stat Change Confirmation -->
    <div id="stat-change-confirm-continue-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-[9000]">
      <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md shadow-xl">
        <h2 class="text-xl text-white font-bold mb-4">Confirmer l'action</h2>
        <p id="stat-change-confirm-message" class="text-white mb-6">Message de confirmation ici.</p>
        <div class="flex justify-end gap-4">
          <button id="stat-change-confirm-yes-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">
            Oui, continuer
          </button>
          <button id="stat-change-confirm-no-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">
            Non, annuler
          </button>
        </div>
      </div>
    </div>

    <!-- Modal for Trait Probabilities -->
    <div id="trait-probabilities-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-[8000]">
      <div class="bg-gray-800 p-4 sm:p-6 rounded-lg w-full max-w-md max-h-[90vh] overflow-y-auto">
        <h2 class="text-xl sm:text-2xl text-white font-bold mb-4">Probabilités des Traits</h2>
        <div id="trait-probabilities-content" class="text-white text-sm sm:text-base space-y-2">
            <!-- Les probabilités des types de traits seront injectées ici par JavaScript -->
        </div>
        <div class="flex justify-end mt-6">
          <button id="close-trait-probabilities-modal-button" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base">Fermer</button>
        </div>
      </div>
    </div>

    <div id="trait-action-confirm-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-[9000]">
        <div class="bg-gray-800 p-6 rounded-lg w-full max-w-md shadow-xl">
            <h2 class="text-xl text-white font-bold mb-4">Confirmer l'action de Trait</h2>
            <p id="trait-action-confirm-message" class="text-white mb-6">Message de confirmation ici.</p>
            <div class="flex justify-end gap-4">
            <button id="trait-action-confirm-yes-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">
                Oui, continuer
            </button>
            <button id="trait-action-confirm-no-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">
                Non, annuler
            </button>
            </div>
          </div>
        </div>
      
    <!-- Modal for Mini-Game -->
    <div id="mini-game-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-[10000]">
      <div id="mini-game-arena" class="bg-gray-900 p-4 sm:p-6 rounded-lg w-full max-w-2xl text-center shadow-lg border-4 border-red-500" style="background-image: url('https://i.pinimg.com/originals/a1/81/d7/a181d76a163158485de067262b947c2b.gif'); background-size: cover; background-position: center;">
        
        <!-- Écran de démarrage -->
        <div id="mini-game-start-screen">
          <h2 id="mini-game-title" class="text-3xl text-white font-bold drop-shadow-md mb-4">Défi du Boss !</h2>
          <p id="mini-game-instructions" class="text-white mb-6">Vous avez 30 secondes pour vaincre le boss. La puissance de votre équipe détermine vos dégâts par clic. Préparez-vous !</p>
          <button id="mini-game-start-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-xl transition transform hover:scale-105">
            Commencer !
          </button>
        </div>

        <!-- Écran de jeu principal (caché au début) -->
        <div id="mini-game-main-screen" class="hidden">
          <div class="relative mb-4">
            <h2 id="mini-game-boss-name" class="text-2xl text-yellow-300 font-bold drop-shadow-lg">Titan des Abysses</h2>
            <!-- Barre de vie du boss -->
            <div class="w-full bg-gray-700 rounded-full h-8 border-2 border-gray-500 mt-2">
              <div id="mini-game-boss-health-bar" class="bg-red-600 h-full rounded-full transition-all duration-100 ease-linear" style="width: 100%;"></div>
              <span id="mini-game-boss-health-text" class="absolute inset-0 flex items-center justify-center text-white font-bold">100%</span>
            </div>
            <!-- Chronomètre -->
            <div id="mini-game-timer" class="absolute -top-2 -right-2 bg-blue-500 text-white text-2xl font-bold py-2 px-4 rounded-full">30</div>
          </div>
          
          <!-- Zone de clic (le boss) -->
          <div id="mini-game-click-area" class="relative mt-4">
            <img id="mini-game-boss-image" src="https://static.wikia.nocookie.net/animeadventures/images/4/4b/Cooler_%28Final%29_Icon.png/revision/latest?cb=20220917173200" alt="Boss" class="mx-auto h-64 cursor-pointer transition-transform duration-75 ease-out hover:scale-105 active:scale-95">
            <!-- Conteneur pour les numéros de dégâts -->
            <div id="mini-game-damage-container" class="absolute inset-0"></div>
          </div>
        </div>

        <!-- Écran de résultat (victoire/défaite) -->
        <div id="mini-game-result-screen" class="hidden">
          <h2 id="mini-game-result-title" class="text-4xl font-bold mb-4"></h2>
          <p id="mini-game-result-rewards" class="text-white mb-6"></p>
          <button id="mini-game-close-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg text-lg">
            Fermer
          </button>
        </div>

      </div>
    </div>
  
  <script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
        try {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row => row.some(filledCell));
          var headerRowIndex = filteredData.findIndex((row, index) =>
            row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
          );
          if (headerRowIndex === -1 || headerRowIndex > 25) {
            headerRowIndex = 0;
          }
          var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
          csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
          return csv;
        } catch (e) {
          console.error(e);
          return "";
        }
      }
      return gk_fileData[filename] || "";
    }
  </script>

  <script>
    const standardCharacters = [
        { name: "Goku", rarity: "Rare", color: "text-gray-400", image: "./images/goku.webp", power: 350, level: 1 },
        { name: "Naruto", rarity: "Rare", color: "text-gray-400", image: "./images/naruto.webp", power: 370, level: 1 },
        { name: "Luffy", rarity: "Rare", color: "text-gray-400", image: "./images/luffy.webp", power: 370, level: 1 },
        { name: "Ichigo", rarity: "Rare", color: "text-gray-400", image: "./images/ichigo.webp", power: 360, level: 1 },
        { name: "Sanji", rarity: "Rare", color: "text-gray-400", image: "./images/sanji.webp", power: 355, level: 1 },
        { name: "Crocodile", rarity: "Épique", color: "text-purple-400", image: "./images/crocodile.webp", power: 550, level: 1 },
        { name: "Killua", rarity: "Épique", color: "text-purple-400", image: "./images/killua.webp", power: 550, level: 1 },
        { name: "Picolo", rarity: "Épique", color: "text-purple-400", image: "./images/picolo.webp", power: 560, level: 1 },
        { name: "Zenitsu", rarity: "Épique", color: "text-purple-400", image: "./images/zenitsu.webp", power: 570, level: 1 },
        { name: "Goku Black", rarity: "Légendaire", color: "text-yellow-400", image: "./images/goku black.webp", power: 800, level: 1 },
        { name: "Gon", rarity: "Légendaire", color: "text-yellow-400", image: "./images/gon.webp", power: 820, level: 1 },
        { name: "Kizaru", rarity: "Légendaire", color: "text-yellow-400", image: "./images/kizaru.webp", power: 820, level: 1 },
        { name: "Itachi", rarity: "Légendaire", color: "text-yellow-400", image: "./images/itachi.webp", power: 820, level: 1 },
        { name: "Pain", rarity: "Légendaire", color: "text-yellow-400", image: "./images/pain.webp", power: 850, level: 1 },
        { name: "Toge", rarity: "Légendaire", color: "text-yellow-400", image: "./images/toge.webp", power: 860, level: 1 },
        {
          name: "Sung Jin Wu",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/sung jin wu.webp",
          power: 1250,
          level: 1,
          evolutionRequirements: [ { item: "Shadow Tracer", quantity: 3 }, { coins: 50000 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 } ],
          evolutionData: {
              newName: "Sung Jin Wu (Monarch)",
              newImage: "./images/sung jin wu monarch.webp",
              basePowerIncrease: 500
          }
        },
        {
            name: "Satoru Gojo",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/gojo.webp",
            power: 1100,
            level: 1,
            evolutionRequirements: [ { item: "Six Eyes", quantity: 5 }, { item: "Green Essence", quantity: 40 }, { item: "Blue Essence", quantity: 30 }, { item: "Red Essence", quantity: 30 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 100000 } ],
            evolutionData: {
                newName: "Satoru Gojo (Infinity)",
                newImage: "./images/satoru gojo (infinity).webp",
                basePowerIncrease: 800, 
                newRarity: "Secret",   
                newColor: "text-secret" 
            }
        },
        {
          name: "Archer",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/archer.webp",
          power: 1200,
          level: 1,
          evolutionRequirements: [ { item: "Cast Blades", quantity: 5 }, { coins: 50000 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 } ],
          evolutionData: {
              newName: "Archer (Counter Spirit)",
              newImage: "./images/archer (counter spirit).webp",
              basePowerIncrease: 500
          }
        },
        {
          name: "Cha Hae-In",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/cha.webp",
          power: 1080,
          level: 1,
          evolutionRequirements: [ { item: "Broken Sword", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 75000 } ],
          evolutionData: {
              newName: "Cha Hae-In (Sword Dance)",
              newImage: "./images/cha hae-in (sword dance).webp",
              basePowerIncrease: 500
          }
        },
        {
          name: "Kenpachi Zaraki",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/kenpachi.webp",
          power: 1150,
          level: 1,
          evolutionRequirements: [ { item: "Chipped Blade", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 75000 } ],
          evolutionData: {
              newName: "Kenpachi Zaraki (Shikai)",
              newImage: "./images/kenpachi zaraki (shikai).webp",
              basePowerIncrease: 500
          }
        },
        {
            name: "Choso",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/choso.webp",
            power: 1180,
            level: 1,
            evolutionRequirements: [ { item: "Hardened Blood", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 75000 } ],
            evolutionData: {
                newName: "Choso (Blood Curse)",
                newImage: "./images/choso (blood curse).webp",
                basePowerIncrease: 590
            }
        },
        {
          name: "Yuji Itadori", 
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/itadori.webp",
          power: 1220,
          level: 1,
          evolutionRequirements: [ { item: "Cursed Finger", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 75000 } ],
          evolutionData: {
              newName: "Sukuna",
              newImage: "./images/sukuna.webp",
              basePowerIncrease: 600,
              newRarity: "Secret",
              newColor: "text-secret"
          }
        },
        {
            name: "Jogo",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/jogo.webp",
            power: 1240,
            level: 1,
            evolutionRequirements: [ { item: "Magma Stone", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Jogo (Volcanic)",
                newImage: "./images/jogo (volcanic).webp",
                basePowerIncrease: 580
            }
        },
        {
            name: "Aoi Todo",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/todo.webp",
            power: 1120,
            level: 1,
            evolutionRequirements: [ { item: "Broken Pendant", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Aoi Todo (Unleashed)",
                newImage: "./images/aoi todo (unleashed).webp",
                basePowerIncrease: 600
            }
        },
        {
            name: "Akaza",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/akaza.webp",
            power: 1280,
            level: 1,
            evolutionRequirements: [ { item: "Demon Beads", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Pink Essence", quantity: 10 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Akaza (Destructive)",
                newImage: "./images/akaza (destructive).webp",
                basePowerIncrease: 620
            }
        },
        {
            name: "Tengen Uzui",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/tengen.webp",
            power: 1230,
            level: 1,
            evolutionRequirements: [ { item: "Nichirin Cleavers", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Tengen Uzui (Flashiness)",
                newImage: "./images/tengen uzui (flashiness).webp",
                basePowerIncrease: 590
            }
        },
        {
            name: "Naruto (Sage)",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/naruto (sage).webp",
            power: 1270,
            level: 1,
            evolutionRequirements: [ { item: "Blue Chakra", quantity: 5 }, { item: "Red Chakra", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Naruto (Six Tails)",
                newImage: "./images/Naruto (Six Tails).webp",
                basePowerIncrease: 610
            }
        },
        {
            name: "Obito Uchiha",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/obito.webp",
            power: 1240,
            level: 1,
            evolutionRequirements: [ { item: "Skin Patch", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Obito Uchiha (Awakened)",
                newImage: "./images/Obito Uchiha (Awakened).webp",
                basePowerIncrease: 600
            }
        },
        {
            name: "Sasuke (Hebi)",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/sasuke (hebi).webp",
            power: 1250,
            level: 1,
            evolutionRequirements: [ { item: "Snake Scale", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Sasuke (Storm)",
                newImage: "./images/Sasuke (Storm).webp",
                basePowerIncrease: 610
            }
        },
        {
            name: "Vegeta (Super)",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/vegeta (super).webp",
            power: 1290,
            level: 1,
            evolutionRequirements: [ { item: "Senzu Bean", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Vegeta (Super Awakened)",
                newImage: "./images/Vegeta (Super Awakened).webp",
                basePowerIncrease: 620
            }
        },
        {
          name: "Alucard",
          rarity: "Secret",
          color: "text-yellow-400",
          image: "./images/alucard.webp",
          power: 1400,
          level: 1,
          evolutionRequirements: [ { item: "Hellsing Arms", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 100000 } ],
          evolutionData: {
              newName: "Alucard (Vampire King)",
              newImage: "./images/Alucard (Vampire King).webp",
              basePowerIncrease: 750
          }
        },
        {
          name: "Yamamoto",
          rarity: "Secret",
          color: "text-yellow-400",
          image: "./images/yamamoto.webp",
          power: 1500,
          level: 1,
          evolutionRequirements: [ { item: "Head Captain's Coat", quantity: 5 }, { coins: 100000 }, { item: "Green Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 } ],
          evolutionData: {
              newName: "Yamamoto (Captain)",
              newImage: "./images/Yamamoto (Captain).webp",
              basePowerIncrease: 750
          }
        },
        {
          name: "Regnaw", 
          rarity: "Secret",
          color: "text-yellow-400", 
          image: "./images/regnaw.webp",
          power: 1510, 
          level: 1,
          evolutionRequirements: [ { item: "Silverite Sword", quantity: 1 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 100000 } ],
          evolutionData: {
              newName: "Regnaw (Rage)",
              newImage: "./images/Regnaw (Rage).webp",
              basePowerIncrease: 750
          }
        },
        {
          name: "Giro",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/giro.webp",
          power: 1250,
          level: 1,
          evolutionRequirements: [ { item: "Holy Corpse Eyes", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Giro (Ball Breaker)",
            newImage: "./images/Giro (Ball Breaker).webp",
            basePowerIncrease: 550
          }
        },
        {
          name: "Johnni",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/johnni.webp",
          power: 1260,
          level: 1,
          evolutionRequirements: [ { item: "Holy Corpse Arms", quantity: 1 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Johnni (Infinite Spin)",
            newImage: "./images/Johnni (Infinite Spin).webp",
            basePowerIncrease: 600
          }
        },
        {
          name: "Valentine",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/valentine.webp",
          power: 1300,
          level: 1,
          evolutionRequirements: [ { item: "Completed Holy Corpse", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 750000 } ],
          evolutionData: {
            newName: "Valentine (Love Train)",
            newImage: "./images/Valentine (Love Train).webp",
            basePowerIncrease: 700,
            newRarity: "Secret",
            newColor: "text-secret"
          }
        },
        {
          name: "Medusa",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/medusa.webp",
          power: 1280,
          level: 1,
          evolutionRequirements: [ { item: "Gorgon's Blindfold", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Medusa (Gorgon)",
            newImage: "./images/Medusa (Gorgon).webp",
            basePowerIncrease: 580
          }
        },
        {
          name: "Medea",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/medea.webp",
          power: 1290,
          level: 1,
          evolutionRequirements: [ { item: "Caster's Headpiece", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Medea (Witch of Betrayal)",
            newImage: "./images/Medea (Witch of Betrayal).webp",
            basePowerIncrease: 590
          }
        },
        {
          name: "Saber",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/saber.webp",
          power: 1300,
          level: 1,
          evolutionRequirements: [ { item: "Avalon", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Saber (King of Knights)",
            newImage: "./images/Saber (King of Knights).webp",
            basePowerIncrease: 610
          }
        },
        {
          name: "Ishtar",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/ishtar.webp",
          power: 1300,
          level: 1,
          evolutionRequirements: [ { item: "Goddess' Sword", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Ishtar (Divinity)",
            newImage: "./images/Ishtar (Divinity).webp",
            basePowerIncrease: 600
          }
        },
        {
          name: "Cu Chulainn",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/cu chulainn.webp",
          power: 1290,
          level: 1,
          evolutionRequirements: [ { item: "Blade of Death", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Cu Chulainn (Child of Light)",
            newImage: "./images/Cu Chulainn (Child of Light)",
            basePowerIncrease: 580
          }
        },
        {
          name: "Lilia",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/lilia.webp",
          power: 1310,
          level: 1,
          evolutionRequirements: [ { item: "Berserker's Blade", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Lilia and Berserker",
            newImage: "./images/Lilia and Berserker.webp",
            basePowerIncrease: 600
          }
        },
        {
          name: "Yoruichi",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/yoruichi.webp",
          power: 1330,
          level: 1,
          evolutionRequirements: [ { item: "Shunpo Spirit", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins:50000 } ],
          evolutionData: {
            newName: "Yoruichi (Raijin)",
            newImage: "./images/Yoruichi (Raijin).webp",
            basePowerIncrease: 620
          }
        },
        {
          name: "Uryu",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/uryu.webp",
          power: 1340,
          level: 1,
          evolutionRequirements: [ { item: "Energy Arrow", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Uryu (Antithesis)",
            newImage: "./images/Uryu (Antithesis).webp",
            basePowerIncrease: 630
          }
        },
        {
          name: "Orihime",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/orihime.webp",
          power: 1260,
          level: 1,
          evolutionRequirements: [ { item: "Hair Ornament", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Orihime (Faith)",
            newImage: "./images/Orihime (Faith).webp",
            basePowerIncrease: 570
          }
        },
         {
          name: "Kisuke",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/kisuke.webp",
          power: 1280,
          level: 1,
          evolutionRequirements: [ { item: "Bucket Hat", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Kisuke (Scientist)",
            newImage: "./images/Kisuke (Scientist).webp",
            basePowerIncrease: 590
          }
        },
        {
          name: "Ichigo (True Release)",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/ichigo (true release).webp",
          power: 1350,
          level: 1,
          evolutionRequirements: [ { item: "Horn of Salvation", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Purple Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 5 }, { coins: 50000 } ],
          evolutionData: {
            newName: "Ichigo (Savior)",
            newImage: "./images/Ichigo (Savior).webp",
            basePowerIncrease: 650 
          }
        },
        {
          name: "Giselle",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/giselle.webp",
          power: 1270,
          level: 1,
          evolutionRequirements: [ { item: "Energy Bone", quantity: 1 }, { item: "Green Essence", quantity: 30 }, { item: "Purple Essence", quantity: 15 }, { item: "Blue Essence", quantity: 20 }, { item: "Yellow Essence", quantity: 12 }, { item: "Rainbow Essence", quantity: 2 }, { coins:50000 } ],
          evolutionData: {
            newName: "Giselle (Zombie)",
            newImage: "./images/Giselle (Zombie).webp",
            basePowerIncrease: 580
          }
        },
        {
          name: "Aizen",
          rarity: "Mythic",
          color: "rainbow-text",
          image: "./images/aizen.webp",
          power: 1320,
          level: 1,
          evolutionRequirements: [ { item: "Prison Chair", quantity: 1 }, { item: "Green Essence", quantity: 30 }, { item: "Blue Essence", quantity: 12 }, { item: "Yellow Essence", quantity: 12 }, { item: "Purple Essence", quantity: 15 }, { item: "Rainbow Essence", quantity: 2 }, { coins: 75000 } ],
            evolutionData: {
                newName: "Aizen (Aura)",
                newImage: "./images/Aizen (Aura).webp",
                basePowerIncrease: 730,
                newRarity: "Secret",
                newColor: "text-secret"
            }
        },
        {
            name: "Goku (Angel)",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/goku (angel).webp",
            power: 1300,
            level: 1,
            evolutionRequirements: [ { item: "Rotara Earring 2", quantity: 1 }, { item: "Rotara Earring 1", quantity: 1 }, { item: "Green Essence", quantity: 40 }, { item: "Red Essence", quantity: 30 }, { item: "Blue Essence", quantity: 30 }, { item: "Rainbow Essence", quantity: 3 }, { coins: 75000 } ],
            evolutionData: {
                newName: "Roku (Super 3)",
                newImage: "./images/Goku (Super 3).webp",
                basePowerIncrease: 850,
                newRarity: "Secret",
                newColor: "text-secret"
            }
        },
        {
            name: "Gohan (Adult)",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/gohan (adult).webp",
            power: 1300,
            level: 1,
            evolutionRequirements: [ { item: "Z Blade", quantity: 12 }, { item: "Green Essence", quantity: 30 }, { item: "Red Essence", quantity: 10 }, { item: "Purple Essence", quantity: 5 }, { item: "Yellow Essence", quantity: 5 }, { item: "Blue Essence", quantity: 15 }, { item: "Rainbow Essence", quantity: 1 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Ultimate Gohan",
                newImage: "./images/Ultimate Gohan.webp",
                basePowerIncrease: 700
            }
        },
        {
            name: "Hercules",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/hercules.webp",
            power: 1280,
            level: 1,
            evolutionRequirements: [ { item: "Champ's Belt", quantity: 12 }, { item: "Green Essence", quantity: 30 }, { item: "Red Essence", quantity: 15 }, { item: "Purple Essence", quantity: 20 }, { item: "Blue Essence", quantity: 5 }, { item: "Yellow Essence", quantity: 15 }, { item: "Rainbow Essence", quantity: 1 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Hercules and Mr Boo",
                newImage: "./images/Hercules and Mr Boo.webp",
                basePowerIncrease: 650
            }
        },
        {
            name: "Delta",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/delta.webp",
            power: 1250,
            level: 1,
            evolutionRequirements: [ { item: "Dog Bone", quantity: 1 }, { item: "Green Essence", quantity: 30 }, { item: "Red Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 1 }, { coins: 50000 } ],
            evolutionData: {
                newName: "Delta (Hunt)",
                newImage: "./images/Delta (Hunt).webp",
                basePowerIncrease: 600
            }
        },
        {
            name: "Subaru Natsuki",
            rarity: "Secret",
            color: "text-secret",
            image: "./images/subaru.webp",
            power: 1500,
            level: 1,
            evolutionRequirements: [ { item: "Tome of Wisdom", quantity: 1 }, { coins: 100000 } ],
            evolutionData: {
                newName: "Subaru Natsuki (Contract)", 
                newImage: "./images/Subaru Natsuki (Contract).webp",
                basePowerIncrease: 800,
            }
        },
        {
            name: "Artoria Pendragon (Alternate)",
            rarity: "Secret",
            color: "text-secret", 
            image: "./images/artoria pendragon (alternate).webp",
            power: 1510,
            level: 1,
            evolutionRequirements: [ { item: "Corrupted Visor", quantity: 1 }, { item: "Green Essence", quantity: 40 }, { item: "Blue Essence", quantity: 12 }, { item: "Yellow Essence", quantity: 12 }, { item: "Red Essence", quantity: 15 }, { item: "Rainbow Essence", quantity: 1 }, { coins: 30000 } ],
            evolutionData: {
                newName: "Artoria Pendragon (Black Tyrant)",
                newImage: "./images/Artoria Pendragon (Black Tyrant).webp",
                basePowerIncrease: 900,
            }
        },
        {
            name: "Sakura Matou",
            rarity: "Secret",
            color: "text-secret",
            image: "./images/sakura.webp",
            power: 1550,
            level: 1,
            evolutionRequirements: [ { item: "Tainted Ribbon", quantity: 1 }, { item: "Green Essence", quantity: 40 }, { item: "Yellow Essence", quantity: 12 }, { item: "Pink Essence", quantity: 15 }, { item: "Red Essence", quantity: 12 }, { item: "Rainbow Essence", quantity: 1 }, { coins: 100000 } ],
            evolutionData: {
                newName: "Sakura (Angra Mainyu)",
                newImage: "./images/Sakura (Angra Mainyu).webp",
                basePowerIncrease: 950,
            }
        },
        {
            name: "Esdeath",
            rarity: "Secret",
            color: "text-secret",
            image: "./images/esdeath.webp",
            power: 1520,
            level: 1,
            evolutionRequirements: [ { item: "Demon Chalice", quantity: 1 }, { coins: 100000 } ],
            evolutionData: {
                newName: "Esdeath (Romantic)",
                newImage: "./images/Esdeath (Romantic).webp",
                basePowerIncrease: 800,
            }
        },
        {
            name: "Yhwach",
            rarity: "Secret",
            color: "text-secret",
            image: "./images/yhwach.webp",
            power: 1530, 
            level: 1,
            evolutionRequirements: [ { item: "Essence of the Spirit King", quantity: 1 }, { item: "Green Essence", quantity: 40 }, { item: "Blue Essence", quantity: 12 }, { item: "Purple Essence", quantity: 15 }, { item: "Red Essence", quantity: 12 }, { item: "Rainbow Essence", quantity: 1 }, { coins: 30000 } ],
            evolutionData: {
                newName: "Yhwach (Almighty)",
                newImage: "./images/Yhwach (Almighty).webp",
                basePowerIncrease: 790,
            }
        },
        {
            name: "Frieren",
            rarity: "Secret",
            color: "text-secret",
            image: "./images/frieren.webp",
            power: 1520,
            level: 1,
            evolutionRequirements: [ { item: "Ring of Friendship", quantity: 1 }, { coins: 10000 } ],
            evolutionData: {
                newName: "Frieren (Teacher)",
                newImage: "./images/Frieren (Teacher).webp",
                basePowerIncrease: 780,
            }
        },
        {
            name: "Choi Jong-In",
            rarity: "Secret",
            color: "text-secret",
            image: "./images/choi jong-in.webp",
            power: 1550, 
            level: 1,
            evolutionRequirements: [ { item: "Red Jewel", quantity: 5 }, { item: "Green Essence", quantity: 40 }, { item: "Blue Essence", quantity: 12 }, { item: "Purple Essence", quantity: 12 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 1 }, { coins: 100000 } ],
            evolutionData: {
                newName: "Choi Jong-In (Guild Leader)", 
                newImage: "./images/Choi Jong-In (Guild Leader).webp",
                basePowerIncrease: 800,
            }
        },
        {
            name: "Boo",
            rarity: "Secret",
            color: "text-secret",
            image: "./images/boo.webp",
            power: 1550,
            level: 1,
            evolutionRequirements: [ { item: "Majan Essence", quantity: 12 }, { item: "Green Essence", quantity: 40 }, { item: "Red Essence", quantity: 12 }, { item: "Pink Essence", quantity: 20 }, { item: "Blue Essence", quantity: 12 }, { item: "Rainbow Essence", quantity: 2 }, { coins: 30000 } ],
            evolutionData: {
                newName: "Boo (Evil)",
                newImage: "./images/Boo (Evil).webp",
                basePowerIncrease: 830,
            }
        },
        {
            name: "Katakuri",
            rarity: "Secret",
            color: "text-secret",
            image: "./images/katakuri.webp",
            power: 1750,
            level: 1,
            evolutionRequirements: [ { item: "Donut", quantity: 5 }, { coins: 100000 } ],
            evolutionData: {
                newName: "Katakuri (Mochi)",
                newImage: "./images/Katakuri (Mochi).webp",
                basePowerIncrease: 800,
            }
        },
        {
            name: "Cid Kagenou",
            rarity: "Secret",
            color: "text-secret",
            image: "./images/cid kagenou.webp",
            power: 1580,
            level: 1,
            evolutionRequirements: [ { item: "Atomic Essence", quantity: 1 }, { item: "Green Essence", quantity: 40 }, { item: "Red Essence", quantity: 30 }, { item: "Blue Essence", quantity: 30 }, { item: "Rainbow Essence", quantity: 3 }, { coins: 30000 } ],
            evolutionData: {
                newName: "Shadow", 
                newImage: "./images/shadow.webp",
                basePowerIncrease: 800,
            }
        },
        {
            name: "NotGoodGuy",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/notgoodguy.webp",
            power: 1260,
            level: 1,
            evolutionRequirements: [ { item: "Restricting Headband", quantity: 12 }, { item: "Green Essence", quantity: 30 }, { item: "Purple Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 1 }, { coins: 15000 } ],
            evolutionData: {
                newName: "NotGoodGuy (Free)",
                newImage: "./images/NotGoodGuy (Free).webp",
                basePowerIncrease: 650
            }
        },
        {
            name: "Kazzy",
            rarity: "Mythic",
            color: "rainbow-text",
            image: "./images/kazzy.webp",
            power: 1300,
            level: 1,
            evolutionRequirements: [ { item: "Toil Ribbon", quantity: 12 }, { item: "Green Essence", quantity: 40 }, { item: "Blue Essence", quantity: 20 }, { item: "Red Essence", quantity: 30 }, { item: "Rainbow Essence", quantity: 3 }, { coins: 30000 } ],
            evolutionData: {
                newName: "Kazzy (Queen)",
                newImage: "./images/Kazzy (Queen).webp",
                basePowerIncrease: 600,
            }
        },
      ];

    const specialCharacters = [
        {
          name: "Gogeta's Super Saiyan 4",
          rarity: "Vanguard",
          color: "text-vanguard",
          image: "./images/gogeta's super saiyan 4.webp",
          power: 1850,
          level: 1,
          passive: { teamSizeBonus: 2 }
        },  
        {
            name: "Igris",
            rarity: "Secret",
            color: "text-yellow-400",
            image: "./images/igris.webp",
            power: 1450,
            level: 1,
            evolutionRequirements: [ { item: "Blood-Red Armor", quantity: 5 }, { item: "Green Essence", quantity: 20 }, { item: "Blue Essence", quantity: 20 }, { item: "Red Essence", quantity: 20 }, { item: "Pink Essence", quantity: 20 }, { item: "Rainbow Essence", quantity: 10 }, { coins: 100000 } ],
            evolutionData: {
                newName: "Igris (Elite Knight)",
                newImage: "./images/Igris (Elite Knight).webp",
                basePowerIncrease: 800
            }
        },
        { name: "Majin Boo (Evil)", rarity: "Secret", color: "text-secret", image: "./images/majin boo (evil).webp", power: 1550, level: 1 },
        { name: "Buuhan (Evil)", rarity: "Secret", color: "text-secret", image: "./images/buuhan (evil).webp", power: 1560, level: 1 },
        { name: "Boockleo (Evil)", rarity: "Secret", color: "text-secret", image: "./images/boockleo (evil).webp", power: 1570, level: 1 },
        { name: "Super Boo (Evil)", rarity: "Secret", color: "text-secret", image: "./images/super boo (evil).webp", power: 1520, level: 1 },
        { name: "Kid Boo (Evil)", rarity: "Secret", color: "text-secret", image: "./images/kid boo (evil).webp", power: 1580, level: 1 },
        { name: "Super Vegetto", rarity: "Secret", color: "text-secret", image: "./images/super vegetto.webp", power: 1585, level: 1 },
        { name: "Cid", rarity: "Secret", color: "text-secret", image: "./images/cid.webp", power: 1650, level: 1 },
        { name: "Kaze-sensei", rarity: "Légendaire", color: "text-purple-400", image: "https://via.placeholder.com/150?text=Kaze", power: 800, level: 1 },
        { name: "Mizu-chan", rarity: "Épique", color: "text-blue-400", image: "https://via.placeholder.com/150?text=Mizu", power: 500, level: 1 },
        { name: "Tsuchi-kun", rarity: "Rare", color: "text-gray-400", image: "https://via.placeholder.com/150?text=Tsuchi", power: 360, level: 1 },
        { name: "Sakura", rarity: "Légendaire", color: "text-pink-400", image: "https://via.placeholder.com/150?text=Sakura", power: 850, level: 1 }
    ];

    const allCharacters = [...standardCharacters, ...specialCharacters];

    const shopItemPool = [
      { type: 'gems', amount: 500, cost: 50, currency: 'coins', description: "500 gemmes" }, { type: 'gems', amount: 1200, cost: 100, currency: 'coins', description: "1200 gemmes" }, { type: 'gems', amount: 3000, cost: 200, currency: 'coins', description: "3000 gemmes" }, { type: 'pull-ticket', amount: 1, cost: 80, currency: 'coins', description: "Ticket de Tirage x1" }, { type: 'pull-ticket', amount: 3, cost: 200, currency: 'coins', description: "Ticket de Tirage x3" }, { type: 'exp-boost', amount: 2, cost: 200, currency: 'coins', description: "Boost EXP x2 (30 min)" },
    ];

    const missionPool = [
    // Missions existantes
    { id: 1, description: "Effectuer 5 tirages standards", type: "pulls", goal: 5, reward: { gems: 200 } },
    { id: 2, description: "Obtenir 3 personnages épiques", type: "epic_chars", goal: 3, reward: { gems: 300 } },
    { id: 3, description: "Vendre 5 personnages", type: "sell_chars", goal: 5, reward: { gems: 150 } },
    { id: 4, description: "Effectuer 3 tirages spéciaux", type: "special_pulls", goal: 3, reward: { gems: 250 } },
    { id: 5, description: "Gagner 500 EXP de joueur", type: "exp_gain", goal: 500, reward: { gems: 100 } },
    { id: 6, description: "Acheter 1 objet dans la boutique", type: "shop_purchase", goal: 1, reward: { gems: 120 } },
    { id: 7, description: "Obtenir 1 personnage légendaire", type: "legendary_chars", goal: 1, reward: { gems: 400 } },
    { id: 8, description: "Atteindre le niveau de joueur 5", type: "level_up", goal: 5, reward: { gems: 300 } },
    { id: 9, description: "Effectuer 15 tirages (tous types)", type: "pulls", goal: 15, reward: { gems: 350 } },
    { id: 10, description: "Vendre 5 personnages rares", type: "sell_rare_chars", goal: 5, reward: { gems: 200 } },
    { id: 11, description: "Obtenir 2 personnages de la bannière spéciale", type: "special_chars", goal: 2, reward: { gems: 280 } },
    { id: 12, description: "Gagner 1000 EXP de joueur", type: "exp_gain", goal: 1000, reward: { gems: 200 } },
    { id: 13, description: "Acheter 3 objets dans la boutique", type: "shop_purchase", goal: 3, reward: { gems: 240 } },
    // NOUVELLES MISSIONS
    { id: 14, description: "Faire évoluer un personnage", type: "evolve_char", goal: 1, reward: { gems: 500 } },
    { id: 15, description: "Terminer 5 niveaux du mode Histoire", type: "complete_story_levels", goal: 5, reward: { gems: 250 } },
    { id: 16, description: "Dépenser 5000 gemmes", type: "spend_gems", goal: 5000, reward: { gems: 300 } },
    { id: 17, description: "Fusionner 10 personnages", type: "fuse_chars", goal: 10, reward: { gems: 150 } },
    { id: 18, description: "Terminer 1 niveau du mode Légende", type: "complete_legendary_levels", goal: 1, reward: { gems: 350 } },
    { id: 19, description: "Utiliser 3 Stat Chips", type: "change_stat_rank", goal: 3, reward: { gems: 200 } },
    { id: 20, description: "Obtenir 1 personnage Mythic", type: "mythic_chars", goal: 1, reward: { gems: 800 } },
    { id: 21, description: "Briser les limites d'un personnage", type: "limit_break_char", goal: 1, reward: { gems: 400 } },
    { id: 22, description: "Appliquer 3 malédictions", type: "curse_char", goal: 3, reward: { gems: 200 } },
    { id: 23, description: "Appliquer 3 traits à des personnages", type: "apply_trait", goal: 3, reward: { gems: 200 } },
    { id: 24, description: "Terminer 1 niveau du mode Challenge", type: "complete_challenge_levels", goal: 1, reward: { gems: 150 } },
    { id: 25, description: "Dépenser 10 000 pièces", type: "spend_coins", goal: 10000, reward: { gems: 150 } }
  ];

    const baseStoryLevels = [
      // Monde 1
      { id: 1, world: "Royaume des Ombres", name: "Niveau 1: Guerrier des Ombres", enemy: { name: "Ombre", power: 250}, rewards: { gems: 80, coins: 100, exp: 50 }, unlocked: true, completed: false, type: 'story' }, 
      { id: 2, world: "Royaume des Ombres", name: "Niveau 2: Gardien de la Forêt", enemy: { name: "Sylve", power: 350 }, rewards: { gems: 80, coins: 100, exp: 60 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 3, world: "Royaume des Ombres", name: "Niveau 3: Seigneur des Flammes", enemy: { name: "Ignis", power: 500 }, rewards: { gems: 80, coins: 100, exp: 70 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 4, world: "Royaume des Ombres", name: "Niveau 4: Maître des Tempêtes", enemy: { name: "Tempestas", power: 700 }, rewards: { gems: 80, coins: 100, exp: 80 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 5, world: "Royaume des Ombres", name: "Niveau 5: Roi Démon", enemy: { name: "Demonis", power: 900 }, rewards: { gems: 150, coins: 80, exp: 90 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 6, world: "Royaume des Ombres", name: "Niveau 6: Spectre Lunaire", enemy: { name: "Lunaris", power: 1100}, rewards: { gems: 80, coins: 100, exp: 100 }, unlocked: false, completed: false, type: 'story' },
      // Monde 2
      { id: 7, world: "Empire de Cristal", name: "Niveau 1: Sentinelle de Quartz", enemy: { name: "Quartzis", power: 1400}, rewards: { gems: 80, coins: 100, exp: 110 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 8, world: "Empire de Cristal", name: "Niveau 2: Garde de Saphir", enemy: { name: "Sapphira", power: 1350}, rewards: { gems: 80, coins: 100, exp: 120 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 9, world: "Empire de Cristal", name: "Niveau 3: Chevalier d'Émeraude", enemy: { name: "Emeraldis", power: 1500}, rewards: { gems: 80, coins: 100, exp: 130 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 10, world: "Empire de Cristal", name: "Niveau 4: Seigneur de Rubis", enemy: { name: "Rubius", power: 1650}, rewards: { gems: 80, coins: 100, exp: 140 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 11, world: "Empire de Cristal", name: "Niveau 5: Roi de Diamant", enemy: { name: "Diamantis", power: 1800}, rewards: { gems: 80, coins: 100, exp: 150 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 12, world: "Empire de Cristal", name: "Niveau 6: Oracle de Cristal", enemy: { name: "Crystalia", power: 1950}, rewards: { gems: 80, coins: 100, exp: 160 }, unlocked: false, completed: false, type: 'story' },
      // Monde 3
      { id: 13, world: "Profondeurs Abyssales", name: "Niveau 1: Ombre des Fonds", enemy: { name: "Abyssal Shade", power: 2100}, rewards: { gems: 80, coins: 100, exp: 170 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 14, world: "Profondeurs Abyssales", name: "Niveau 2: Kraken des Mers", enemy: { name: "Krakenis", power: 2250}, rewards: { gems: 80, coins: 100, exp: 180 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 15, world: "Profondeurs Abyssales", name: "Niveau 3: Serpent des Abysses", enemy: { name: "Serpentra", power: 2400}, rewards: { gems: 80, coins: 100, exp: 190 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 16, world: "Profondeurs Abyssales", name: "Niveau 4: Gardien des Coraux", enemy: { name: "Coralith", power: 2550}, rewards: { gems: 80, coins: 100, exp: 200 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 17, world: "Profondeurs Abyssales", name: "Niveau 5: Léviathan", enemy: { name: "Leviathos", power: 2700}, rewards: { gems: 80, coins: 180, exp: 100 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 18, world: "Profondeurs Abyssales", name: "Niveau 6: Dieu des Abysses", enemy: { name: "Abyssara", power: 2850}, rewards: { gems: 80, coins: 100, exp: 220 }, unlocked: false, completed: false, type: 'story' },
      // Monde 4
      { id: 19, world: "Pics Célestes", name: "Niveau 1: Aigle des Cieux", enemy: { name: "Skywing", power: 3000}, rewards: { gems: 80, coins: 100, exp: 230 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 20, world: "Pics Célestes", name: "Niveau 2: Gardien des Nuages", enemy: { name: "Cloudius", power: 3150}, rewards: { gems: 80, coins: 100, exp: 240 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 21, world: "Pics Célestes", name: "Niveau 3: Phénix Étoilé", enemy: { name: "Starphoenix", power: 3300}, rewards: { gems: 80, coins: 100, exp: 250 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 22, world: "Pics Célestes", name: "Niveau 4: Dragon des Cieux", enemy: { name: "Skydra", power: 3450}, rewards: { gems: 80, coins: 100, exp: 260 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 23, world: "Pics Célestes", name: "Niveau 5: Ange Céleste", enemy: { name: "Celestia", power: 3600}, rewards: { gems: 80, coins: 100, exp: 270 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 24, world: "Pics Célestes", name: "Niveau 6: Empereur des Étoiles", enemy: { name: "Starex", power: 3750}, rewards: { gems: 80, coins: 100, exp: 280 }, unlocked: false, completed: false, type: 'story' },
      // Monde 5
      { id: 25, world: "Déserts du Vide", name: "Niveau 1: Ombre du Néant", enemy: { name: "Voidshade", power: 3900}, rewards: { gems: 80, coins: 100, exp: 290 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 26, world: "Déserts du Vide", name: "Niveau 2: Vagabond du Vide", enemy: { name: "Voidwalker", power: 4050}, rewards: { gems: 80, coins: 100, exp: 300 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 27, world: "Déserts du Vide", name: "Niveau 3: Spectre du Chaos", enemy: { name: "Chaospecter", power: 4200}, rewards: { gems: 80, Coins: 100, exp: 310 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 28, world: "Déserts du Vide", name: "Niveau 4: Titan du Néant", enemy: { name: "Voidtitan", power: 4350}, rewards: { gems: 80, coins: 100, exp: 320 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 29, world: "Déserts du Vide", name: "Niveau 5: Démon du Vide", enemy: { name: "Voidemon", power: 4500}, rewards: { gems: 80, coins: 100, exp: 330 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 30, world: "Déserts du Vide", name: "Niveau 6: Seigneur du Néant", enemy: { name: "Voidrex", power: 4650}, rewards: { gems: 80, coins: 100, exp: 340 }, unlocked: false, completed: false, type: 'story' },
      // Monde 6
      { id: 31, world: "Éclipse Éternelle", name: "Niveau 1: Ombre de l'Éclipse", enemy: { name: "Ecliptor", power: 4800}, rewards: { gems: 80, coins: 100, exp: 350 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 32, world: "Éclipse Éternelle", name: "Niveau 2: Gardien de l'Ombre", enemy: { name: "Shadowguard", power: 4950}, rewards: { gems: 80, coins: 100, exp: 360 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 33, world: "Éclipse Éternelle", name: "Niveau 3: Spectre Solaire", enemy: { name: "Solarspecter", power: 5100}, rewards: { gems: 80, coins: 100, exp: 370 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 34, world: "Éclipse Éternelle", name: "Niveau 4: Dragon de l'Éclipse", enemy: { name: "Eclipsera", power: 5250}, rewards: { gems: 80, coins: 100, exp: 380 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 35, world: "Éclipse Éternelle", name: "Niveau 5: Roi de l'Ombre", enemy: { name: "Shadowrex", power: 5400}, rewards: { gems: 80, coins: 100, exp: 390 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 36, world: "Éclipse Éternelle", name: "Niveau 6: Dieu de l'Éclipse", enemy: { name: "Eclipsegod", power: 5550}, rewards: { gems: 80, coins: 100, exp: 400 }, unlocked: false, completed: false, type: 'story' },
      // Monde 7  
      { id: 37, world: "Forêt Éthérée", name: "Niveau 1: Esspirit du Bosquet", enemy: { name: "Sylvaris", power: 5700}, rewards: { gems: 80, coins: 100, exp: 410 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 38, world: "Forêt Éthérée", name: "Niveau 2: Gardien de l'Arbre-Monde", enemy: { name: "Arborius", power: 5850}, rewards: { gems: 80, coins: 100, exp: 420 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 39, world: "Forêt Éthérée", name: "Niveau 3: Fée des Brumes", enemy: { name: "Mistalia", power: 6000}, rewards: { gems: 80, coins: 100, exp: 430 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 40, world: "Forêt Éthérée", name: "Niveau 4: Chaman des Anciens", enemy: { name: "Elderglow", power: 6150}, rewards: { gems: 80, coins: 100, exp: 440 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 41, world: "Forêt Éthérée", name: "Niveau 5: Entité Sylvestre", enemy: { name: "Forestheart", power: 6300}, rewards: { gems: 80, coins: 100, exp: 450 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 42, world: "Forêt Éthérée", name: "Niveau 6: Reine Éthérée", enemy: { name: "Aetheria", power: 6450}, rewards: { gems: 80, coins: 100, exp: 460 }, unlocked: false, completed: false, type: 'story' },
      // Monde 8
      { id: 43, world: "Cieux Fracturés", name: "Niveau 1: Éclaireur des Étoiles", enemy: { name: "Starseeker", power: 6600}, rewards: { gems: 80, coins: 100, exp: 470 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 44, world: "Cieux Fracturés", name: "Niveau 2: Sentinelle Cosmique", enemy: { name: "Cosmara", power: 6750}, rewards: { gems: 80, coins: 100, exp: 480 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 45, world: "Cieux Fracturés", name: "Niveau 3: Guerrier des Novas", enemy: { name: "Novablade", power: 6900}, rewards: { gems: 80, coins: 100, exp: 490 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 46, world: "Cieux Fracturés", name: "Niveau 4: Titan Stellaire", enemy: { name: "Starforge", power: 7050}, rewards: { gems: 80, coins: 100, exp: 500 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 47, world: "Cieux Fracturés", name: "Niveau 5: Héraut du Cosmos", enemy: { name: "Cosmoherald", power: 7200}, rewards: { gems: 80, coins: 100, exp: 510 }, unlocked: false, completed: false, type: 'story' }, 
      { id: 48, world: "Cieux Fracturés", name: "Niveau 6: Empereur Fracturé", enemy: { name: "Skyshatter", power: 7350}, rewards: { gems: 80, coins: 100, exp: 520 }, unlocked: false, completed: false, type: 'story' },
       // Monde 9: Ruines Volcaniques
      { id: 50, world: "Ruines Volcaniques", name: "Niveau 1: Gardien de Cendre", enemy: { name: "Cinderguard", power: 7500}, rewards: { gems: 80, coins: 100, exp: 530 }, unlocked: false, completed: false, type: 'story' },
      { id: 51, world: "Ruines Volcaniques", name: "Niveau 2: Salamandre de Lave", enemy: { name: "Lavascale", power: 7650}, rewards: { gems: 80, coins: 100, exp: 540 }, unlocked: false, completed: false, type: 'story' },
      { id: 52, world: "Ruines Volcaniques", name: "Niveau 3: Golem Magmatique", enemy: { name: "Magmacore", power: 7800}, rewards: { gems: 80, coins: 100, exp: 550 }, unlocked: false, completed: false, type: 'story' },
      { id: 53, world: "Ruines Volcaniques", name: "Niveau 4: Drake de Soufre", enemy: { name: "Sulfurdrake", power: 7950}, rewards: { gems: 80, coins: 100, exp: 560 }, unlocked: false, completed: false, type: 'story' },
      { id: 54, world: "Ruines Volcaniques", name: "Niveau 5: Seigneur du Volcan", enemy: { name: "Volcanus Rex", power: 8100}, rewards: { gems: 80, coins: 100, exp: 570 }, unlocked: false, completed: false, type: 'story' },
      { id: 55, world: "Ruines Volcaniques", name: "Niveau 6: Esprit Incandescent", enemy: { name: "Blazespirit", power: 8250}, rewards: { gems: 80, coins: 100, exp: 580 }, unlocked: false, completed: false, type: 'story' },

      // Monde 10: Cité Céleste Engloutie
      { id: 56, world: "Cité Céleste Engloutie", name: "Niveau 1: Sentinelle Aquatique", enemy: { name: "Aquaguardian", power: 8400}, rewards: { gems: 80, coins: 100, exp: 590 }, unlocked: false, completed: false, type: 'story' },
      { id: 57, world: "Cité Céleste Engloutie", name: "Niveau 2: Spectre des Profondeurs", enemy: { name: "Deepwraith", power: 8550}, rewards: { gems: 80, coins: 100, exp: 600 }, unlocked: false, completed: false, type: 'story' },
      { id: 58, world: "Cité Céleste Engloutie", name: "Niveau 3: Léviathan Ancien", enemy: { name: "Elder Leviathan", power: 8700}, rewards: { gems: 80, coins: 100, exp: 610 }, unlocked: false, completed: false, type: 'story' },
      { id: 59, world: "Cité Céleste Engloutie", name: "Niveau 4: Oracle Submergé", enemy: { name: "Sunken Oracle", power: 8850}, rewards: { gems: 80, coins: 100, exp: 620 }, unlocked: false, completed: false, type: 'story' },
      { id: 60, world: "Cité Céleste Engloutie", name: "Niveau 5: Roi Noyé", enemy: { name: "Drowned King", power: 9000}, rewards: { gems: 80, coins: 100, exp: 630 }, unlocked: false, completed: false, type: 'story' },
      { id: 61, world: "Cité Céleste Engloutie", name: "Niveau 6: Titan des Abysses Célestes", enemy: { name: "Skyabyss Titan", power: 9150}, rewards: { gems: 80, coins: 100, exp: 640 }, unlocked: false, completed: false, type: 'story' },

      // NOUVEAU MONDE 11: Royaume des Douceurs
      { id: 62, world: "Royaume des Douceurs", name: "Niveau 1: Sentinelle Guimauve", enemy: { name: "Marshmallow Guard", power: 9300}, rewards: { gems: 80, coins: 100, exp: 650 }, unlocked: false, completed: false, type: 'story' },
      { id: 63, world: "Royaume des Douceurs", name: "Niveau 2: Golem de Pain d'Épice", enemy: { name: "Gingerbread Golem", power: 9450}, rewards: { gems: 80, coins: 100, exp: 660 }, unlocked: false, completed: false, type: 'story' },
      { id: 64, world: "Royaume des Douceurs", name: "Niveau 3: Dragon de Sucre Filé", enemy: { name: "Spun Sugar Dragon", power: 9600}, rewards: { gems: 80, coins: 100, exp: 670 }, unlocked: false, completed: false, type: 'story' },
      { id: 65, world: "Royaume des Douceurs", name: "Niveau 4: Sorcière des Bonbons", enemy: { name: "Candy Witch", power: 9750}, rewards: { gems: 80, coins: 100, exp: 680 }, unlocked: false, completed: false, type: 'story' },
      { id: 66, world: "Royaume des Douceurs", name: "Niveau 5: Roi Chocolat", enemy: { name: "Chocolate King", power: 9900}, rewards: { gems: 80, coins: 100, exp: 690 }, unlocked: false, completed: false, type: 'story' },
      { id: 67, world: "Royaume des Douceurs", name: "Niveau 6: Déesse des Desserts", enemy: { name: "Dessert Goddess", power: 10050}, rewards: { gems: 80, coins: 100, exp: 700 }, unlocked: false, completed: false, type: 'story' },

      // NOUVEAU MONDE 12: Ruines Éthérées
      { id: 68, world: "Ruines Éthérées", name: "Niveau 1: Gardien Silencieux", enemy: { name: "Silent Sentinel", power: 10200}, rewards: { gems: 80, coins: 100, exp: 710 }, unlocked: false, completed: false, type: 'story' },
      { id: 69, world: "Ruines Éthérées", name: "Niveau 2: Spectre Flottant", enemy: { name: "Floating Wraith", power: 10350}, rewards: { gems: 80, coins: 100, exp: 720 }, unlocked: false, completed: false, type: 'story' },
      { id: 70, world: "Ruines Éthérées", name: "Niveau 3: Golem Ancien", enemy: { name: "Ancient Golem", power: 10500}, rewards: { gems: 80, coins: 100, exp: 730 }, unlocked: false, completed: false, type: 'story' },
      { id: 71, world: "Ruines Éthérées", name: "Niveau 4: Oracle Perdu", enemy: { name: "Lost Oracle", power: 10650}, rewards: { gems: 80, coins: 100, exp: 740 }, unlocked: false, completed: false, type: 'story' },
      { id: 72, world: "Ruines Éthérées", name: "Niveau 5: Esprit Vengeur", enemy: { name: "Vengeful Spirit", power: 10800}, rewards: { gems: 80, coins: 100, exp: 750 }, unlocked: false, completed: false, type: 'story' },
      { id: 73, world: "Ruines Éthérées", name: "Niveau 6: Maître des Ruines", enemy: { name: "Ruin Master", power: 10950}, rewards: { gems: 80, coins: 100, exp: 760 }, unlocked: false, completed: false, type: 'story' },

      // NOUVEAU MONDE 13: Vallée des Murmures
      { id: 74, world: "Vallée des Murmures", name: "Niveau 1: Gardien des Échos", enemy: { name: "Echo Warden", power: 11100}, rewards: { gems: 80, coins: 100, exp: 770 }, unlocked: false, completed: false, type: 'story' },
      { id: 75, world: "Vallée des Murmures", name: "Niveau 2: Esprit du Vent", enemy: { name: "Wind Spirit", power: 11250}, rewards: { gems: 80, coins: 100, exp: 780 }, unlocked: false, completed: false, type: 'story' },
      { id: 76, world: "Vallée des Murmures", name: "Niveau 3: Voix Ancestrale", enemy: { name: "Ancestral Voice", power: 11400}, rewards: { gems: 80, coins: 100, exp: 790 }, unlocked: false, completed: false, type: 'story' },
      { id: 77, world: "Vallée des Murmures", name: "Niveau 4: Chaman de la Vallée", enemy: { name: "Valley Shaman", power: 11550}, rewards: { gems: 80, coins: 100, exp: 800 }, unlocked: false, completed: false, type: 'story' },
      { id: 78, world: "Vallée des Murmures", name: "Niveau 5: Titan Murmurant", enemy: { name: "Whispering Titan", power: 11700}, rewards: { gems: 80, coins: 100, exp: 810 }, unlocked: false, completed: false, type: 'story' },
      { id: 79, world: "Vallée des Murmures", name: "Niveau 6: Souverain des Murmures", enemy: { name: "Whisper Sovereign", power: 11850}, rewards: { gems: 80, coins: 100, exp: 820 }, unlocked: false, completed: false, type: 'story' },

      // NOUVEAU MONDE 14: Néant Cosmique
      { id: 80, world: "Néant Cosmique", name: "Niveau 1: Vagabond Stellaire", enemy: { name: "Stellar Drifter", power: 12000}, rewards: { gems: 80, coins: 100, exp: 830 }, unlocked: false, completed: false, type: 'story' },
      { id: 81, world: "Néant Cosmique", name: "Niveau 2: Entité du Vide", enemy: { name: "Void Entity", power: 12150}, rewards: { gems: 80, coins: 100, exp: 840 }, unlocked: false, completed: false, type: 'story' },
      { id: 82, world: "Néant Cosmique", name: "Niveau 3: Gardien Galactique", enemy: { name: "Galactic Warden", power: 12300}, rewards: { gems: 80, coins: 100, exp: 850 }, unlocked: false, completed: false, type: 'story' },
      { id: 83, world: "Néant Cosmique", name: "Niveau 4: Conquérant Xéno", enemy: { name: "Xeno Conqueror", power: 12450}, rewards: { gems: 80, coins: 100, exp: 860 }, unlocked: false, completed: false, type: 'story' },
      { id: 84, world: "Néant Cosmique", name: "Niveau 5: Abomination Cosmique", enemy: { name: "Cosmic Abomination", power: 12600}, rewards: { gems: 80, coins: 100, exp: 870 }, unlocked: false, completed: false, type: 'story' },
      { id: 85, world: "Néant Cosmique", name: "Niveau 6: Seigneur du Néant", enemy: { name: "Overlord of the Void", power: 12750}, rewards: { gems: 80, coins: 100, exp: 880 }, unlocked: false, completed: false, type: 'story' },

      // NOUVEAU MONDE 15: Bastion des Chevaliers
      { id: 86, world: "Bastion des Chevaliers", name: "Niveau 1: Sentinelle en Armure", enemy: { name: "Armored Sentinel", power: 12900}, rewards: { gems: 80, coins: 100, exp: 890 }, unlocked: false, completed: false, type: 'story' },
      { id: 87, world: "Bastion des Chevaliers", name: "Niveau 2: Chevalier Vagabond", enemy: { name: "Knight Errant", power: 13050}, rewards: { gems: 80, coins: 100, exp: 900 }, unlocked: false, completed: false, type: 'story' },
      { id: 88, world: "Bastion des Chevaliers", name: "Niveau 3: Capitaine de la Garde", enemy: { name: "Captain of the Guard", power: 13200}, rewards: { gems: 80, coins: 100, exp: 910 }, unlocked: false, completed: false, type: 'story' },
      { id: 89, world: "Bastion des Chevaliers", name: "Niveau 4: Paladin Sacré", enemy: { name: "Holy Paladin", power: 13350}, rewards: { gems: 80, coins: 100, exp: 920 }, unlocked: false, completed: false, type: 'story' },
      { id: 90, world: "Bastion des Chevaliers", name: "Niveau 5: Grand Maître Chevalier", enemy: { name: "Grand Knightmaster", power: 13500}, rewards: { gems: 80, coins: 100, exp: 930 }, unlocked: false, completed: false, type: 'story' },
      { id: 91, world: "Bastion des Chevaliers", name: "Niveau 6: Roi Chevalier Héroïque", enemy: { name: "Heroic Knight King", power: 13650}, rewards: { gems: 80, coins: 100, exp: 940 }, unlocked: false, completed: false, type: 'story' },
      
      // Monde 16: Forteresse Céleste
      { id: 92, world: "Forteresse Céleste", name: "Niveau 1: Gardien Ailé", enemy: { name: "Aegis Alatus", power: 13800}, rewards: { gems: 80, coins: 100, exp: 950 }, unlocked: false, completed: false, type: 'story' },
      { id: 93, world: "Forteresse Céleste", name: "Niveau 2: Sentinelle de Lumière", enemy: { name: "Lux Vigilo", power: 13950}, rewards: { gems: 80, coins: 100, exp: 960 }, unlocked: false, completed: false, type: 'story' },
      { id: 94, world: "Forteresse Céleste", name: "Niveau 3: Archonte Céleste", enemy: { name: "Archon Caelum", power: 14100}, rewards: { gems: 80, coins: 100, exp: 970 }, unlocked: false, completed: false, type: 'story' },
      { id: 95, world: "Forteresse Céleste", name: "Niveau 4: Paladin des Étoiles", enemy: { name: "Stella Paladinus", power: 14250}, rewards: { gems: 80, coins: 100, exp: 980 }, unlocked: false, completed: false, type: 'story' },
      { id: 96, world: "Forteresse Céleste", name: "Niveau 5: Juge Divin", enemy: { name: "Divinus Iudex", power: 14400}, rewards: { gems: 80, coins: 100, exp: 990 }, unlocked: false, completed: false, type: 'story' },
      { id: 97, world: "Forteresse Céleste", name: "Niveau 6: Roi-Soleil", enemy: { name: "Sol Invictus Rex", power: 14550}, rewards: { gems: 80, coins: 100, exp: 1000 }, unlocked: false, completed: false, type: 'story' },

      // Monde 17: Ruines Oubliées du Temps
      { id: 98, world: "Ruines Oubliées du Temps", name: "Niveau 1: Spectre Temporel", enemy: { name: "Chronospecter", power: 15000}, rewards: { gems: 80, coins: 100, exp: 1010 }, unlocked: false, completed: false, type: 'story' },
      { id: 99, world: "Ruines Oubliées du Temps", name: "Niveau 2: Gardien des Éons", enemy: { name: "Aeon Custos", power: 15150}, rewards: { gems: 80, coins: 100, exp: 1020 }, unlocked: false, completed: false, type: 'story' },
      { id: 100, world: "Ruines Oubliées du Temps", name: "Niveau 3: Golem de Paradoxe", enemy: { name: "Paradox Golem", power: 15300}, rewards: { gems: 80, coins: 100, exp: 1030 }, unlocked: false, completed: false, type: 'story' },
      { id: 101, world: "Ruines Oubliées du Temps", name: "Niveau 4: Oracle des Âges", enemy: { name: "Saeculum Oraculum", power: 15450}, rewards: { gems: 80, coins: 100, exp: 1040 }, unlocked: false, completed: false, type: 'story' },
      { id: 102, world: "Ruines Oubliées du Temps", name: "Niveau 5: Titan Oublié", enemy: { name: "Oblitus Titan", power: 15600}, rewards: { gems: 80, coins: 100, exp: 1050 }, unlocked: false, completed: false, type: 'story' },
      { id: 103, world: "Ruines Oubliées du Temps", name: "Niveau 6: Seigneur du Temps", enemy: { name: "Dominus Temporis", power: 15750}, rewards: { gems: 80, coins: 100, exp: 1060 }, unlocked: false, completed: false, type: 'story' },

      { id: 120, world: "Abîme Infini", name: "Niveau Infini: Abîme Éternel", enemy: { name: "Entité Infinie", power: 7500}, rewards: { gemsPerMinute: 10 }, unlocked: false, completed: false, isInfinite: true }
    ];
    const legendaryStoryLevels = [
        { id: 1001, world: "Royaume des Ombres", name: "Défi Légendaire: Roi des Ombres Éveillé", enemy: { name: "Rex Umbra Validus", power: 5000}, rewards: { gems: 500, coins: 250, exp: 1000, itemChance: { item: "Green Essence", probability: 0.01, minQuantity: 1, maxQuantity: 3 } }, type: 'legendary', unlocked: false, completed: false },
        { id: 1002, world: "Empire de Cristal", name: "Défi Légendaire: Cœur de Cristal Pur", enemy: { name: "Crystallus Prime Validus", power: 7500}, rewards: { gems: 750, coins: 375, exp: 1500, itemChance: { item: "Red Essence", probability: 0.01, minQuantity: 1, maxQuantity: 3} }, type: 'legendary', unlocked: false, completed: false },
        { id: 1003, world: "Profondeurs Abyssales", name: "Défi Légendaire: Abomination des Profondeurs", enemy: { name: "Abyss Lord Validus", power: 10000}, rewards: { gems: 1000, coins: 500, exp: 2000, itemChance: { item: "Blue Essence", probability: 0.01, minQuantity: 1, maxQuantity: 3 } }, type: 'legendary', unlocked: false, completed: false},
        { id: 1004, world: "Pics Célestes", name: "Défi Légendaire: Souverain des Cieux", enemy: { name: "Sky Emperor Validus", power: 12500}, rewards: { gems: 1250, coins: 625, exp: 2500, itemChance: { item: "Pink Essence", probability: 0.01, minQuantity: 1, maxQuantity: 3 } }, type: 'legendary', unlocked: false, completed: false},
        { id: 1005, world: "Déserts du Vide", name: "Défi Légendaire: Entité du Vide Ancestrale", enemy: { name: "Void Ancient Validus", power: 15000}, rewards: { gems: 1500, coins: 750, exp: 3000, itemChance: { item: "Yellow Essence", probability: 0.01, minQuantity: 1, maxQuantity: 3 } }, type: 'legendary', unlocked: false, completed: false},
        { id: 1006, world: "Éclipse Éternelle", name: "Défi Légendaire: Dévoreur d'Éclipse", enemy: { name: "Eclipse Eater Validus", power: 17500}, rewards: { gems: 1750, coins: 875, exp: 3500, itemChance: {item: "Purple Essence", probability: 0.01, minQuantity: 1, maxQuantity: 3} }, type: 'legendary', unlocked: false, completed: false},
        { id: 1007, world: "Forêt Éthérée", name: "Défi Légendaire: Esprit Millénaire de la Forêt", enemy: { name: "Millennial Forest Spirit Validus", power: 20000}, rewards: { gems: 2000, coins: 1000, exp: 4000, itemChance: { item: "Rainbow Essence", probability: 0.005, minQuantity: 1, maxQuantity: 2 } }, type: 'legendary', unlocked: false, completed: false},
        { id: 1008, world: "Cieux Fracturés", name: "Défi Légendaire: Briseur de Cosmos", enemy: { name: "Cosmos Breaker Validus", power: 22500}, rewards: { gems: 2250, coins: 1125, exp: 4500, itemChance: [ { item: "Shadow Tracer", probability: 1, minQuantity: 1, maxQuantity: 1 }, { item: "Silverite Sword", probability: 0.0004, minQuantity: 1, maxQuantity: 2 } ] }, type: 'legendary', unlocked: false, completed: false},
        { id: 1009, world: "Ruines Volcaniques", name: "Défi Légendaire: Cœur du Volcan Ancien", enemy: { name: "Ignis Primordialis Validus", power: 25000}, rewards: { gems: 2500, coins: 1250, exp: 5000, itemChance: [ { item : "Blood-Red Armor", probability: 0.0004, minQuantity: 1, maxQuantity: 1 }, { item: "Cast Blades", probability: 0.0004, minQuantity: 1, maxQuantity: 2 } ] }, type: 'legendary', unlocked: false, completed: false},
        { id: 1010, world: "Cité Céleste Engloutie", name: "Défi Légendaire: Titan des Mers Étoilées", enemy: { name: "Stellamaris Titan Validus", power: 27500}, rewards: { gems: 2750, coins: 1375, exp: 5500, itemChance: [ { item: "Hellsing Arms", probability: 0.0004, minQuantity: 1, maxQuantity: 1 }, { item: "Broken Sword", probability: 0.0004, minQuantity: 1, maxQuantity: 2  } ] }, type: 'legendary', unlocked: false, completed: false},
        { id: 1011, world: "Royaume des Douceurs", name: "Défi Légendaire: Festin Apocalyptique", enemy: { name: "Seigneur Sucre Sombre Validus", power: 30000 }, rewards: { gems: 3000, coins: 1500, exp: 6000, itemChance: [ { item: "Head Captain's Coat", probability: 0.0004, minQuantity: 1, maxQuantity: 1 }, { item: "Chipped Blade", probability: 0.0004, minQuantity: 1, maxQuantity: 1 } ] }, type: 'legendary', unlocked: false, completed: false },
        { id: 1012, world: "Ruines Éthérées", name: "Défi Légendaire: L'Écho Éthéré", enemy: { name: "Custode Éthéré Validus", power: 32500 }, rewards: { gems: 3250, coins: 1625, exp: 6500, itemChance: [ { item: "Cursed Finger", probability: 0.0004, minQuantity: 1, maxQuantity: 1 }, { item: "Magma Stone", probability: 0.0004, minQuantity: 1, maxQuantity: 1 } ] }, type: 'legendary', unlocked: false, completed: false },
        { id: 1013, world: "Vallée des Murmures", name: "Défi Légendaire: Silence Assourdissant", enemy: { name: "Entité du Silence Validus", power: 35000 }, rewards: { gems: 3500, coins: 1750, exp: 7000, itemChance: [ { item: "Broken Pendant", probability: 0.0004, minQuantity: 1, maxQuantity: 1 }, { item: "Demon Beads", probability: 0.0004, minQuantity: 1, maxQuantity: 1 } ] }, type: 'legendary', unlocked: false, completed: false },
        { id: 1014, world: "Néant Cosmique", name: "Défi Légendaire: Singularité Menaçante", enemy: { name: "Singularité Primordiale Validus", power: 37500 }, rewards: { gems: 3750, coins: 1875, exp: 7500, itemChance: [ { item: "Nichirin Cleavers", probability: 0.0004, minQuantity: 1, maxQuantity: 1 }, { item: "Skin Patch", probability: 0.0004, minQuantity: 1, maxQuantity: 1 } ] }, type: 'legendary', unlocked: false, completed: false },
        { id: 1015, world: "Bastion des Chevaliers", name: "Défi Légendaire: Le Serment du Chevalier Éternel", enemy: { name: "Chevalier Éternel Validus", power: 40000 }, rewards: { gems: 4000, coins: 2000, exp: 8000, itemChance: [ { item: "Blue Chakra", probability: 0.0004, minQuantity: 1, maxQuantity: 1 }, { item: "Red Chakra", probability: 0.0004, minQuantity: 1, maxQuantity: 1 } ] }, type: 'legendary', unlocked: false, completed: false },
        { id: 1016, world: "Forteresse Céleste", name: "Défi Légendaire: Gardien Suprême des Cieux", enemy: { name: "Caelum Supremus Validus", power: 42500}, rewards: { gems: 4250, coins: 2125, exp: 8500, itemChance: [ { item: "Atomic Essence", probability: 0.0002, minQuantity: 1, maxQuantity: 1 }, { item: "Divin Wish", probability: 0.0002, minQuantity: 1, maxQuantity: 1 } ] }, type: 'legendary', unlocked: false, completed: false },
        { id: 1017, world: "Ruines Oubliées du Temps", name: "Défi Légendaire: Entité Temporelle Primordiale", enemy: { name: "Primordius Chronos Validus", power: 45000}, rewards: { gems: 4500, coins: 2250, exp: 9000, itemChance: [ { item: "Atomic Essence", probability: 0.0002, minQuantity: 1, maxQuantity: 1 }, { item: "Divin Wish", probability: 0.0002, minQuantity: 1, maxQuantity: 1 } ] }, type: 'legendary', unlocked: false, completed: false },
    ];
    const storyLevels = [...baseStoryLevels, ...legendaryStoryLevels];

    const challengeLevels = [
      { id: 201, world: "Challenge Unique", name: "Défi: Vague d'ennemis", enemy: { name: "Horde Mixte", power: 3000}, rewards: { gems: 100, coins: 50, exp: 200, itemChance: { item: "Cursed Token", probability: 0.01, minQuantity: 1, maxQuantity: 1 } }, type: 'challenge', unlocked: true, completed: false },
      { id: 202, world: "Challenge Unique", name: "Défi: Boss Résistant", enemy: { name: "Golem Ancien", power: 6000}, rewards: { gems: 200, coins: 100, exp: 400, itemChance: { item: "Stat Chip", probability: 0.01, minQuantity: 1, maxQuantity: 1 }}, type: 'challenge', unlocked: true, completed: false },
      { id: 203, world: "Challenge Unique", name: "Défi: Gardien Véloce", enemy: { name: "Gardien Véloce", power: 4500}, rewards: { gems: 150, coins: 75, exp: 300, itemChance: {item: "Reroll Token", probability: 0.01, minQuantity: 1, maxQuantity: 1} }, type: 'challenge', unlocked: true, completed: false },
      { id: 204, world: "Challenge Avancé", name: "Défi: Briser les Limites", enemy: { name: "Gardien Ancestral", power: 8000 }, rewards: { gems: 250, coins: 125, exp: 500, itemChance: { item: "Divin Wish", probability: 0.01, minQuantity: 1, maxQuantity: 1 } }, type: 'challenge', unlocked: true, completed: false },
      { 
        id: 205,
        world: "Challenge Jouable", 
        name: "Défi: Boss Tapper", 
        enemy: { 
          name: "Titan Tapper", 
          power: 100000, 
          image: "./images/titan-tapper.png" // <-- NOUVELLE LIGNE
        }, 
        rewards: { gems: 300, coins: 150, exp: 500, itemChance: { item: "Reroll Token", probability: 0.25, minQuantity: 1, maxQuantity: 1 } }, 
        type: 'minigame',
        unlocked: true, 
        completed: false 
      },
    ];

            const materialFarmLevels = [
      {
        id: 301,
        world: "Antre du Gardien des Essences",
        name: "Farm: Snake Scale et Gorgon's Blindfold",
        enemy: { name: "Gardien des Essences", power: 5000 },
        rewards: {
          gems: 10, coins: 20, exp: 30,
          itemChance: [{ item: "Snake Scale", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Gorgon's Blindfold", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 302,
        world: "Domaine du Spectre d'Ombre",
        name: "Farm: Senzu Bean et Caster's Headpiece",
        enemy: { name: "Spectre d'Ombre", power: 6000 },
        rewards: {
          gems: 10, coins: 20, exp: 30,
          itemChance: [{ item: "Senzu Bean", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Caster's Headpiece", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 303,
        world: "Fosse de l'Abomination Maudite",
        name: "Farm: Holy Corpse Eyes et Holy Corpse Arms",
        enemy: { name: "Abomination Maudite", power: 7000 },
        rewards: {
          gems: 10, coins: 20, exp: 30,
          itemChance: [{ item: "Holy Corpse Eyes", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Holy Corpse Arms", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 304,
        world: "Forge du Forgeron Ancien",
        name: "Farm: Completed Holy Corpse et Avalon",
        enemy: { name: "Forgeron Ancien", power: 8000 },
        rewards: {
          gems: 15, coins: 30, exp: 40,
          itemChance: [{ item: "Completed Holy Corpse", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Avalon", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 305,
        world: "Poste du Veilleur Éthéré",
        name: "Farm: Goddess' Sword et Blade of Death",
        enemy: { name: "Veilleur Éthéré", power: 6000 },
        rewards: {
          gems: 12, coins: 25, exp: 35,
          itemChance: [{ item: "Goddess' Sword", probability: 0.02, minQuantity: 1, maxQuantity: 1 },  { item: "Blade of Death", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true, 
        completed: false
      },
      {
        id: 306,
        world: "Crypte du Gardien Squelettique",
        name: "Farm: Berserker's Blade et Shunpo Spirit",
        enemy: { name: "Gardien Squelettique", power: 6200 },
        rewards: {
          gems: 12, coins: 25, exp: 35,
          itemChance: [{ item: "Berserker's Blade", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Shunpo Spirit", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 314,
        world: "Chenil du Cerbère Spectral",
        name: "Farm: Six Eyes et Tome of Wisdom",
        enemy: { name: "Cerbère Spectral", power: 7600 },
        rewards: {
          gems: 15, coins: 35, exp: 45,
          itemChance: [{ item: "Six Eyes", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Tome of Wisdom", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 315,
        world: "Sanctuaire de l'Oracle Ancien",
        name: "Farm: Corrupted Visor et Tainted Ribbon",
        enemy: { name: "Oracle Ancien", power: 8500 },
        rewards: {
          gems: 20, coins: 40, exp: 50,
          itemChance: [{ item: "Corrupted Visor", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Tainted Ribbon", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 316,
        world: "Atelier de l'Esprit du Forgeron",
        name: "Farm: Demon Chalice et Essence of the Spirit King",
        enemy: { name: "Esprit du Forgeron", power: 8800 },
        rewards: {
          gems: 22, coins: 42, exp: 52,
          itemChance: [{ item: "Demon Chalice", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Essence of the Spirit King", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 317,
        world: "Arène du Champion Déchu",
        name: "Farm: Ring of Friendship et Red Jewel",
        enemy: { name: "Champion Déchu", power: 9000 },
        rewards: {
          gems: 25, coins: 45, exp: 55,
          itemChance: [ { item: "Ring of Friendship", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Red Jewel", probability: 0.02, minQuantity: 1, maxQuantity: 1 } ]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 318,
        world: "Caveau du Gardien des Reliques",
        name: "Farm: Majan Essence et Donut",
        enemy: { name: "Gardien des Reliques Sombres", power: 9200 },
        rewards: {
          gems: 28, coins: 48, exp: 58,
          itemChance: [ { item: "Majan Essence", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Donut", probability: 0.02, minQuantity: 1, maxQuantity: 1 } ]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 319,
        world: "Tombeau du Spectre Royal",
        name: "Farm: Atomic Essence",
        enemy: { name: "Spectre Royal", power: 9500 },
        rewards: {
          gems: 30, coins: 50, exp: 60,
          itemChance: [{ item: "Atomic Essence", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 307,
        world: "Autel de l'Esprit du Sanctuaire",
        name: "Farm: Energy Arrow et Hair Ornament",
        enemy: { name: "Esprit du Sanctuaire", power: 6500 },
        rewards: {
          gems: 13, coins: 28, exp: 38,
          itemChance: [{ item: "Energy Arrow", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Hair Ornament", probability: 0.02, minQuantity: 1, maxQuantity: 1 }] 
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 308,
        world: "Enclume du Forgeron Céleste",
        name: "Farm: Bucket Hat et Horn of Salvation",
        enemy: { name: "Forgeron Céleste Déchu", power: 6800 },
        rewards: {
          gems: 14, coins: 30, exp: 40,
          itemChance: [{ item: "Bucket Hat", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Horn of Salvation", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 309,
        world: "Scriptorium de l'Archiviste",
        name: "Farm: Energy Bone et Z Blade",
        enemy: { name: "Archiviste Spectral", power: 7000 },
        rewards: {
          gems: 15, coins: 32, exp: 42,
          itemChance: [{ item: "Energy Bone", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Z Blade", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 310,
        world: "Dojo du Maître Poussiéreux",
        name: "Farm: Bucket Hat et Prison Chair",
        enemy: { name: "Maître Poussiéreux", power: 7200 },
        rewards: {
          gems: 15, coins: 33, exp: 43,
          itemChance: [{ item: "Bucket Hat", probability: 0.016, minQuantity: 1, maxQuantity: 1 }, { item: "Prison Chair", probability: 0.016, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
       {
        id: 311,
        world: "Trône du Gardien Scintillant",
        name: "Farm: Toil Ribbon",
        enemy: { name: "Gardien Scintillant", power: 7500 },
        rewards: {
            gems: 16, coins: 35, exp: 45,
            itemChance: [{ item: "Toil Ribbon", probability: 0.8, minQuantity: 1, maxQuantity: 3 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 312,
        world: "Champ de Bataille Ancestral",
        name: "Farm: Rotara Earring 1 et Rotara Earring 2",
        enemy: { name: "Guerrier Ancestral", power: 7800 },
        rewards: {
          gems: 16, coins: 36, exp: 46,
          itemChance: [{ item: "Rotara Earring 1", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Rotara Earring 2", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 313, 
        world: "Temple de la Divinité Gardienne",
        name: "Farm: Champ's Belt et Dog Bone",
        enemy: { name: "Divinité Gardienne", power: 8200 },
        rewards: {
          gems: 18, coins: 38, exp: 48,
          itemChance: [{ item: "Champ's Belt", probability: 0.02, minQuantity: 1, maxQuantity: 1 }, { item: "Dog Bone", probability: 0.02, minQuantity: 1, maxQuantity: 1 }]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 320,
        world: "Cuisine du Chef Pâtissier Fou",
        name: "Farm: Donut et Essence de Majin",
        enemy: { name: "Chef Pâtissier Fou", power: 9300 },
        rewards: {
          gems: 28, coins: 48, exp: 58,
          itemChance: [
            { item: "Donut", probability: 0.025, minQuantity: 1, maxQuantity: 2 },
            { item: "Essence de Majin", probability: 0.01, minQuantity: 1, maxQuantity: 1 }
          ]
        },
        type: 'material',
        unlocked: true,
        completed: false
      },
      {
        id: 321,
        world: "Geôles du Gardien du Château",
        name: "Farm: Restricting Headband",
        enemy: { name: "Gardien du Château", power: 9400 },
        rewards: {
          gems: 28, coins: 48, exp: 58,
          itemChance: [
            { item: "Restricting Headband", probability: 0.8, minQuantity: 1, maxQuantity: 1 }
          ]
        },
        type: 'material',
        unlocked: true,
        completed: false
      }
    ];

    const allGameLevels = [...baseStoryLevels, ...legendaryStoryLevels, ...challengeLevels, ...materialFarmLevels];

    const worldRewards = [
      { world: 1, item: "Haricots", minQuantity: 2, maxQuantity: 4 },
      { world: 2, item: "Fluide mystérieux", minQuantity: 3, maxQuantity: 6 },
      { world: 3, item: "Ramen Bowl", minQuantity: 5, maxQuantity: 10 },
      { world: 4, item: "Ghoul Coffee", minQuantity: 1, maxQuantity: 3 },
      { world: 5, item: "Soul Candy", minQuantity: 1, maxQuantity: 3 },
      { world: 6, item: "Cooked Fish", minQuantity: 1, maxQuantity: 3 },
      { world: 7, item: "Magical Artifact", minQuantity: 1, maxQuantity: 2 },
      { world: 8, item: "Curse Talisman", minQuantity: 1, maxQuantity: 2 },
      { world: 9, item: "Magic Pendant", minQuantity: 1, maxQuantity: 2 },
      { world: 10, item: "Crystal", minQuantity: 1, maxQuantity: 2 },
      { world: 11, item: "Chocolate Bar's", minQuantity: 1, maxQuantity: 2 },
      { world: 12, item: "Magic Stone", minQuantity: 1, maxQuantity: 2 },
      { world: 13, item: "Stone Pendant", minQuantity: 1, maxQuantity: 2 },
      { world: 14, item: "Alien Core", minQuantity: 1, maxQuantity: 2 },
      { world: 15, item: "Tavern Pie", minQuantity: 1, maxQuantity: 2 },
      { world: 16, item: "Plume Céleste", minQuantity: 1, maxQuantity: 2 },
      { world: 17, item: "Sablier Ancien", minQuantity: 1, maxQuantity: 2 },
    ];

    const itemEffects = {
      "Haricots": { exp: 50 },
      "Fluide mystérieux": { exp: 100 },
      "Ramen Bowl": { exp: 150 },
      "Ghoul Coffee": { exp: 200 },
      "Soul Candy": { exp: 250 },
      "Cooked Fish": { exp: 300 },
      "Magical Artifact": { exp: 350 },
      "Curse Talisman": { exp: 400 },
      "Crystal": { exp: 450 },
      "Magic Pendant": { exp: 500 },
      "Chocolate Bar's": { exp: 550 },
      "Magic Stone": { exp: 600 },
      "Stone Pendant": { exp: 650 },
      "Alien Core": { exp: 700 },
      "Tavern Pie": { exp: 750 },
      "Plume Céleste": { exp: 950 },
      "Sablier Ancien": { exp: 1000 },
    };

    const BANNER_CONFIG = {
        Secret:     { overallChance: 0.000025 }, // 0.0025% (inchangé)
        Mythic:     { overallChance: 0.002,  numFeatured: 3, featuredPoolRatio: 0.85, featuredRelativeWeights: [0.33 / 1.16, 0.33 / 1.16, 0.50 / 1.16] }, // NOUVEAU: 0.2% (au lieu de 0.5%)
        Légendaire: { overallChance: 0.01 },    // 1% (inchangé)
        Épique:     { overallChance: 0.05 },    // 5% (inchangé)
        // La probabilité pour Rare est calculée pour que la somme totale soit 1.
        // Somme des autres: 0.000025 (Secret) + 0.002 (Mythic) + 0.01 (Légendaire) + 0.05 (Épique) = 0.062025
        // Donc, Rare = 1 - 0.062025 = 0.937975
        Rare:       { overallChance: 0.937975 } // NOUVEAU: 93.7975%
    };

    const statRanks = {
        "C":   { modifier: 0.85, color: "text-gray-400",  order: 1, borderColor: "border-gray-400" },
        "B":   { modifier: 0.92, color: "text-sky-400",   order: 2, borderColor: "border-sky-400" },
        "A":   { modifier: 1.0,  color: "text-lime-400",  order: 3, borderColor: "border-lime-400" },
        "S":   { modifier: 1.08, color: "text-amber-400", order: 4, borderColor: "border-amber-400" },
        "SS":  { modifier: 1.15, color: "text-orange-500",order: 5, borderColor: "border-orange-500" }, 
        "SSS": { modifier: 1.25, color: "text-rose-500",  order: 6, borderColor: "border-rose-500" }
    };
    console.log("statRanks defined:", typeof statRanks, statRanks);

    const statRankProbabilities = [
        { rank: "C",   probability: 0.40 }, // 40 / 100
        { rank: "B",   probability: 0.30 }, // 30 / 100
        { rank: "A",   probability: 0.20 }, // 20 / 100
        { rank: "S",   probability: 0.09 }, //  9 / 100
        { rank: "SS",  probability: 0.009 }, // 0.9 / 100
        { rank: "SSS", probability: 0.001 }  //  0.1 / 100
    ];
    // La somme des probabilités est bien 0.35 + 0.35 + 0.18 + 0.07 + 0.03 + 0.02 = 1.00
    
    console.log("statRankProbabilities defined:", typeof statRankProbabilities, statRankProbabilities);
    const rarityOrder = {
      "Rare": 1,
      "Épique": 2,
      "Légendaire": 3,
      "Mythic": 4,
      "Secret": 5,
      "Vanguard": 6
    };
    const rarityExpMultipliers = {
      "Rare": 1.0,
      "Épique": 1.5,
      "Légendaire": 2.0,
      "Mythic": 3.0,
      "Secret": 4.0,
      "Vanguard": 5.0
    };

    const TWO_HOURS_MS = 2 * 60 * 60 * 1000;

    const TRAIT_DEFINITIONS = {
        "strength": {
            id: "strength",
            name: "Force",
            image: "https://static.wikia.nocookie.net/animeadventures/images/b/bf/Trait_Superior.png/revision/latest/scale-to-width-down/65?cb=20220831131930",
            probability: 0.48, // Adjusted probability
            order: 1,
            gradeProbabilities: [
                { grade: 1, probability: 0.55 },
                { grade: 2, probability: 0.33 },
                { grade: 3, probability: 0.11 }
            ],
            grades: [
                { grade: 1, description: "+5% Puissance (Tous modes)", powerMultiplier: 0.05 },
                { grade: 2, description: "+10% Puissance (Tous modes)", powerMultiplier: 0.10 },
                { grade: 3, description: "+15% Puissance (Tous modes)", powerMultiplier: 0.15 }
            ]
        },
        "fortune": {
            id: "fortune",
            name: "Fortune",
            image: "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/bf/Fortune.png/revision/latest/scale-to-width-down/65?cb=20240911055432",
            probability: 0.48, // Adjusted probability
            order: 1,
            gradeProbabilities: [
                { grade: 1, probability: 0.55 },
                { grade: 2, probability: 0.33 },
                { grade: 3, probability: 0.11 }
            ],
            grades: [
                { grade: 1, description: "+5% Gemmes (Mode Histoire)", gemBonusPercentage: 0.10 },
                { grade: 2, description: "+15% Gemmes (Mode Histoire)", gemBonusPercentage: 0.15 },
                { grade: 3, description: "+25% Gemmes (Mode Histoire)", gemBonusPercentage: 0.25 }
            ]
        },
        "berserk": {
            id: "berserk",
            name: "Berserk",
            image: "https://static.wikia.nocookie.net/animeadventures/images/d/d9/Trait_Reaper.png/revision/latest/scale-to-width-down/65?cb=20220831133708", // Placeholder image
            probability: 0.01, // Assigned probability
            order: 2,
            // No gradeProbabilities for single-grade trait
            grades: [
                { grade: 1, description: "+25% Puissance (Mode Infini)", powerMultiplierInfinite: 0.25 }
            ]
        },
        "legends": {
            id: "legends",
            name: "Héros de Légende", // "Legends" from image, translated for consistency
            image: "https://static.wikia.nocookie.net/animeadventures/images/1/14/Trait_Divine.png/revision/latest/scale-to-width-down/65?cb=20220831133702", // Placeholder image
            probability: 0.01, // Assigned probability
            order: 3,
            grades: [
                { grade: 1, description: "+25% Puissance (Mode Légende)", powerMultiplierLegend: 0.25 }
            ]
        },
        "challenge_master": {
            id: "challenge_master",
            name: "Maître des Challenges",
            image: "https://static.wikia.nocookie.net/animeadventures/images/f/f9/Trait_Celestial.png/revision/latest/scale-to-width-down/65?cb=20221225203625",
            probability: 0.01,
            order: 4,
            grades: [
                { grade: 1, description: "+25% Puissance (Mode Challenge)", powerMultiplierChallenge: 0.25 }
            ]
        },
        "looter": {
            id: "looter",
            name: "Looter",
            image: "https://cdn.icon-icons.com/icons2/1465/PNG/512/558lootbox_100983.png", // Placeholder image
            probability: 0.006,
            order: 5,
            grades: [
                { grade: 1, description: "+30% Taux de Drop Items (Mode Histoire)", itemDropRateStoryBonusPercentage: 0.30 }
            ]
        },
        "golder": {
            id: "golder",
            name: "Golden", // "Golder" from image
            image: "https://static.wikia.nocookie.net/animeadventures/images/1/10/Trait_Golden.png/revision/latest/scale-to-width-down/65?cb=20220831133640", // Placeholder image
            probability: 0.003, // Assigned probability
            order: 6,
            grades: [
                { grade: 1, description: "+40% Gemmes & Pièces (Tous modes)", gemBonusPercentageAllModes: 0.40, coinBonusPercentageAllModes: 0.40 }
            ]
        },
        "monarch": {
            id: "monarch",
            name: "Monarque",
            image: "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9f/Soverign.png/revision/latest/scale-to-width-down/65?cb=20240922070846", // Placeholder image
            probability: 0.001, 
            order: 7,
            grades: [
                { grade: 1, description: "+40% Puissance (Tous modes)", powerMultiplier: 0.40 }
            ]
        }
    };

    // --- NOUVEAU: Initialisation de Firebase ---
    // TODO: COLLEZ VOTRE CONFIGURATION FIREBASE ICI
    const firebaseConfig = {
        apiKey: "AIzaSyDcNkyF9_fUdfzX5pv2V9Q-SzKQhGEbP-g",
        authDomain: "jeu-gacha-93e4e.firebaseapp.com",
        projectId: "jeu-gacha-93e4e",
        storageBucket: "jeu-gacha-93e4e.firebasestorage.app",
        messagingSenderId: "521750081576",
        appId: "1:521750081576:web:6d8c26a2a67eb92b57451d"
    };

    // Initialiser Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // --- NOUVEAU: Variables pour l'état de l'authentification ---
    let currentUser = null;
    let isGameInitialized = false; // Pour s'assurer que le jeu n'est initialisé qu'une seule fois

    // --- NOUVEAU: Références aux nouveaux éléments HTML ---
    const appContainer = document.getElementById("app-container");
    const authContainer = document.getElementById("auth-container");
    const gameContainer = document.getElementById("game-container");
    const userStatus = document.getElementById("user-status");

    // --- VARIABLES GLOBALES ENSUITE ---
    let characterIdCounter = parseInt(localStorage.getItem("characterIdCounter")) || 0;
    let gemsRaw = localStorage.getItem("gems");
    let gems;
    if (gemsRaw !== null) {
        gems = parseInt(gemsRaw);
        if (isNaN(gems)) {
            console.warn("Valeur de 'gems' invalide dans localStorage:", gemsRaw, ". Réinitialisation à 1000.");
            gems = 1000;
        }
    } else {
        gems = 1000;
    }
    let coins = parseInt(localStorage.getItem("coins")) || 0;
    let pullCount = parseInt(localStorage.getItem("pullCount")) || 0;
    
    let ownedCharacters = [];
    const rawOwnedCharactersString = localStorage.getItem("ownedCharacters");
    console.log("Vérification avant boucle: statRanks est défini?", typeof statRanks !== 'undefined'); // LOG DE CONTRÔLE

    if (rawOwnedCharactersString) {
        try {
            const loadedChars = JSON.parse(rawOwnedCharactersString);
            if (Array.isArray(loadedChars)) {
                loadedChars.forEach((char, index) => {
                    try {
                        if (!char || typeof char.name !== 'string') {
                            console.warn(`[INIT Char ${index}] Personnage invalide ou nom manquant, skippé:`, char);
                            return;
                        }

                        const nameToFind = char.hasEvolved && char.originalName ? char.originalName : char.name;
                        const baseDefinition = allCharacters.find(c => c.name === nameToFind);
                        if (!baseDefinition) {
                            console.warn(`[INIT Char ${index}] Définition de base non trouvée pour '${char.name}'. Skippé.`);
                            return;
                        }
                        const initialPowerFromDefinition = baseDefinition.power;

                        let basePower = char.basePower;
                        let statRank = char.statRank;
                        let statModifier = char.statModifier;
                        let traitOnLoad = char.trait || { id: null, grade: 0 };
                        if (char.trait && typeof char.trait.level !== 'undefined' && typeof char.trait.grade === 'undefined') {
                            traitOnLoad.grade = char.trait.level > 0 ? char.trait.level : 0;
                            delete traitOnLoad.level;
                        }

                        if (typeof basePower === 'undefined' || basePower === null || isNaN(Number(basePower)) || Number(basePower) <= 0) {
                            // ... (logique existante pour dériver basePower)
                        }

                        if (!statRank || !statRanks[statRank]) {
                            statRank = getRandomStatRank();
                            statModifier = statRanks[statRank].modifier;
                        } else if (typeof statModifier === 'undefined' || statModifier === null || isNaN(Number(statModifier))) {
                            statModifier = statRanks[statRank].modifier;
                        }

                        const newCharData = {
                             ...(baseDefinition ? baseDefinition : {}),
                            ...char,
                            id: char.id || `char_${characterIdCounter++}`,
                            level: Number(char.level) || 1,
                            exp: Number(char.exp) || 0,
                            locked: char.locked || false,
                            hasEvolved: char.hasEvolved || false,
                            curseEffect: Number(char.curseEffect) || 0,
                            basePower: Number(basePower),
                            // MODIFICATION ICI:
                            maxLevelCap: Number(char.maxLevelCap) || 60, // Assurer que maxLevelCap existe, sinon 60
                            statRank: statRank,
                            statModifier: Number(statModifier),
                            trait: (traitOnLoad && typeof traitOnLoad.id === 'string' && typeof traitOnLoad.grade === 'number' && TRAIT_DEFINITIONS[traitOnLoad.id])
                                   ? { id: traitOnLoad.id, grade: traitOnLoad.grade }
                                   : { id: null, grade: 0 }
                        };
                        delete newCharData.power;

                        // console.log(`[DEBUG Pre-Recalc] Char: ${newCharData.name}, BaseP: ${newCharData.basePower}, StatMod: ${newCharData.statModifier}, Trait: ${JSON.stringify(newCharData.trait)}`);
                        if (newCharData.trait.id && newCharData.trait.grade > 0) {
                            const traitDef = TRAIT_DEFINITIONS[newCharData.trait.id];
                            if (traitDef && traitDef.grades) {
                                const maxGradeForTrait = traitDef.grades.length;
                                if (newCharData.trait.grade > maxGradeForTrait) {
                                    console.warn(`[INIT Char ${newCharData.name}] Trait ${newCharData.trait.id} avait un grade ${newCharData.trait.grade} > max ${maxGradeForTrait}. Ajustement au grade max.`);
                                    newCharData.trait.grade = maxGradeForTrait;
                                }
                                if (newCharData.trait.grade <= 0) { // Si le grade était 0 après la conversion
                                     console.warn(`[INIT Char ${newCharData.name}] Trait ${newCharData.trait.id} avait un grade 0. Remise à 0 (aucun trait).`);
                                     newCharData.trait = { id: null, grade: 0 }; // Réinitialiser si grade 0
                                }
                            } else { // Trait ID existe mais pas de définition de grades (ne devrait pas arriver avec la nouvelle structure)
                                newCharData.trait = { id: null, grade: 0 };
                            }
                        } else if (newCharData.trait.id && newCharData.trait.grade === 0) { // Si l'ID est là mais grade 0
                            newCharData.trait = { id: null, grade: 0 };
                        }
                        
                        recalculateCharacterPower(newCharData);

                        if (isNaN(newCharData.power) || newCharData.power <= 0) {
                             console.warn(`[INIT Char ${index}] Puissance INVALIDE pour ${newCharData.name} après recalcul. Power: ${newCharData.power}. SKIPPED.`);
                             console.log("[INIT Char Detail for Skipped]: ", JSON.parse(JSON.stringify(newCharData)));
                             return;
                        }
                        ownedCharacters.push(newCharData);
                    } catch (errorForChar) {
                        console.error(`[INIT Char ${index}] ERREUR lors du traitement du personnage sauvegardé:`, char, errorForChar);
                    }
                });
                if (loadedChars.length !== ownedCharacters.length) {
                    console.warn("[INIT] Attention: Certains personnages de la sauvegarde n'ont pas pu être chargés correctement.");
                }
            } else {
                console.warn("[INIT] 'ownedCharacters' depuis localStorage n'est pas un tableau. Initialisation à vide.");
            }
        } catch (e) {
            console.error("[INIT] ERREUR FATALE lors du JSON.parse de 'ownedCharacters' ou de son traitement:", e);
            ownedCharacters = [];
        }
    } else {
        // console.log("[INIT] 'ownedCharacters' non trouvé dans localStorage. Initialisation à un tableau vide.");
    }
    localStorage.setItem("characterIdCounter", characterIdCounter);

    let level = parseInt(localStorage.getItem("level")) || 1;
    let exp = parseInt(localStorage.getItem("exp")) || 0;
    let expMultiplier = parseFloat(localStorage.getItem("expMultiplier")) || 1;
    let pullTickets = parseInt(localStorage.getItem("pullTickets")) || 0;
    let missions = JSON.parse(localStorage.getItem("missions")) || [];
    let isDeleteMode = false;
    let selectedCharacterIndices = new Set(); 
    let shopOffers = JSON.parse(localStorage.getItem("shopOffers")) || [];
    let shopRefreshTime = parseInt(localStorage.getItem("shopRefreshTime")) || Date.now() + 2 * 60 * 60 * 1000;
    let expBoostEndTime = parseInt(localStorage.getItem("expBoostEndTime")) || 0;
    let storyProgress = (() => {
      const savedProgressString = localStorage.getItem("storyProgress");
      let loadedProgressArray = [];
      if (savedProgressString) {
          try {
              loadedProgressArray = JSON.parse(savedProgressString);
              if (!Array.isArray(loadedProgressArray)) {
                  console.warn("storyProgress depuis localStorage n'est pas un tableau. Il sera ignoré.");
                  loadedProgressArray = [];
              }
          } catch (e) {
              console.error("Erreur lors du parsing de storyProgress depuis localStorage:", e);
              loadedProgressArray = [];
          }
      }

      // 1. Utiliser une Map pour s'assurer que chaque niveau de allGameLevels a une entrée
      //    et que les états sauvegardés sont prioritaires.
      let currentProgressMap = new Map();

      allGameLevels.forEach(levelDefinition => {
        const savedLevelState = loadedProgressArray.find(sl => sl.id === levelDefinition.id);
        
        let isUnlockedInitial = levelDefinition.unlocked || false; // Utiliser la valeur de la définition, ou false

        // Logique de déverrouillage initial spécifique pour les types de niveaux
        if (levelDefinition.type === 'story' && !levelDefinition.isInfinite) {
            // Seul le premier niveau d'histoire (ID 1) est débloqué au départ
            isUnlockedInitial = (levelDefinition.id === 1);
        } else if (levelDefinition.type === 'material' || levelDefinition.type === 'challenge') {
            // Les niveaux de matériaux et challenges sont toujours débloqués initialement
            isUnlockedInitial = true;
        }
        // Pour les types 'legendary' et 'infinite' (sauf si ID 1), on se fie à leur `unlocked` dans allGameLevels
        // ou à la logique de migration ci-dessous.

        if (savedLevelState && typeof savedLevelState.unlocked === 'boolean' && typeof savedLevelState.completed === 'boolean') {
          // Si un état sauvegardé valide existe, on l'utilise
          currentProgressMap.set(levelDefinition.id, { ...savedLevelState });
        } else {
          // Sinon, on utilise l'état initial déduit de la définition du niveau
          currentProgressMap.set(levelDefinition.id, {
            id: levelDefinition.id,
            unlocked: isUnlockedInitial,
            completed: levelDefinition.completed || false
          });
        }
      });

      // Convertir la Map en Array pour la suite de la logique
      let currentProgress = Array.from(currentProgressMap.values());

      // 2. Logique de déblocage additionnelle pour les mondes d'histoire (migration pour joueurs existants)
      //    Cette partie est cruciale pour s'assurer que si un joueur a terminé un monde, le suivant se débloque.
      //    On utilise une liste de mondes triée par leur premier ID de niveau pour assurer l'ordre correct.
      const storyWorldDefinitions = [...new Set(baseStoryLevels
          .filter(l => l.type === 'story' && !l.isInfinite) // Uniquement les niveaux d'histoire standard
          .map(l => ({ // Créer un objet avec le nom du monde et le plus petit ID de niveau de ce monde
              world: l.world,
              firstId: Math.min(...baseStoryLevels
                  .filter(sl => sl.world === l.world && sl.type === 'story' && !sl.isInfinite)
                  .map(sl => sl.id))
          }))
          .sort((a, b) => a.firstId - b.firstId) // Trier les mondes par leur premier ID de niveau
      )];

      for (let i = 0; i < storyWorldDefinitions.length - 1; i++) { // Itérer jusqu'à l'avant-dernier monde
          const currentWorldName = storyWorldDefinitions[i].world;
          const nextWorldName = storyWorldDefinitions[i + 1].world;

          // Vérifier si tous les niveaux du monde actuel sont complétés
          const levelsInCurrentWorldProgress = currentProgress.filter(p => {
              const levelDef = baseStoryLevels.find(lDef => lDef.id === p.id);
              return levelDef && levelDef.world === currentWorldName && levelDef.type === 'story' && !levelDef.isInfinite;
          });

          if (levelsInCurrentWorldProgress.length > 0 && levelsInCurrentWorldProgress.every(p => p.completed)) {
              // Si le monde actuel est complété, trouver le premier niveau du prochain monde
              const levelsInNextWorldDefs = baseStoryLevels.filter(lDef =>
                  lDef.world === nextWorldName &&
                  lDef.type === 'story' &&
                  !lDef.isInfinite);
              
              if (levelsInNextWorldDefs.length > 0) {
                  const firstLevelOfNextWorldId = Math.min(...levelsInNextWorldDefs.map(l => l.id));
                  const progressForFirstLevelNextWorld = currentProgress.find(p => p.id === firstLevelOfNextWorldId);
                  
                  // Débloquer le premier niveau du prochain monde s'il n'est pas déjà débloqué
                  if (progressForFirstLevelNextWorld && !progressForFirstLevelNextWorld.unlocked) {
                      console.log(`[MIGRATION PROGRESSION] Déblocage du niveau ID ${firstLevelOfNextWorldId} (${levelsInNextWorldDefs.find(l=>l.id === firstLevelOfNextWorldId)?.name}) car le monde ${currentWorldName} est complété.`);
                      progressForFirstLevelNextWorld.unlocked = true;
                  }
              }
          }
      }
      
      // 3. Logique de déblocage pour le Niveau Infini (ID 49) - Si tous les niveaux d'histoire standard sont faits
      const infiniteLevelId = 49; 
      const infiniteLevelProgress = currentProgress.find(p => p.id === infiniteLevelId);
      const infiniteLevelDef = allGameLevels.find(l => l.id === infiniteLevelId && l.isInfinite);

      if (infiniteLevelProgress && infiniteLevelDef && !infiniteLevelProgress.unlocked) {
          const allStandardStoryLevels = baseStoryLevels.filter(l => l.type === 'story' && !l.isInfinite);
          const allStandardStoryLevelsCompleted = allStandardStoryLevels.every(stdLevel => {
              const progress = currentProgress.find(p => p.id === stdLevel.id);
              return progress && progress.completed;
          });

          if (allStandardStoryLevelsCompleted) {
              console.log(`[MIGRATION PROGRESSION] Déblocage de ${infiniteLevelDef.name} (ID ${infiniteLevelId}) car tous les mondes d'histoire standard sont complétés.`);
              infiniteLevelProgress.unlocked = true;
          }
      }

      // 4. Logique de déblocage pour les niveaux légendaires - Si le monde standard correspondant est terminé
      const uniqueStoryWorldNames = [...new Set(baseStoryLevels.filter(l => l.type === 'story' && !l.isInfinite).map(l => l.world))];
      uniqueStoryWorldNames.forEach(worldName => {
          const standardLevelsInThisWorld = baseStoryLevels.filter(l => l.world === worldName && l.type === 'story' && !l.isInfinite);
          const isThisStandardWorldCompleted = standardLevelsInThisWorld.length > 0 && standardLevelsInThisWorld.every(l => {
              const prog = currentProgress.find(p => p.id === l.id);
              return prog && prog.completed;
          });

          if (isThisStandardWorldCompleted) {
              const legendaryLevelForThisWorld = legendaryStoryLevels.find(ll => ll.world === worldName);
              if (legendaryLevelForThisWorld) {
                  const legendaryProgress = currentProgress.find(p => p.id === legendaryLevelForThisWorld.id);
                  if (legendaryProgress && !legendaryProgress.unlocked) {
                      console.log(`[MIGRATION PROGRESSION] Déblocage du niveau légendaire ${legendaryLevelForThisWorld.name} (ID ${legendaryLevelForThisWorld.id}) car le monde ${worldName} est complété.`);
                      legendaryProgress.unlocked = true;
                  }
              }
          }
      });


      return currentProgress;
    })();
    let selectedBattleCharacters = new Set();
    let selectedFusionCharacters = new Set();
    let currentLevelId = null;
    let currentFusionCharacterId = null;
    let soundEnabled = localStorage.getItem("soundEnabled") !== "false";
    let animationsEnabled = localStorage.getItem("animationsEnabled") !== "false";
    let theme = localStorage.getItem("theme") || "dark";
    let infiniteLevelStartTime = null;
    let everOwnedCharacters = JSON.parse(localStorage.getItem("everOwnedCharacters")) || [];
    let sortCriteria = localStorage.getItem("sortCriteria") || "power";
    let battleSortCriteria = localStorage.getItem("battleSortCriteria") || "power";
    let inventory = JSON.parse(localStorage.getItem("inventory")) || {
            "Haricots": 0,
            "Fluide mystérieux": 0,
            "Wisteria Flower": 0,
            "Pass XP": pullTickets,
            "Cursed Token": 0,
            "Shadow Tracer": 0,
            "Stat Chip": 0,
            "Reroll Token": 0,
            "Divin Wish": 0,
            "Hellsing Arms": 0,
            "Green Essence": 0,
            "Yellow Essence": 0,
            "Blue Essence": 0,
            "Pink Essence": 0,
            "Rainbow Essence": 0,
            "Crystal": 0,
            "Magic Pendant": 0,
            "Chocolate Bar's": 0,
            "Head Captain's Coat": 0,
            "Broken Sword": 0,
            "Chipped Blade": 0,
            "Cast Blades": 0,
            "Hardened Blood": 0,
            "Silverite Sword": 0,
            "Cursed Finger": 0,
            "Magic Stone": 0,
            "Magma Stone": 0,
            "Broken Pendant": 0,
            "Stone Pendant": 0,
            "Demon Beads": 0,
            "Alien Core": 0,
            "Nichirin Cleavers": 0,
            "Tavern Pie": 0,
            "Blue Chakra": 0,
            "Red Chakra": 0,
            "Skin Patch": 0,
            "Snake Scale": 0,
            "Senzu Bean": 0,
            "Holy Corpse Eyes": 0,
            "Holy Corpse Arms": 0,
            "Completed Holy Corpse": 0,
            "Gorgon's Blindfold": 0,
            "Caster's Headpiece": 0,
            "Avalon": 0,
            "Goddess' Sword": 0,
            "Blade of Death": 0,
            "Berserker's Blade": 0,
            "Shunpo Spirit": 0,
            "Energy Arrow": 0,
            "Hair Ornament": 0,
            "Bucket Hat": 0,
            "Horn of Salvation": 0,
            "Energy Bone": 0,
            "Prison Chair": 0,
            "Rotara Earring 2": 0,
            "Rotara Earring 1": 0,
            "Z Blade": 0,
            "Champ's Belt": 0,
            "Dog Bone": 0,
            "Six Eyes": 0,
            "Tome of Wisdom": 0,
            "Corrupted Visor": 0,
            "Tainted Ribbon": 0,
            "Demon Chalice": 0,
            "Essence of the Spirit King": 0,
            "Ring of Friendship": 0,
            "Red Jewel": 0,
            "Majan Essence": 0,
            "Donut": 0,
            "Atomic Essence": 0,
            "Plume Céleste": 0,
            "Sablier Ancien": 0,
            "Restricting Headband": 0,
        };
    inventory["Pass XP"] = pullTickets;
    let selectedItemsForGiving = new Map(); 
    let currentGiveItemsCharacterId = null;
    let currentEvolutionCharacterId = null;
    let selectedEvolutionItems = new Map(); 
    let purchasedOffers = JSON.parse(localStorage.getItem("purchasedOffers")) || [];
    let characterPreset = JSON.parse(localStorage.getItem("characterPreset")) || []; 
    let presetConfirmed = localStorage.getItem("presetConfirmed") === "true"; 
    let selectedPresetCharacters = new Set(); 
    let presetSortCriteria = localStorage.getItem("presetSortCriteria") || "power"; 
    let currentAutofuseCharacterId = null;
    let autofuseSelectedRarities = new Set();
    let discoveredCharacters = JSON.parse(localStorage.getItem("discoveredCharacters")) || [];
    let lastUsedBattleTeamIds = [];
    let currentCurseCharacterId = null;
    let currentStatChangeCharacterId = null; 
    let curseConfirmationCallback = null;
    let statChangeConfirmationCallback = null;
    let statChangeInfoTimeoutId = null;
    let currentTraitCharacterId = null;
    let traitKeepBetterToggleState = false;
    let traitConfirmationCallback = null;
    let infoMsgTraitTimeoutId = null;
    let currentLimitBreakCharacterId = null;
    let bannerTimerIntervalId = null;
    let currentMaxTeamSize = 3;
    let battleSearchName = localStorage.getItem("battleSearchName") || "";
    let battleFilterRarity = localStorage.getItem("battleFilterRarity") || "all";
    let presetSearchName = localStorage.getItem("presetSearchName") || "";
    let presetFilterRarity = localStorage.getItem("presetFilterRarity") || "all";
    let fusionSearchName = localStorage.getItem("fusionSearchName") || "";
    let fusionFilterRarity = localStorage.getItem("fusionFilterRarity") || "all";
    let standardPityCount = parseInt(localStorage.getItem("standardPityCount")) || 0;
    let specialPityCount = parseInt(localStorage.getItem("specialPityCount")) || 0;
    let sortCriteriaSecondary = localStorage.getItem("sortCriteriaSecondary") || "none";
    let inventoryFilterName = localStorage.getItem("inventoryFilterName") || "";
    let inventoryFilterRarity = localStorage.getItem("inventoryFilterRarity") || "all";
    let inventoryFilterEvolvable = localStorage.getItem("inventoryFilterEvolvable") === "true";
    let inventoryFilterLimitBreak = localStorage.getItem("inventoryFilterLimitBreak") === "true";
    let inventoryFilterCanReceiveExp = localStorage.getItem("inventoryFilterCanReceiveExp") === "true";
    let saveTimeoutId = null; // Pour stocker l'ID du minuteur de sauvegarde
    const SAVE_DELAY_MS = 2000; // 2 secondes de délai avant la sauvegarde
    let miniGameState = {
        isActive: false,
        bossMaxHealth: 0,
        bossCurrentHealth: 0,
        damagePerClick: 0,
        timer: 30,
        intervalId: null,
        levelData: null
    };

    // Existing DOM elements
    const gemsElement = document.getElementById("gems");
    const coinsElement = document.getElementById("coins");
    const pullCountElement = document.getElementById("pull-count");
    const levelElement = document.getElementById("level");
    const expElement = document.getElementById("exp");
    const expNeededElement = document.getElementById("exp-needed");
    const pullButton = document.getElementById("pull-button");
    const multiPullButton = document.getElementById("multi-pull-button");
    const specialPullButton = document.getElementById("special-pull-button");
    const shopElement = document.getElementById("shop");
    const missionsElement = document.getElementById("missions");
    const inventoryElement = document.getElementById("inventory");
    const playElement = document.getElementById("play");
    const missionListElement = document.getElementById("mission-list");
    const resultElement = document.getElementById("result");
    const characterDisplay = document.getElementById("character-display");
    const itemDisplay = document.getElementById("item-display");
    const shopTimerElement = document.getElementById("shop-timer");
    const missionTimerElement = document.getElementById("mission-timer");
    const shopItemsElement = document.getElementById("shop-items");
    const levelListElement = document.getElementById("level-list");
    const rareCountElement = document.getElementById("rare-count");
    const epicCountElement = document.getElementById("epic-count");
    const legendaryCountElement = document.getElementById("legendary-count");
    const mythicCountElement = document.getElementById("mythic-count");
    const secretCountElement = document.getElementById("secret-count");
    const tabButtons = document.querySelectorAll(".tab-button"); // This will include the new tab-stat-change
    const subtabButtons = document.querySelectorAll(".subtab-button"); // Keep this for Play and Inventory subtabs
    const deleteButton = document.getElementById("delete-button");
    const statsModal = document.getElementById("stats-modal");
    const modalContent = document.getElementById("modal-content");
    const fuseButton = document.getElementById("fuse-button");
    const closeModalButton = document.getElementById("close-modal");
    const characterSelectionModal = document.getElementById("character-selection-modal");
    const characterSelectionList = document.getElementById("character-selection-list");
    const selectedCountElement = document.getElementById("selected-count");
    const confirmSelectionButton = document.getElementById("confirm-selection");
    const cancelSelectionButton = document.getElementById("cancel-selection");
    const fusionModal = document.getElementById("fusion-modal");
    const fusionSelectionList = document.getElementById("fusion-selection-list");
    const fusionSelectedCountElement = document.getElementById("fusion-selected-count");
    const confirmFusionButton = document.getElementById("confirm-fusion");
    const cancelFusionButton = document.getElementById("cancel-fusion");
    const settingsButton = document.getElementById("settings-button");
    const settingsModal = document.getElementById("settings-modal");
    const soundToggle = document.getElementById("sound-toggle");
    const animationsToggle = document.getElementById("animations-toggle");
    const themeSelect = document.getElementById("theme-select");
    const resetGameButton = document.getElementById("reset-game");
    const saveSettingsButton = document.getElementById("save-settings");
    const closeSettingsButton = document.getElementById("close-settings");
    const resetConfirmModal = document.getElementById("reset-confirm-modal");
    const confirmResetButton = document.getElementById("confirm-reset");
    const cancelResetButton = document.getElementById("cancel-reset");
    const indexElement = document.getElementById("index");
    const indexDisplay = document.getElementById("index-display");
    const sortCriteriaSelect = document.getElementById("sort-criteria");
    const giveItemsModal = document.getElementById("give-items-modal");
    const giveItemsButton = document.getElementById("give-items-button");
    const itemSelectionList = document.getElementById("item-selection-list");
    const itemSelectedCountElement = document.getElementById("item-selected-count");
    const confirmGiveItemsButton = document.getElementById("confirm-give-items");
    const cancelGiveItemsButton = document.getElementById("cancel-give-items");
    const evolutionElement = document.getElementById("evolution");
    const evolutionDisplay = document.getElementById("evolution-display");
    const evolutionModal = document.getElementById("evolution-modal");
    const evolutionRequirementsElement = document.getElementById("evolution-requirements");
    const evolutionSelectionList = document.getElementById("evolution-selection-list");
    const evolutionSelectedCountElement = document.getElementById("evolution-selected-count");
    const confirmEvolutionButton = document.getElementById("confirm-evolution");
    const cancelEvolutionButton = document.getElementById("cancel-evolution");
    const autofuseSettingsButton = document.getElementById("autofuse-settings-button");
    const autofuseModal = document.getElementById("autofuse-modal");
    const autofuseMainCharacterElement = document.getElementById("autofuse-main-character");
    const autofuseCharacterGrid = document.getElementById("autofuse-character-grid");
    const autofuseCountElement = document.getElementById("autofuse-count");
    const confirmAutofuseButton = document.getElementById("confirm-autofuse");
    const cancelAutofuseButton = document.getElementById("cancel-autofuse");
    const autofuseRarityCheckboxes = {
      Rare: document.getElementById("autofuse-rare"),
      Épique: document.getElementById("autofuse-epic"),
      Légendaire: document.getElementById("autofuse-legendary"),
      Mythic: document.getElementById("autofuse-mythic"),
      Secret: document.getElementById("autofuse-secret")
    };
    const presetSelectionModal = document.getElementById("preset-selection-modal");
    const presetSelectionList = document.getElementById("preset-selection-list");
    const presetSelectedCountDisplayElement = document.getElementById("preset-selected-count-display");
    const confirmPresetButton = document.getElementById("confirm-preset");
    const cancelPresetButton = document.getElementById("cancel-preset");
    const pullMethodModal = document.getElementById("pull-method-modal");
    const pullWithGemsButton = document.getElementById("pull-with-gems");
    const pullWithTicketButton = document.getElementById("pull-with-ticket");
    const cancelPullMethodButton = document.getElementById("cancel-pull-method");
    let currentPullType = null; 
    const infoButton = document.getElementById("info-button");
    const probabilitiesModal = document.getElementById("probabilities-modal");
    const closeProbabilitiesButton = document.getElementById("close-probabilities");
    const probTabButtons = document.querySelectorAll(".prob-tab-button");
    const standardProbabilities = document.getElementById("standard-probabilities");
    const specialProbabilities = document.getElementById("special-probabilities");
    const tabCurseButton = document.getElementById("tab-curse");
    const curseElement = document.getElementById("curse");
    const cursedTokenCountElement = document.getElementById("cursed-token-count");
    const curseSelectedCharacterDisplayElement = document.getElementById("curse-selected-character-display");
    const curseCharacterSelectionGridElement = document.getElementById("curse-character-selection-grid");
    const applyCurseButton = document.getElementById("apply-curse-button");
    let currentStandardBanner = { Mythic: [], generatedAt: 0 };
    const statRankInfoButton = document.getElementById("stat-rank-info-button");
    const statRankProbabilitiesModal = document.getElementById("stat-rank-probabilities-modal");
    const statRankProbabilitiesContent = document.getElementById("stat-rank-probabilities-content");
    const closeStatRankProbabilitiesModalButton = document.getElementById("close-stat-rank-probabilities-modal-button");
    const curseKeepBetterToggle = document.getElementById("curse-keep-better-toggle");
    const curseMinPercentageInput = document.getElementById("curse-min-percentage");
    const curseConfirmContinueModal = document.getElementById("curse-confirm-continue-modal");
    const curseConfirmMessageElement = document.getElementById("curse-confirm-message");
    const curseConfirmYesButton = document.getElementById("curse-confirm-yes-button");
    const curseConfirmNoButton = document.getElementById("curse-confirm-no-button");
    const statKeepBetterToggle = document.getElementById("stat-keep-better-toggle");
    const statTargetRanksSelectionElement = document.getElementById("stat-target-ranks-selection");
    const statChangeConfirmContinueModal = document.getElementById("stat-change-confirm-continue-modal");
    const statChangeConfirmMessageElement = document.getElementById("stat-change-confirm-message");
    const statChangeConfirmYesButton = document.getElementById("stat-change-confirm-yes-button");
    const statChangeConfirmNoButton = document.getElementById("stat-change-confirm-no-button");
    const statChangeElement = document.getElementById("stat-change"); // Pour le nouvel onglet principal

    const TRAIT_REMOVAL_COST = 5; // Cost in Reroll Token to remove a trait
    const APPLY_NEW_TRAIT_COST = 1;
    const tabTraitButton = document.getElementById("tab-trait"); // NOUVEAU
    const traitElement = document.getElementById("trait"); // NOUVEAU
    const traitEssenceCountElement = document.getElementById("trait-essence-count"); // NOUVEAU
    const traitSelectedCharacterDisplayElement = document.getElementById("trait-selected-character-display"); // NOUVEAU
    const traitCharacterSelectionGridElement = document.getElementById("trait-character-selection-grid"); // NOUVEAU
    const traitAvailableListElement = document.getElementById("trait-available-list"); // NOUVEAU
    const removeTraitButton = document.getElementById("remove-trait-button"); // NOUVEAU
    const traitCharSearchInput = document.getElementById("trait-char-search"); // NOUVEAU
    const traitProbabilitiesInfoButton = document.getElementById("trait-probabilities-info-button");
    const traitProbabilitiesModal = document.getElementById("trait-probabilities-modal");
    const traitProbabilitiesContent = document.getElementById("trait-probabilities-content");
    const closeTraitProbabilitiesModalButton = document.getElementById("close-trait-probabilities-modal-button");
    const traitKeepBetterToggle = document.getElementById("trait-keep-better-toggle");
    const traitTargetSelectionElement = document.getElementById("trait-target-selection");
    const traitActionConfirmModal = document.getElementById("trait-action-confirm-modal");
    const traitActionConfirmMessageElement = document.getElementById("trait-action-confirm-message");
    const tabLimitBreakButton = document.getElementById("tab-limit-break"); // AJOUT
    const limitBreakElement = document.getElementById("limit-break"); // AJOUT
    const transcendenceOrbCountElement = document.getElementById("transcendence-orb-count"); // AJOUT
    const limitBreakSelectedCharDisplayElement = document.getElementById("limit-break-selected-char-display"); // AJOUT
    const limitBreakCharSelectionGridElement = document.getElementById("limit-break-char-selection-grid"); // AJOUT
    const applyLimitBreakButton = document.getElementById("apply-limit-break-button"); // AJOUT
    const traitActionConfirmYesButton = document.getElementById("trait-action-confirm-yes-button");
    const traitActionConfirmNoButton = document.getElementById("trait-action-confirm-no-button");
    const LIMIT_BREAK_LEVEL_INCREASE = 5;
    const MAX_POSSIBLE_LEVEL_CAP = 100; 
    const LIMIT_BREAK_COST = 1;
    const STANDARD_MYTHIC_PITY_THRESHOLD = 10000;
    const SPECIAL_BANNER_PITY_THRESHOLD = 85000;
    const miniGameModal = document.getElementById('mini-game-modal');
    const miniGameStartScreen = document.getElementById('mini-game-start-screen');
    const miniGameMainScreen = document.getElementById('mini-game-main-screen');
    const miniGameResultScreen = document.getElementById('mini-game-result-screen');
    const miniGameStartButton = document.getElementById('mini-game-start-button');
    const miniGameBossImage = document.getElementById('mini-game-boss-image');
    const miniGameTimerEl = document.getElementById('mini-game-timer');
    const miniGameHealthBar = document.getElementById('mini-game-boss-health-bar');
    const miniGameHealthText = document.getElementById('mini-game-boss-health-text');
    const miniGameCloseButton = document.getElementById('mini-game-close-button');
    const miniGameDamageContainer = document.getElementById('mini-game-damage-container');

    
    const pullSound = new Audio("https://freesound.org/data/previews/270/270333_5121236-lq.mp3");
    const buySound = new Audio("https://freesound.org/data/previews/156/156859_2048418-lq.mp3");
    const battleSound = new Audio("https://freesound.org/data/previews/270/270330_5121236-lq.mp3");
    const winSound = new Audio('');
    const loseSound = new Audio('');

    function setupAuthUI() {
        // Logique pour basculer entre les vues de connexion et d'inscription
        document.getElementById('show-signup').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('login-view').classList.add('hidden');
            document.getElementById('signup-view').classList.remove('hidden');
            document.getElementById('auth-error').textContent = '';
        });

        document.getElementById('show-login').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('signup-view').classList.add('hidden');
            document.getElementById('login-view').classList.remove('hidden');
            document.getElementById('auth-error').textContent = '';
        });

        // Gestion des soumissions de formulaire
        document.getElementById('login-form').addEventListener('submit', handleLogin);
        document.getElementById('signup-form').addEventListener('submit', handleSignup);
        document.getElementById('logout-button').addEventListener('click', handleLogout);
    }

    function initializeGameData(saveData) {
        // Cas 1: Nouvelle partie (pas de sauvegarde trouvée)
        if (!saveData) {
            console.log("Aucune sauvegarde trouvée, initialisation d'une nouvelle partie.");
            
            // Variables de base du joueur
            characterIdCounter = 0;
            gems = 1000;
            coins = 0;
            pullCount = 0;
            ownedCharacters = [];
            level = 1;
            exp = 0;
            expMultiplier = 1;
            pullTickets = 0;
            
            // Variables de progression et d'état
            missions = [];
            shopOffers = [];
            shopRefreshTime = Date.now() + TWO_HOURS_MS;
            expBoostEndTime = 0;
            storyProgress = allGameLevels.map(level => ({
                id: level.id,
                unlocked: level.type === 'challenge' ? true : (level.type === 'material' ? true : (level.type === 'story' && level.id === 1)),
                completed: false
            }));
            discoveredCharacters = [];
            characterPreset = [];
            presetConfirmed = false;
            standardPityCount = 0;
            specialPityCount = 0;
            lastUsedBattleTeamIds = [];

            // Paramètres par défaut
            autosellSettings = { Rare: false, Épique: false, Légendaire: false, Mythic: false, Secret: false };

            // Inventaire par défaut (tous les objets à 0)
            inventory = {
                "Haricots": 0, "Fluide mystérieux": 0, "Wisteria Flower": 0, "Pass XP": 0,
                "Cursed Token": 0, "Shadow Tracer": 0, "Stat Chip": 0, "Reroll Token": 0, "Divin Wish": 0,
                "Hellsing Arms": 0, "Green Essence": 0, "Yellow Essence": 0, "Blue Essence": 0,
                "Pink Essence": 0, "Rainbow Essence": 0, "Crystal": 0, "Magic Pendant": 0,
                "Chocolate Bar's": 0, "Head Captain's Coat": 0, "Broken Sword": 0, "Chipped Blade": 0,
                "Cast Blades": 0, "Hardened Blood": 0, "Silverite Sword": 0, "Cursed Finger": 0,
                "Magic Stone": 0, "Magma Stone": 0, "Broken Pendant": 0, "Stone Pendant": 0,
                "Demon Beads": 0, "Alien Core": 0, "Nichirin Cleavers": 0, "Tavern Pie": 0,
                "Blue Chakra": 0, "Red Chakra": 0, "Skin Patch": 0, "Snake Scale": 0, "Senzu Bean": 0,
                "Holy Corpse Eyes": 0, "Holy Corpse Arms": 0, "Completed Holy Corpse": 0,
                "Gorgon's Blindfold": 0, "Caster's Headpiece": 0, "Avalon": 0, "Goddess' Sword": 0,
                "Blade of Death": 0, "Berserker's Blade": 0, "Shunpo Spirit": 0, "Energy Arrow": 0,
                "Hair Ornament": 0, "Bucket Hat": 0, "Horn of Salvation": 0, "Energy Bone": 0,
                "Prison Chair": 0, "Rotara Earring 2": 0, "Rotara Earring 1": 0, "Z Blade": 0,
                "Champ's Belt": 0, "Dog Bone": 0, "Six Eyes": 0, "Tome of Wisdom": 0,
                "Corrupted Visor": 0, "Tainted Ribbon": 0, "Demon Chalice": 0, "Essence of the Spirit King": 0,
                "Ring of Friendship": 0, "Red Jewel": 0, "Majan Essence": 0, "Donut": 0, "Atomic Essence": 0,
                "Plume Céleste": 0, "Sablier Ancien": 0, "Restricting Headband": 0, "Toil Ribbon": 0
            };

        // Cas 2: Chargement d'une partie existante
        } else {
            console.log("Sauvegarde trouvée, chargement de la progression.");
            
            // Charger les données depuis l'objet saveData, en utilisant "||" pour fournir
            // une valeur par défaut si une propriété n'existe pas dans la sauvegarde (utile pour les mises à jour du jeu).
            characterIdCounter = saveData.characterIdCounter || 0;
            gems = saveData.gems || 1000;
            coins = saveData.coins || 0;
            pullCount = saveData.pullCount || 0;
            ownedCharacters = saveData.ownedCharacters || [];
            level = saveData.level || 1;
            exp = saveData.exp || 0;
            expMultiplier = saveData.expMultiplier || 1;
            pullTickets = saveData.pullTickets || 0;
            missions = saveData.missions || [];
            shopOffers = saveData.shopOffers || [];
            shopRefreshTime = saveData.shopRefreshTime || (Date.now() + TWO_HOURS_MS);
            expBoostEndTime = saveData.expBoostEndTime || 0;
            storyProgress = saveData.storyProgress || allGameLevels.map(level => ({
                id: level.id,
                unlocked: level.type === 'challenge' ? true : (level.type === 'material' ? true : (level.type === 'story' && level.id === 1)),
                completed: false
            }));
            inventory = saveData.inventory || {}; // Un objet vide est une bonne valeur par défaut
            discoveredCharacters = saveData.discoveredCharacters || [];
            characterPreset = saveData.characterPreset || [];
            presetConfirmed = saveData.presetConfirmed || false;
            standardPityCount = saveData.standardPityCount || 0;
            specialPityCount = saveData.specialPityCount || 0;
            lastUsedBattleTeamIds = saveData.lastUsedBattleTeamIds || [];
            autosellSettings = saveData.autosellSettings || { Rare: false, Épique: false, Légendaire: false, Mythic: false, Secret: false };
            
            // Assurer la cohérence entre pullTickets et l'inventaire
            if (inventory) {
                inventory["Pass XP"] = pullTickets;
            }
        }

        // 1. Mettre à jour les données et les états internes en premier.
        updateLegendeDisplay();
        updateChallengeDisplay();
        updateMaterialFarmDisplay();
        updateShopDisplay();
        updateMissions();
        applySettings();
        updateTimer();

        // 2. Mettre à jour l'affichage de l'UI principale avec les données finalisées.
        updateUI();
        updateCharacterDisplay();
        updateItemDisplay();
        updateIndexDisplay();
        updateEvolutionDisplay();
        updateStatChangeTabDisplay();
        updateCurseTabDisplay();
        updateTraitTabDisplay();
        updateLimitBreakTabDisplay();

        // 3. Mettre à jour l'affichage des niveaux AVANT de montrer l'onglet
        updateLevelDisplay(); // <-- Ligne cruciale restaurée ici

        // 4. Afficher le premier onglet maintenant que tout est prêt.
        showTab("play");
        
        // 5. Marquer le jeu comme initialisé.
        isGameInitialized = true;

        // 6. Planifier une sauvegarde initiale une fois que tout est chargé.
        scheduleSave();
    }

    async function handleLogin(e) {
        e.preventDefault();
        document.getElementById('auth-error').textContent = '';
        const username = document.getElementById('login-username').value.trim();
        const password = document.getElementById('login-password').value;

        if (!username || !password) {
            document.getElementById('auth-error').textContent = "Veuillez remplir tous les champs.";
            return;
        }

        try {
            // 1. Chercher le pseudo dans Firestore pour trouver l'email associé
            const usernameDocRef = db.collection('usernames').doc(username.toLowerCase());
            const doc = await usernameDocRef.get();

            if (!doc.exists) {
                throw new Error("Ce pseudo n'existe pas.");
            }

            const email = doc.data().email;

            // 2. Se connecter avec l'email récupéré et le mot de passe fourni
            await auth.signInWithEmailAndPassword(email, password);
            // L'observateur onAuthStateChanged s'occupera du reste

        } catch (error) {
            console.error("Erreur de connexion:", error);
            if (error.code === 'auth/wrong-password') {
                document.getElementById('auth-error').textContent = "Mot de passe incorrect.";
            } else {
                document.getElementById('auth-error').textContent = `Erreur: ${error.message}`;
            }
        }
    }

    // MODIFIÉ: Gère l'inscription avec un pseudo
    async function handleSignup(e) {
        e.preventDefault();
        document.getElementById('auth-error').textContent = '';
        const username = document.getElementById('signup-username').value.trim();
        const password = document.getElementById('signup-password').value;

        // Validation du pseudo
        if (username.length < 3 || username.length > 15) {
            document.getElementById('auth-error').textContent = "Le pseudo doit contenir entre 3 et 15 caractères.";
            return;
        }
        if (!/^[a-zA-Z0-9_]+$/.test(username)) {
            document.getElementById('auth-error').textContent = "Le pseudo ne peut contenir que des lettres, des chiffres et des underscores (_).";
            return;
        }

        try {
            // 1. Vérifier si le pseudo est déjà pris dans Firestore (en minuscules pour être insensible à la casse)
            const usernameDocRef = db.collection('usernames').doc(username.toLowerCase());
            const doc = await usernameDocRef.get();

            if (doc.exists) {
                throw new Error("Ce pseudo est déjà utilisé.");
            }

            // 2. Générer un email synthétique pour Firebase Auth
            const email = `${username.toLowerCase()}@gacha-game-ultime.com`; // Le domaine n'a pas besoin d'exister

            // 3. Créer l'utilisateur dans Firebase Auth
            const userCredential = await auth.createUserWithEmailAndPassword(email, password);
            const user = userCredential.user;

            // 4. Enregistrer l'association pseudo/email et uid dans Firestore
            await usernameDocRef.set({
                email: user.email,
                uid: user.uid,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            // L'observateur onAuthStateChanged s'occupera du reste

        } catch (error) {
            console.error("Erreur d'inscription:", error);
            if (error.code === 'auth/weak-password') {
                document.getElementById('auth-error').textContent = "Le mot de passe est trop faible.";
            } else {
                document.getElementById('auth-error').textContent = `Erreur: ${error.message}`;
            }
        }
    }

    async function handleLogout() {
        console.log("[LOGOUT] Sauvegarde immédiate avant déconnexion.");
        await _performSave(); // Attend que la sauvegarde soit terminée
        auth.signOut();
    }

    function getRandomStatRank(fromPull = false) {
        let random = Math.random();
        let cumulativeProbability = 0;
        let obtainedRankKey = statRankProbabilities[statRankProbabilities.length - 1].rank; // Fallback au rang le plus bas

        for (const entry of statRankProbabilities) {
            cumulativeProbability += entry.probability;
            if (random < cumulativeProbability) {
                obtainedRankKey = entry.rank;
                break;
            }
        }

        if (fromPull) {
            const rankBOrder = statRanks["B"]?.order;
            const obtainedRankOrder = statRanks[obtainedRankKey]?.order;

            // Safety checks for undefined orders (should not happen with correct statRanks definition)
            if (rankBOrder === undefined) {
                console.error("Stat rank 'B' definition or its order is missing in statRanks. Cannot cap pulls.");
                return obtainedRankKey; // Return original if 'B' is not properly defined
            }
            if (obtainedRankOrder === undefined) {
                console.warn(`Obtained rank '${obtainedRankKey}' has no order defined. Cannot compare for capping. Returning original.`);
                return obtainedRankKey;
            }

            if (obtainedRankOrder > rankBOrder) {
                return "B"; // Cap to "B" if the obtained rank is higher than B
            }
        }
        return obtainedRankKey;
    }

    function recalculateCharacterPower(char) {
        if (!char.statRank || !statRanks[char.statRank]) {
            char.statRank = "A"; // Rang par défaut si non défini
            char.statModifier = statRanks["A"].modifier;
        } else if (typeof char.statModifier === 'undefined' || char.statModifier === null || isNaN(Number(char.statModifier))) {
            char.statModifier = statRanks[char.statRank].modifier;
        }

        let powerBeforeTrait = char.basePower * char.statModifier;
        let traitPowerBonus = 0; // Généralement pas utilisé si powerMultiplier est présent pour le même trait
        let traitPowerMultiplier = 1.0;

        if (char.trait && char.trait.id && char.trait.grade > 0) {
            const traitDef = TRAIT_DEFINITIONS[char.trait.id];
            if (traitDef && traitDef.grades) {
                const gradeDef = traitDef.grades.find(g => g.grade === char.trait.grade);
                if (gradeDef) {
                    // Gère les bonus de puissance directs (comme +X Puissance) - Moins courant avec les multiplicateurs
                    if (typeof gradeDef.powerBonus === 'number') {
                        traitPowerBonus = gradeDef.powerBonus;
                    }
                    // Gère les multiplicateurs de puissance (comme +Y% Puissance)
                    // S'applique aux traits comme Strength, Monarch
                    if (typeof gradeDef.powerMultiplier === 'number') {
                        traitPowerMultiplier = 1.0 + gradeDef.powerMultiplier;
                    }
                    // Note: Les traits de puissance spécifiques au mode (Berserk, Legends, Challenge Master)
                    // sont gérés dans la fonction `confirmSelection` car ils ne modifient pas la puissance de base
                    // du personnage, mais sa puissance effective pendant un combat spécifique.
                }
            }
        }
        
        let powerAfterTraitMultiplier = powerBeforeTrait * traitPowerMultiplier;
        let powerAfterTraitBonus = powerAfterTraitMultiplier + traitPowerBonus; // Appliquer le bonus additif après le multiplicateur
        
        char.power = Math.max(1, Math.floor(powerAfterTraitBonus) + (char.curseEffect || 0));

        if (isNaN(char.power) || char.power <= 0) {
            const baseDefinition = allCharacters.find(c => c.name === char.name);
            const initialPowerFromDefinition = baseDefinition ? baseDefinition.power : 50;
            if (isNaN(char.basePower) || char.basePower <=0) char.basePower = initialPowerFromDefinition / (char.statModifier || 1);
            powerBeforeTrait = char.basePower * (char.statModifier || 1);
            powerAfterTraitMultiplier = powerBeforeTrait * traitPowerMultiplier;
            powerAfterTraitBonus = powerAfterTraitMultiplier + traitPowerBonus;
            char.power = Math.max(1, Math.floor(powerAfterTraitBonus) + (char.curseEffect || 0));
        }
    }

    function showProbTab(tabId) {
      document.getElementById("prob-standard").classList.add("hidden");
      document.getElementById("prob-special").classList.add("hidden");
      document.getElementById(`prob-${tabId}`).classList.remove("hidden");
      probTabButtons.forEach(btn => {
        btn.classList.toggle("border-blue-500", btn.dataset.tab === tabId);
        btn.classList.toggle("border-transparent", btn.dataset.tab !== tabId);
      });
    }

    function populateTargetStatRanks() {
        statTargetRanksSelectionElement.innerHTML = "";
        Object.keys(statRanks).sort((a,b) => statRanks[a].order - statRanks[b].order).forEach(rankKey => {
            const rankData = statRanks[rankKey];
            const label = document.createElement("label");
            label.className = `flex items-center p-1.5 rounded hover:bg-gray-600 transition-colors duration-150`;
            label.innerHTML = `
                <input type="checkbox" value="${rankKey}" class="stat-target-rank-checkbox mr-2 h-4 w-4 ${rankData.borderColor ? rankData.borderColor.replace('border-', 'text-') : 'text-teal-500'} border-gray-400 rounded focus:ring-transparent">
                <span class="${rankData.color || 'text-white'} text-sm font-medium">${rankKey}</span>
            `;
            // AJOUT DE L'ÉCOUTEUR D'ÉVÉNEMENT
            const checkbox = label.querySelector('.stat-target-rank-checkbox');
            checkbox.addEventListener('change', () => {
                if (statKeepBetterToggle.checked) { // Seulement mettre à jour si le toggle principal est actif
                    updateStatChangeTabDisplay();
                }
            });
            statTargetRanksSelectionElement.appendChild(label);
        });
    }

    function formatTime(ms) {
      if (ms <= 0) return "00:00:00";
      let seconds = Math.floor((ms / 1000) % 60);
      let minutes = Math.floor((ms / (1000 * 60)) % 60);
      let hours = Math.floor(ms / (1000 * 60 * 60));

      hours = hours < 10 ? "0" + hours : hours;
      minutes = minutes < 10 ? "0" + minutes : minutes;
      seconds = seconds < 10 ? "0" + seconds : seconds;

      return `${hours}:${minutes}:${seconds}`;
    }

    function updateProbabilitiesDisplay() {
        standardProbabilities.innerHTML = ""; // Vider le contenu précédent
        const decimalPlaces = 5;

        // --- DÉBUT DES AJOUTS POUR LE MINUTEUR DE BANNIÈRE ---
        const probStandardDiv = document.getElementById("prob-standard");
        const h3Title = probStandardDiv ? probStandardDiv.querySelector('h3') : null;

        // Supprimer un ancien conteneur de minuteur s'il existe (pour éviter les doublons lors des mises à jour)
        if (h3Title) {
            const existingTimerContainer = h3Title.querySelector('#banner-change-timer-container-title');
            if (existingTimerContainer) {
                existingTimerContainer.remove();
            }
        }

        let bannerTimerHTMLForTitle = "";
        if (h3Title && currentStandardBanner && currentStandardBanner.generatedAt) {
            const nextChangeTime = currentStandardBanner.generatedAt + TWO_HOURS_MS;
            const timeLeftMs = Math.max(0, nextChangeTime - Date.now()); // S'assurer que le temps n'est pas négatif

            bannerTimerHTMLForTitle = `
                <div id="banner-change-timer-container-title" class="ml-4 text-sm sm:text-base text-gray-300">
                  (Change dans: <span id="standard-banner-timer-title" class="font-bold text-yellow-300">${formatTime(timeLeftMs)}</span>)
                </div>
            `;
            h3Title.classList.add('flex', 'items-center', 'flex-wrap'); // flex-wrap si le titre est long
            h3Title.insertAdjacentHTML('beforeend', bannerTimerHTMLForTitle);

        } else if (h3Title) {
             bannerTimerHTMLForTitle = `
                <div id="banner-change-timer-container-title" class="ml-4 text-sm sm:text-base text-gray-300">
                  (Chargement du minuteur...)
                </div>
            `;
            h3Title.classList.add('flex', 'items-center', 'flex-wrap');
            h3Title.insertAdjacentHTML('beforeend', bannerTimerHTMLForTitle);
        }
        // --- FIN DES AJOUTS POUR LE MINUTEUR DE BANNIÈRE ---


        const mythicConfig = BANNER_CONFIG.Mythic;
        const featuredMythicNames = currentStandardBanner.Mythic || [];
        const allMythicCharsStd = standardCharacters.filter(char => char.rarity === "Mythic");

        // 1. Afficher les Mythics en Vedette individuellement
        featuredMythicNames.forEach((charName, index) => {
            const charData = allMythicCharsStd.find(c => c.name === charName);
            if (!charData) return;
            let individualChance = 0;
            if (mythicConfig.featuredRelativeWeights && mythicConfig.featuredRelativeWeights.length === featuredMythicNames.length) {
                 individualChance = mythicConfig.overallChance * mythicConfig.featuredPoolRatio * mythicConfig.featuredRelativeWeights[index];
            } else if (featuredMythicNames.length > 0) {
                individualChance = (mythicConfig.overallChance * mythicConfig.featuredPoolRatio) / featuredMythicNames.length;
            }

            standardProbabilities.innerHTML += `
                <div class="bg-gray-700 p-4 rounded-lg border-2 ${getRarityBorderClass(charData.rarity)}">
                    <div class="flex items-center gap-4">
                        <img src="${charData.image}" alt="${charData.name}" class="object-contain">
                        <div>
                            <p class="rainbow-text font-semibold">${charData.name} (Vedette)</p>
                            <p class="text-white">Probabilité: ${(individualChance * 100).toFixed(decimalPlaces)}%</p>
                        </div>
                    </div>
                </div>`;
        });

        // 2. Afficher la probabilité groupée pour les Mythics Non-Vedette
        const totalChanceNonFeaturedMythic = mythicConfig.overallChance * (1 - mythicConfig.featuredPoolRatio);
        if (totalChanceNonFeaturedMythic > 0 && allMythicCharsStd.filter(char => !featuredMythicNames.includes(char.name)).length > 0) {
            standardProbabilities.innerHTML += `
                <div class="bg-gray-600 p-4 rounded-lg border-2 ${getRarityBorderClass("Mythic")}">
                    <div class="flex items-center gap-4">
                        <div>
                            <p class="rainbow-text font-semibold">Autres personnages Mythiques</p>
                            <p class="text-white">Probabilité globale: ${(totalChanceNonFeaturedMythic * 100).toFixed(decimalPlaces)}%</p>
                        </div>
                    </div>
                </div>`;
        }

        // 3. Afficher les probabilités groupées pour les autres raretés
        ["Secret", "Légendaire", "Épique", "Rare"].forEach(rarity => {
            const rarityConfig = BANNER_CONFIG[rarity];
            if (!rarityConfig || rarityConfig.overallChance === 0) {
                return;
            }
            let rarityDisplayName = `Personnages ${rarity === "Épique" ? "Épiques" : (rarity + (rarity.endsWith('e') || rarity.endsWith('s') ? '' : 's'))}`;
            if (rarity === "Légendaire") rarityDisplayName = "Personnages Légendaires";

            let textColorClass = "";
            switch(rarity) {
                case "Secret": textColorClass = "text-secret"; break;
                case "Légendaire": textColorClass = "text-yellow-400"; break;
                case "Épique": textColorClass = "text-purple-400"; break;
                case "Rare": textColorClass = "text-gray-400"; break;
                default: textColorClass = "text-white";
            }

            standardProbabilities.innerHTML += `
                <div class="bg-gray-600 p-4 rounded-lg border-2 ${getRarityBorderClass(rarity)}">
                    <div class="flex items-center gap-4">
                        <div>
                            <p class="${textColorClass} font-semibold">${rarityDisplayName}</p>
                            <p class="text-white">Probabilité globale: ${(rarityConfig.overallChance * 100).toFixed(decimalPlaces)}%</p>
                        </div>
                    </div>
                </div>`;
        });

        // Bannière Spéciale (inchangée)
        specialProbabilities.innerHTML = specialCharacters.map(char => {
            // ... (code existant pour specialProbabilities) ...
            let textColorClass = char.color;
            if (char.rarity === "Mythic") textColorClass = "rainbow-text";
            else if (char.rarity === "Secret") textColorClass = "text-secret";
            else if (char.rarity === "Légendaire") textColorClass = "text-yellow-400";
            else if (char.rarity === "Épique") textColorClass = "text-purple-400";
            else if (char.rarity === "Rare") textColorClass = "text-gray-400";
            return `
            <div class="bg-gray-700 p-4 rounded-lg border-2 ${getRarityBorderClass(char.rarity)}">
                <div class="flex items-center gap-4">
                    <img src="${char.image}" alt="${char.name}" class="object-contain">
                    <div>
                        <p class="${textColorClass} font-semibold">${char.name} (${char.rarity})</p>
                        <p class="text-white">Probabilité: ${(char.chance * 100).toFixed(decimalPlaces)}%</p>
                    </div>
                </div>
            </div>`;
        }).join("");
    }

    function getRandomGradeForTrait(traitDef) {
        if (!traitDef || !traitDef.grades || traitDef.grades.length === 0) {
            console.warn(`Le trait ${traitDef?.name || 'inconnu'} n'a pas de grades définis. Fallback.`);
            return { grade: 1, description: "Erreur: Trait sans grade" }; // Fallback
        }

        // If gradeProbabilities is defined and not empty, use the existing logic for multi-grade traits
        if (traitDef.gradeProbabilities && traitDef.gradeProbabilities.length > 0) {
            let randomNumber = Math.random();
            let cumulativeProbability = 0;

            for (const gradeProb of traitDef.gradeProbabilities) {
                cumulativeProbability += gradeProb.probability;
                if (randomNumber <= cumulativeProbability) {
                    const chosenGradeDef = traitDef.grades.find(g => g.grade === gradeProb.grade);
                    return chosenGradeDef || { grade: gradeProb.grade, description: `Grade ${gradeProb.grade} (desc. manquante)` };
                }
            }
            // Fallback if sum of probabilities isn't 1 or other error for multi-grade
            console.warn(`Fallback dans getRandomGradeForTrait (multi-grade) pour ${traitDef.name}. Somme des probabilités de grade != 1?`);
            return traitDef.grades[traitDef.grades.length - 1]; // Returns the highest grade definition in case of issues
        } else {
            // If no gradeProbabilities, assume it's a single-grade trait.
            // Return its first (and only) grade definition.
            // We expect traitDef.grades[0] to have a `grade` property (e.g., grade: 1).
            const singleGradeDef = { ...traitDef.grades[0] };
             // Ensure the 'grade' property exists, default to 1 if not.
            if (typeof singleGradeDef.grade === 'undefined') {
                console.warn(`Trait ${traitDef.name} (single-grade) missing 'grade' property in its definition. Defaulting to grade 1.`);
                singleGradeDef.grade = 1;
            }
            return singleGradeDef;
        }
    }

    function openStatRankProbabilitiesModal() {
        statRankProbabilitiesContent.innerHTML = ""; // Vider le contenu précédent
        statRankProbabilities.forEach(probEntry => {
            const rankData = statRanks[probEntry.rank];
            const percentage = (probEntry.probability * 100).toFixed(probEntry.probability < 0.01 ? 2 : 1); // Plus de décimales pour les petites probas

            const probDiv = document.createElement("div");
            probDiv.className = "flex justify-between items-center p-2 bg-gray-700 rounded";
            probDiv.innerHTML = `
                <span class="${rankData.color || 'text-white'} font-semibold">Rang ${probEntry.rank}</span>
                <span class="text-white">${percentage}%</span>
            `;
            statRankProbabilitiesContent.appendChild(probDiv);
        });
        statRankProbabilitiesModal.classList.remove("hidden");
        enableNoScroll();
    }

    function closeStatRankProbabilitiesModal() {
        statRankProbabilitiesModal.classList.add("hidden");
        disableNoScroll();
    }

    function getExpNeededForCharacterLevel(level, rarity) {
      const baseExp = 50 * level * level; 
      const multiplier = rarityExpMultipliers[rarity] || 1.0; 
      return Math.floor(baseExp * multiplier); 
    }

    function updateLevelDisplay() {
          const worlds = baseStoryLevels.reduce((acc, level) => {
            if (!acc[level.world]) acc[level.world] = [];
            acc[level.world].push(level);
            return acc;
          }, {});
          levelListElement.innerHTML = Object.entries(worlds).map(([worldName, levels]) => {
            const progressLevels = levels.map(level => storyProgress.find(p => p.id === level.id));
            const worldUnlocked = progressLevels.some(p => p.unlocked);
            const worldCompleted = progressLevels.every(p => p.completed);
            return `
              <div class="mb-6">
                <h3 class="text-xl text-white font-bold mb-2">${worldName} ${worldCompleted ? '(Terminé)' : ''}</h3>
                <div class="grid gap-4">
                  ${worldUnlocked ? levels.map(level => {
                    const progress = storyProgress.find(p => p.id === level.id);
                    const isDisabled = !progress.unlocked;
                    const buttonText = level.isInfinite ? `${level.name} (Gemmes/min: ${level.rewards.gemsPerMinute})` : `${level.name} ${progress.completed ? '(Terminé)' : ''}`;
                    return `<button class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}" onclick="${level.isInfinite ? 'startInfiniteLevel(' : 'startLevel('}${level.id})" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>`;
                  }).join("") : '<p class="text-white">Monde verrouillé. Terminez le monde précédent pour déverrouiller.</p>'}
                </div>
              </div>`;
          }).join("");
          const groupedLevels = storyProgress.reduce((acc, level) => {
            const world = level.id <= 6 ? "Royaume des Ombres" : level.id <= 12 ? "Empire de Cristal" : level.id <= 18 ? "Profondeurs Abyssales" : level.id <= 24 ? "Pics Célestes" : level.id <= 30 ? "Déserts du Vide" : level.id <= 36 ? "Éclipse Éternelle" : "Abîme Infini";
            acc[world] = acc[world] || [];
            acc[world].push(level);
            return acc;
          }, {});
          document.querySelectorAll('.start-level-button').forEach(button => {
            button.addEventListener('click', () => {
              currentLevelId = parseInt(button.dataset.levelId);
              selectedBattleCharacters.clear();
              characterSelectionModal.classList.remove('hidden');
              enableNoScroll();
              updateCharacterSelectionDisplay();
            });
          });
    }

    function updateLegendeDisplay() {
        const legendeLevelListElement = document.getElementById("legende-level-list");
        if (!legendeLevelListElement) return;

        legendeLevelListElement.innerHTML = ""; // Vider le contenu précédent

        const uniqueWorldsInStory = [...new Set(baseStoryLevels.filter(lvl => !lvl.isInfinite).map(level => level.world))];

        let foundLegendaryLevel = false;
        uniqueWorldsInStory.forEach(worldName => {
            const standardLevelsInWorld = baseStoryLevels.filter(level => level.world === worldName && !level.isInfinite && level.type !== 'legendary');
            const worldCompleted = standardLevelsInWorld.length > 0 && standardLevelsInWorld.every(level => {
                const progress = storyProgress.find(p => p.id === level.id);
                return progress && progress.completed;
            });

            const legendaryLevelForWorld = legendaryStoryLevels.find(ll => ll.world === worldName);

            if (legendaryLevelForWorld) {
                let legendaryProgress = storyProgress.find(p => p.id === legendaryLevelForWorld.id);
                if (!legendaryProgress) { // S'assurer que la progression existe pour les niveaux légendaires
                    legendaryProgress = { id: legendaryLevelForWorld.id, unlocked: false, completed: false };
                    storyProgress.push(legendaryProgress); // AJOUTER à storyProgress si nouveau
                }

                // Déverrouiller le niveau légendaire si le monde est terminé et qu'il n'est pas déjà déverrouillé
                if (worldCompleted && !legendaryProgress.unlocked) {
                    legendaryProgress.unlocked = true;
                }

                const isDisabled = !legendaryProgress.unlocked;
                const buttonText = `${legendaryLevelForWorld.name} ${legendaryProgress.completed ? '(Terminé)' : ''}`;

                const levelDiv = document.createElement('div');
                levelDiv.className = 'mb-6';
                levelDiv.innerHTML = `
                    <h3 class="text-xl text-white font-bold mb-2">${worldName} - Défi Légendaire</h3>
                    <div class="grid gap-4">
                        <button class="bg-yellow-600 hover:bg-yellow-700 text-white py-2 px-4 rounded-lg ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}"
                                onclick="startLevel(${legendaryLevelForWorld.id})" ${isDisabled ? 'disabled' : ''}>
                            ${buttonText}
                        </button>
                        ${isDisabled && !worldCompleted ? `<p class="text-sm text-gray-400">Terminez tous les niveaux du monde "${worldName}" pour débloquer ce défi.</p>` : ''}
                        ${isDisabled && worldCompleted && !legendaryProgress.unlocked ? `<p class="text-sm text-gray-400">Défi verrouillé. Le monde "${worldName}" est terminé mais le défi n'est pas encore débloqué.</p>` : ''}
                         ${!worldCompleted && legendaryProgress.unlocked ? `<p class="text-sm text-yellow-300">Attention: Défi débloqué mais le monde "${worldName}" n'est pas complet. (Vérifier logique)</p>` : ''}
                    </div>
                `;
                legendeLevelListElement.appendChild(levelDiv);
                foundLegendaryLevel = true;
            }
        });

        if (!foundLegendaryLevel) {
             legendeLevelListElement.innerHTML = "<p class='text-white'>Aucun défi légendaire disponible pour le moment. Terminez des mondes pour les déverrouiller !</p>";
        }
        scheduleSave(); // Sauvegarder les changements de storyProgress (surtout les nouveaux déverrouillages)
    }

    function startLevel(id, useLastTeam = false) {
      console.log("startLevel appelé avec id:", id, "useLastTeam:", useLastTeam);
      const levelData = allGameLevels.find(lvl => lvl.id === id);
      if (!levelData) {
        console.log("Niveau introuvable, id:", id);
        return;
      }
      
      if (levelData.type !== 'challenge' && levelData.type !== 'minigame' && !storyProgress.find(sp => sp.id === id)?.unlocked) {
          console.log("Niveau non déverrouillé, id:", id);
          return;
      }

      currentLevelId = id;
      selectedBattleCharacters.clear();

      let teamReady = false;
      let loadedTeam = [];

      if (useLastTeam && lastUsedBattleTeamIds && lastUsedBattleTeamIds.length > 0) {
        const validLastTeam = lastUsedBattleTeamIds.every(charId => ownedCharacters.find(c => c.id === charId));
        if (validLastTeam) {
            lastUsedBattleTeamIds.forEach(charId => {
                const index = ownedCharacters.findIndex(c => c.id === charId);
                if (index !== -1) selectedBattleCharacters.add(index);
            });

            const expectedSizeForThisTeam = calculateMaxTeamSize();
            if (selectedBattleCharacters.size === expectedSizeForThisTeam && selectedBattleCharacters.size === lastUsedBattleTeamIds.length) {
                teamReady = true;
                loadedTeam = Array.from(selectedBattleCharacters).map(index => ownedCharacters[index]);
                console.log("Utilisation de la dernière équipe pour enchaîner:", loadedTeam.map(c => c.name));
            } else {
                selectedBattleCharacters.clear();
            }
        }
      }
      
      if (!teamReady && presetConfirmed && characterPreset && characterPreset.length > 0) {
        const validPreset = characterPreset.every(pid => ownedCharacters.find(c => c.id === pid));
        if (validPreset) {
          characterPreset.forEach(pid => {
            const index = ownedCharacters.findIndex(c => c.id === pid);
            if (index !== -1) selectedBattleCharacters.add(index);
          });
          
          const expectedSizeForThisPresetTeam = calculateMaxTeamSize(); 
          if (selectedBattleCharacters.size === expectedSizeForThisPresetTeam && selectedBattleCharacters.size === characterPreset.length) { 
            teamReady = true;
            loadedTeam = Array.from(selectedBattleCharacters).map(index => ownedCharacters[index]);
            console.log("Utilisation du preset confirmé:", loadedTeam.map(c => c.name));
          } else {
            selectedBattleCharacters.clear();
            characterPreset = [];
            presetConfirmed = false;
            localStorage.setItem("characterPreset", JSON.stringify(characterPreset));
            localStorage.setItem("presetConfirmed", presetConfirmed.toString());
          }
        } else {
          characterPreset = [];
          presetConfirmed = false;
          localStorage.setItem("characterPreset", JSON.stringify(characterPreset));
          localStorage.setItem("presetConfirmed", presetConfirmed.toString());
        }
      }

      // AJOUT : Vérification du type de niveau pour router le gameplay
      if (levelData.type === 'minigame') {
        if (teamReady) {
            // Lance directement le mini-jeu si une équipe est prête
            launchMiniGame(levelData, loadedTeam);
        } else {
            // Ouvre la sélection d'équipe, `confirmSelection` gérera le lancement
            characterSelectionModal.classList.remove("hidden");
            enableNoScroll();
            updateCharacterSelectionDisplay();
        }
        return; // Fin de la fonction pour les mini-jeux
      }

      // Logique pour les niveaux normaux
      if (teamReady) {
        console.log("Équipe prête, lancement direct du combat pour le niveau:", levelData.name);
        confirmSelection();
      } else {
        console.log("Aucun preset valide ou dernière équipe, ouverture de la modale de sélection pour le niveau:", levelData.name);
        characterSelectionModal.classList.remove("hidden");
        enableNoScroll();
        updateCharacterSelectionDisplay();
      }
    }


    function startAutofuse() {
      console.log("startAutofuse appelé");
      if (ownedCharacters.length <= 1) {
        resultElement.innerHTML = '<p class="text-red-400">Pas assez de personnages pour autofusionner !</p>';
        return;
      }
      currentAutofuseCharacterId = null;
      autofuseSelectedRarities.clear();
      settingsModal.classList.add("hidden");
      autofuseModal.classList.remove("hidden");
      enableNoScroll();
      updateAutofuseDisplay();
    }

    function updateAutofuseDisplay() {
      // Afficher le personnage principal sélectionné
      let mainCharIsMaxLevel = false;
      if (currentAutofuseCharacterId) {
        const char = ownedCharacters.find(c => c.id === currentAutofuseCharacterId);
        if (char) {
          // MODIFIÉ: Utiliser maxLevelCap
          mainCharIsMaxLevel = char.level >= (char.maxLevelCap || 60);
          autofuseMainCharacterElement.innerHTML = `
            <div class="bg-gray-800 bg-opacity-50 p-4 rounded-lg border-2 ${getRarityBorderClass(char.rarity)}">
              <img src="${char.image}" alt="${char.name}" class="w-full h-32 object-cover rounded mb-2">
              <p class="${char.color} font-semibold">${char.name} (<span class="${char.rarity === 'Mythic' ? 'rainbow-text' : ''}">${char.rarity}</span>, Niv. ${char.level}${mainCharIsMaxLevel ? ` (Max: ${char.maxLevelCap || 60})` : ` / ${char.maxLevelCap || 60}`})</p>
              <p class="text-white">Puissance: ${char.power}</p>
              ${mainCharIsMaxLevel ? '<p class="text-red-400 font-bold mt-2">Niveau maximum atteint ! Ne peut pas recevoir d\'EXP.</p>' : ''}
            </div>
          `;
        }
      } else {
        autofuseMainCharacterElement.innerHTML = '<p class="text-gray-400">Aucun personnage sélectionné</p>';
      }

      // Afficher la grille des personnages disponibles pour être sélectionné comme principal
      autofuseCharacterGrid.innerHTML = ownedCharacters
        // MODIFIÉ: Utiliser maxLevelCap
        .filter(char => char.level < (char.maxLevelCap || 60))
        .sort((a, b) => b.power - a.power)
        .map(char => `
          <div class="bg-gray-800 bg-opacity-50 p-4 rounded-lg border-2 ${getRarityBorderClass(char.rarity)} cursor-pointer hover:bg-gray-700 ${currentAutofuseCharacterId === char.id ? 'border-green-500' : ''}" data-id="${char.id}">
            <img src="${char.image}" alt="${char.name}" class="w-full h-24 object-cover rounded mb-2">
            <p class="${char.color} font-semibold text-sm">${char.name} ${char.locked ? '🔒' : ''}</p>
            <p class="text-white text-xs"><span class="${char.rarity === 'Mythic' ? 'rainbow-text' : ''}">${char.rarity}</span>, Niv. ${char.level} / ${char.maxLevelCap || 60}</p>
          </div>
        `)
        .join("") || '<p class="text-gray-400 col-span-full">Aucun personnage éligible (niveau inférieur à son cap actuel) disponible.</p>';

      // Ajouter des écouteurs aux vignettes
      autofuseCharacterGrid.querySelectorAll("[data-id]").forEach(element => {
        element.addEventListener("click", () => {
          currentAutofuseCharacterId = element.dataset.id;
          updateAutofuseDisplay(); // Mettre à jour l'affichage après sélection
        });
      });

      // Mettre à jour l'état des cases à cocher
      Object.keys(autofuseRarityCheckboxes).forEach(rarity => {
        autofuseRarityCheckboxes[rarity].checked = autofuseSelectedRarities.has(rarity);
      });

      // Compter les personnages à fusionner (doivent être non verrouillés et différents du principal)
      const charactersToFuse = ownedCharacters.filter(c =>
          c.id !== currentAutofuseCharacterId &&
          !c.locked &&
          autofuseSelectedRarities.has(c.rarity)
      );
      autofuseCountElement.textContent = charactersToFuse.length;

      // Activer/désactiver le bouton Confirmer
      const disableConfirm = charactersToFuse.length === 0 || !currentAutofuseCharacterId || mainCharIsMaxLevel;
      confirmAutofuseButton.disabled = disableConfirm;
      confirmAutofuseButton.classList.toggle("opacity-50", disableConfirm);
      confirmAutofuseButton.classList.toggle("cursor-not-allowed", disableConfirm);
    }

    function selectAutofuseRarity(rarity, checked) {
      if (checked) {
        autofuseSelectedRarities.add(rarity);
      } else {
        autofuseSelectedRarities.delete(rarity);
      }
      updateAutofuseDisplay();
    }

    function cancelAutofuse() {
      console.log("cancelAutofuse appelé");
      autofuseSelectedRarities.clear();
      autofuseModal.classList.add("hidden");
      disableNoScroll();
    }

    function confirmAutofuse() {
        console.log("confirmAutofuse appelé");
        if (autofuseSelectedRarities.size === 0 || !currentAutofuseCharacterId) {
            console.log("Personnage principal ou raretés non sélectionnés");
            resultElement.innerHTML = '<p class="text-red-400">Veuillez sélectionner un personnage principal et au moins une rareté.</p>';
            return;
        }
        const mainChar = ownedCharacters.find(c => c.id === currentAutofuseCharacterId);
        if (!mainChar) {
            console.log("Personnage principal non trouvé, currentAutofuseCharacterId:", currentAutofuseCharacterId);
            resultElement.innerHTML = '<p class="text-red-400">Personnage principal non trouvé !</p>';
            autofuseModal.classList.add("hidden");
            document.body.classList.remove("no-scroll");
            return;
        }
        if (mainChar.level >= 100) {
            console.log("Personnage au niveau maximum");
            resultElement.innerHTML = '<p class="text-red-400">Ce personnage est déjà au niveau maximum (100) !</p>';
            autofuseModal.classList.add("hidden");
            document.body.classList.remove("no-scroll");
            return;
        }
        if (mainChar.level >= (mainChar.maxLevelCap || 60)) {
            resultElement.innerHTML = `<p class="text-red-400">Le personnage principal ${mainChar.name} est déjà à son niveau maximum actuel (${mainChar.maxLevelCap || 60}) et ne peut plus recevoir d'EXP. Choisissez un autre personnage ou augmentez son cap.</p>`;
            // Ne pas fermer la modale, laisser l'utilisateur choisir un autre personnage
            return;
        }

        const expByRarity = {
            Rare: 25,
            Épique: 50,
            Légendaire: 100,
            Mythic: 200,
            Secret: 300
        };
        let totalExpGained = 0;
        const fusionSummary = {};

        // --- CORRECTION ICI : Ajout de !c.locked ---
        const charactersToFuse = ownedCharacters.filter(c =>
            c.id !== currentAutofuseCharacterId &&
            !c.locked && // Ajout de la condition !c.locked
            autofuseSelectedRarities.has(c.rarity)
        );
        // --- FIN CORRECTION ---

        if (charactersToFuse.length === 0) {
            console.log("Aucun personnage non verrouillé disponible pour la fusion");
            resultElement.innerHTML = '<p class="text-red-400">Aucun personnage non verrouillé disponible pour la fusion avec les raretés sélectionnées.</p>';
            // Pas besoin de fermer la modale ici, l'utilisateur peut vouloir changer de rareté
            updateAutofuseDisplay(); // Met à jour l'affichage pour refléter 0 personnage à fusionner
            return;
        }

        const characterIdsToFuse = charactersToFuse.map(c => c.id); // Obtenir les IDs avant de modifier ownedCharacters

        charactersToFuse.forEach(char => {
            const expGained = expByRarity[char.rarity] || 25;
            totalExpGained += expGained;
            fusionSummary[char.rarity] = (fusionSummary[char.rarity] || 0) + 1;
        });

        addCharacterExp(mainChar, totalExpGained); // Ajouter l'EXP au personnage principal

        // Supprimer les personnages fusionnés en utilisant leurs IDs
        ownedCharacters = ownedCharacters.filter(c => !characterIdsToFuse.includes(c.id));

        addExp(totalExpGained); // Ajouter l'EXP au joueur

        const summaryText = Object.entries(fusionSummary)
            .map(([rarity, count]) => `${count} ${rarity} (+${count * expByRarity[rarity]} EXP)`)
            .join(", ");
        resultElement.innerHTML = `
        <p class="text-green-400">Multifusion réussie pour ${mainChar.name} !</p>
        <p class="text-white">${charactersToFuse.length} personnage(s) fusionné(s) (non verrouillés): ${summaryText}</p>
        <p class="text-white">Total +${totalExpGained} EXP gagné pour ${mainChar.name} et le joueur</p>
      `;
        autofuseSelectedRarities.clear(); // Réinitialiser les raretés sélectionnées
        autofuseModal.classList.add("hidden");
        disableNoScroll(); // Utiliser la fonction pour gérer le scroll et padding
        updateCharacterDisplay();
        // updateAutofuseCharacterGrid(); // Pas nécessaire car la modale est fermée
        updateUI();
        scheduleSave();
    }

    function addGems(amount) {
        gems = Math.min(gems + amount, 1000000000); // Limite à 10 000 gemmes
        updateUI(); // Met à jour l'affichage
        scheduleSave(); // Sauvegarde la progression
    }

    function openPullMethodModal(pullType) {
      console.log("openPullMethodModal appelé avec pullType:", pullType);
      currentPullType = pullType;
      pullMethodModal.classList.remove("hidden");
      document.body.classList.add("no-scroll");
      pullWithGemsButton.disabled = (pullType === "standard" && gems < 100) || (pullType === "special" && gems < 150);
      pullWithGemsButton.classList.toggle("opacity-50", pullWithGemsButton.disabled);
      pullWithGemsButton.classList.toggle("cursor-not-allowed", pullWithGemsButton.disabled);
      pullWithTicketButton.disabled = pullTickets === 0;
      pullWithTicketButton.classList.toggle("opacity-50", pullWithTicketButton.disabled);
      pullWithTicketButton.classList.toggle("cursor-not-allowed", pullWithTicketButton.disabled);
    }

    function cancelPullMethod() {
      console.log("cancelPullMethod appelé");
      pullMethodModal.classList.add("hidden");
      document.body.classList.remove("no-scroll");
      currentPullType = null;
    }


    function startInfiniteLevel(levelId) {
      if (ownedCharacters.length < 3) {
        resultElement.innerHTML = '<p class="text-red-400">Vous avez besoin d\'au moins 3 personnages pour commencer un combat !</p>';
        return;
      }
      selectedBattleCharacters.clear();
      currentLevelId = levelId;
      infiniteLevelStartTime = Date.now();
      updateCharacterSelectionDisplay();
      characterSelectionModal.classList.remove("hidden");
    }

    function openPresetSelectionModal() {
      console.log("openPresetSelectionModal appelé");
      selectedPresetCharacters.clear();
      presetSelectionModal.classList.remove("hidden");
      enableNoScroll();
      updatePresetSelectionDisplay();
    }

    function updatePresetSelectionDisplay() {
      presetSelectionList.innerHTML = "";
      const currentFunctionalMaxPresetTeamSize = calculateMaxPresetTeamSize(); // Calcul dynamique

      // Mettre à jour le titre de la modale de preset
      const presetModalTitle = document.getElementById("preset-selection-modal-title"); // S'assurer que l'ID est correct
      if (presetModalTitle) {
          presetModalTitle.textContent = `Sélectionner ${currentFunctionalMaxPresetTeamSize} Personnage(s) pour le Preset`;
      }

      const searchNameInputPreset = document.getElementById("preset-search-name");
      const filterRaritySelectPreset = document.getElementById("preset-filter-rarity");
      if (searchNameInputPreset) searchNameInputPreset.value = presetSearchName;
      if (filterRaritySelectPreset) filterRaritySelectPreset.value = presetFilterRarity;


      let charactersToDisplayForPreset = [...ownedCharacters];

      // Appliquer le filtre par nom (utilise la variable globale presetSearchName)
      if (presetSearchName) {
          charactersToDisplayForPreset = charactersToDisplayForPreset.filter(char => (char.name || "").toLowerCase().includes(presetSearchName));
      }

      // Appliquer le filtre par rareté (utilise la variable globale presetFilterRarity)
      if (presetFilterRarity !== "all") {
          charactersToDisplayForPreset = charactersToDisplayForPreset.filter(char => char.rarity === presetFilterRarity);
      }

      const sortedCharacters = charactersToDisplayForPreset.sort((a, b) => {
        if (presetSortCriteria === "power") { // Utilise bien presetSortCriteria
          return (b.power || 0) - (a.power || 0);
        } else if (presetSortCriteria === "rarity") { // Utilise bien presetSortCriteria
          const rarityAValue = rarityOrder[a.rarity] ?? -1;
          const rarityBValue = rarityOrder[b.rarity] ?? -1;
          return rarityBValue - rarityAValue;
        } else if (presetSortCriteria === "level") { // Utilise bien presetSortCriteria
          return (b.level || 0) - (a.level || 0);
        } else if (presetSortCriteria === "name") { // Ajout du tri par nom
          return (a.name || "").localeCompare(b.name || "");
        }
        return 0;
      });

      const selectedPresetCharacterNames = new Set();
      for (const selectedIdx of selectedPresetCharacters) {
          if(ownedCharacters[selectedIdx]) { // Vérifier que l'index est valide
              selectedPresetCharacterNames.add(ownedCharacters[selectedIdx].name);
          }
      }

      sortedCharacters.forEach((char) => {
        const originalIndex = ownedCharacters.findIndex(c => c.id === char.id);
        if (originalIndex === -1) return;

        const charElement = document.createElement("div");
        
        let isCurrentlySelectedInPreset = selectedPresetCharacters.has(originalIndex);
        let isSelectableForPreset = true;
        let additionalClassesPreset = "";

        // Si le personnage n'est pas sélectionné et qu'il y a de la place
        if (!isCurrentlySelectedInPreset && selectedPresetCharacters.size < currentFunctionalMaxPresetTeamSize) {
            if (selectedPresetCharacterNames.has(char.name)) {
                isSelectableForPreset = false;
                additionalClassesPreset = "non-selectable-for-battle";
            }
        } else if (!isCurrentlySelectedInPreset && selectedPresetCharacters.size >= currentFunctionalMaxPresetTeamSize) {
            isSelectableForPreset = false;
            additionalClassesPreset = "opacity-50";
        }


        let rarityTextClass = char.color;
        if (char.rarity === "Mythic") rarityTextClass = "rainbow-text";
        else if (char.rarity === "Secret") rarityTextClass = "text-secret";
        else if (char.rarity === "Vanguard") rarityTextClass = "text-vanguard";


        charElement.className = `bg-gray-800 bg-opacity-50 p-4 rounded-lg transition transform hover:scale-105 cursor-pointer border-2 ${getRarityBorderClass(char.rarity)} ${
            isCurrentlySelectedInPreset ? 'selected-for-battle' : ''
        } ${additionalClassesPreset}`;
        
        charElement.innerHTML = `
          <img src="${char.image}" alt="${char.name}" class="w-full h-32 object-contain rounded mb-2">
          <p class="${rarityTextClass} font-semibold">${char.name} (<span class="${rarityTextClass}">${char.rarity}</span>, Niv. ${char.level})</p>
          <p class="text-white">Puissance: ${char.power}</p>
        `;
        
        if (isSelectableForPreset || isCurrentlySelectedInPreset) {
            charElement.addEventListener("click", () => {
                selectPresetCharacter(originalIndex);
            });
        }
        presetSelectionList.appendChild(charElement);
      });

      // Mettre à jour l'élément d'affichage du compteur
      if (presetSelectedCountDisplayElement) { // Utilise la variable renommée
        presetSelectedCountDisplayElement.textContent = `${selectedPresetCharacters.size}/${currentFunctionalMaxPresetTeamSize}`;
      }
      
      confirmPresetButton.disabled = selectedPresetCharacters.size !== currentFunctionalMaxPresetTeamSize;
      confirmPresetButton.classList.toggle("opacity-50", selectedPresetCharacters.size !== currentFunctionalMaxPresetTeamSize);
      confirmPresetButton.classList.toggle("cursor-not-allowed", selectedPresetCharacters.size !== currentFunctionalMaxPresetTeamSize);
      document.getElementById("preset-sort-criteria").value = presetSortCriteria;
    }

    function selectPresetCharacter(index) {
      const characterToAdd = ownedCharacters[index];

      if (selectedPresetCharacters.has(index)) {
          selectedPresetCharacters.delete(index);
      } else {
          // Recalculer la taille max *potentielle* si ce personnage était ajouté (pour le preset)
          let potentialSelectedForPreset = new Set(selectedPresetCharacters);
          potentialSelectedForPreset.add(index);
          let potentialMaxTeamSizeForPreset = 3;
          let potentialBonusForPreset = 0;
          potentialSelectedForPreset.forEach(idx => {
              const char = ownedCharacters[idx];
              if (char && char.passive && typeof char.passive.teamSizeBonus === 'number') {
                  potentialBonusForPreset = Math.max(potentialBonusForPreset, char.passive.teamSizeBonus);
              }
          });
          potentialMaxTeamSizeForPreset += potentialBonusForPreset;

          if (selectedPresetCharacters.size < potentialMaxTeamSizeForPreset) { // MODIFIÉ: Utilise la taille potentielle
              let alreadySelectedSameNameInPreset = false;
              for (const selectedIndex of selectedPresetCharacters) {
                  if (ownedCharacters[selectedIndex].name === characterToAdd.name) {
                      alreadySelectedSameNameInPreset = true;
                      break;
                  }
              }
              if (!alreadySelectedSameNameInPreset) {
                  selectedPresetCharacters.add(index);
              } else {
                  console.log(`Preset: Personnage ${characterToAdd.name} (ou un autre du même nom) déjà sélectionné pour ce preset.`);
              }
          }
      }
      updatePresetSelectionDisplay(); // Ceci va recalculer et réafficher avec la bonne taille max
    }

    function confirmPreset() {
      console.log("confirmPreset appelé");
      const currentMaxPresetTeamSize = calculateMaxPresetTeamSize(); // MODIFIÉ: Utilise la taille dynamique

      if (selectedPresetCharacters.size !== currentMaxPresetTeamSize) { // MODIFIÉ: Utilise la taille dynamique
        resultElement.innerHTML = `<p class="text-red-400">Veuillez sélectionner exactement ${currentMaxPresetTeamSize} personnage(s) !</p>`;
        return;
      }
      characterPreset = Array.from(selectedPresetCharacters).map(index => ownedCharacters[index].id);
      presetConfirmed = true;
      localStorage.setItem("characterPreset", JSON.stringify(characterPreset));
      localStorage.setItem("presetConfirmed", presetConfirmed);
      resultElement.innerHTML = '<p class="text-green-400">Preset enregistré avec succès !</p>';
      selectedPresetCharacters.clear();
      presetSelectionModal.classList.add("hidden");
      disableNoScroll();
      updateCharacterDisplay();
    }


    function cancelPreset() {
      console.log("cancelPreset appelé");
      selectedPresetCharacters.clear();
      presetSelectionModal.classList.add("hidden");
      disableNoScroll();
      updateCharacterDisplay();
    }

    function loadPreset() {
      console.log("loadPreset appelé, characterPreset:", characterPreset);
      if (characterPreset.length !== 3) {
        resultElement.innerHTML = '<p class="text-red-400">Aucun preset valide enregistré ou le preset n\'est pas complet !</p>';
        return;
      }
      const validPresetOwnership = characterPreset.every(id => ownedCharacters.find(c => c.id === id));
      if (!validPresetOwnership) {
        resultElement.innerHTML = '<p class="text-red-400">Le preset contient des personnages non possédés ! Il sera vidé.</p>';
        characterPreset = [];
        presetConfirmed = false;
        localStorage.setItem("characterPreset", JSON.stringify(characterPreset));
        localStorage.setItem("presetConfirmed", presetConfirmed);
        selectedBattleCharacters.clear(); // Vider la sélection si le preset est invalide
        updateCharacterSelectionDisplay();
        return;
      }

      selectedBattleCharacters.clear(); // Vider la sélection actuelle avant de charger
      const tempSelectedNamesFromPreset = new Set(); // Pour suivre les noms ajoutés depuis le preset

      for (const charOwnedId of characterPreset) {
          const index = ownedCharacters.findIndex(c => c.id === charOwnedId);
          if (index !== -1) {
              const characterToLoad = ownedCharacters[index];
              if (!tempSelectedNamesFromPreset.has(characterToLoad.name)) {
                  if (selectedBattleCharacters.size < 3) { // S'assurer qu'on n'ajoute pas plus de 3
                      selectedBattleCharacters.add(index);
                      tempSelectedNamesFromPreset.add(characterToLoad.name);
                  }
              } else {
                  console.warn(`Preset: Le personnage ${characterToLoad.name} (ID: ${charOwnedId}) est un doublon par nom dans le preset et a été ignoré lors du chargement.`);
              }
          }
      }
      
      if (selectedBattleCharacters.size < 3) {
          resultElement.innerHTML = '<p class="text-yellow-400">Le preset a été chargé, mais contenait des doublons. Veuillez compléter votre équipe.</p>';
          // Le bouton "Confirmer" sera désactivé par updateCharacterSelectionDisplay si la taille n'est pas 3.
      } else {
          // Si tout s'est bien passé et que 3 personnages uniques ont été chargés.
           resultElement.innerHTML = '<p class="text-green-400">Preset chargé !</p>';
           setTimeout(() => {
                if (resultElement.innerHTML.includes("Preset chargé !")) {
                    resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`;
                }
           }, 3000);
      }

      updateCharacterSelectionDisplay(); // Met à jour l'affichage avec les personnages chargés
    }

    function updateIndexDisplay() {
        if (!allCharacters) {
            console.error("allCharacters n'est pas défini");
            indexDisplay.innerHTML = '<p class="text-red-400">Erreur : Liste des personnages non disponible.</p>';
            return;
        }

        // Trier les personnages par rareté
        const sortedCharacters = [...allCharacters].sort((a, b) => {
            return rarityOrder[a.rarity] - rarityOrder[b.rarity];
        });

        indexDisplay.innerHTML = sortedCharacters.map(char => {
            const isDiscovered = discoveredCharacters.includes(char.name);
            return `
            <div class="relative p-2 rounded-lg border ${isDiscovered ? getRarityBorderClass(char.rarity) : 'unowned-character'}">
                <img src="${char.image}" alt="${char.name}" class="w-full h-32 object-cover rounded">
                <p class="text-center text-white font-semibold mt-2">${isDiscovered ? char.name : '???'}</p>
                <p class="text-center ${isDiscovered ? (char.rarity === 'Mythic' ? 'rainbow-text' : char.color) : 'text-gray-400'}">${isDiscovered ? char.rarity : 'Inconnu'}</p>
            </div>
            `;
        }).join("");
    }

    let autosellSettings = JSON.parse(localStorage.getItem("autosellSettings")) || {
      Rare: false,
      Épique: false,
      Légendaire: false,
      Mythic: false,
      Secret: false
    };

    function autoSellCharacter(char) {
      const gemValue = char.rarity === "Rare" ? 10 : char.rarity === "Épique" ? 50 : char.rarity === "Légendaire" ? 100 : char.rarity === "Mythic" ? 500 : 1000;
      const coinValue = char.rarity === "Rare" ? 5 : char.rarity === "Épique" ? 15 : char.rarity === "Légendaire" ? 30 : char.rarity === "Mythic" ? 100 : 200;
      
      addGems(gemValue);
      coins = Math.min(coins + coinValue, 10000000);
      
      missions.forEach(mission => {
        if (!mission.completed) {
          if (mission.type === "sell_chars") mission.progress++;
          if (mission.type === "sell_rare_chars" && char.rarity === "Rare") mission.progress++;
        }
      });
      checkMissions();
      return { gems: gemValue, coins: coinValue };
    }

    async function confirmSelection() {
        const currentMaxTeamSize = calculateMaxTeamSize();
        if (selectedBattleCharacters.size !== currentMaxTeamSize) {
            console.warn("Tentative de confirmation avec une sélection invalide. Taille attendue:", currentMaxTeamSize, "Taille actuelle:", selectedBattleCharacters.size);
            if (!characterSelectionModal.classList.contains("hidden")) {
                return;
            }
            characterSelectionModal.classList.remove("hidden");
            enableNoScroll();
            updateCharacterSelectionDisplay();
            return;
        }

        lastUsedBattleTeamIds = Array.from(selectedBattleCharacters).map(index => ownedCharacters[index].id);
        
        if (!characterSelectionModal.classList.contains("hidden")) {
            characterSelectionModal.classList.add("hidden");
            disableNoScroll();
        }

        const selectedCharsObjects = Array.from(selectedBattleCharacters).map(index => ownedCharacters[index]);
        const levelData = allGameLevels.find(l => l.id === currentLevelId);
        
        // AJOUT : Aiguillage vers le mini-jeu si le type de niveau correspond
        if (levelData && levelData.type === 'minigame') {
            launchMiniGame(levelData, selectedCharsObjects);
            return; // Important : arrête l'exécution pour ne pas lancer le combat automatique
        }

        let progress = storyProgress.find(p => p.id === currentLevelId);
        if (!progress && levelData && levelData.type === 'challenge') {
            progress = { id: currentLevelId, unlocked: true, completed: false };
            storyProgress.push(progress);
        }

        if (!levelData || !progress) {
            console.error("Données de niveau ou de progression introuvables dans confirmSelection. Level ID:", currentLevelId);
            resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`;
            return;
        }
        
        if (selectedCharsObjects.some(char => char === undefined)) {
            console.error("Un ou plusieurs personnages sélectionnés sont undefined. Indices:", Array.from(selectedBattleCharacters), "OwnedChars:", ownedCharacters.length);
            selectedBattleCharacters.clear();
            lastUsedBattleTeamIds = [];
            characterSelectionModal.classList.remove("hidden");
            enableNoScroll();
            updateCharacterSelectionDisplay();
            resultElement.innerHTML = '<p class="text-red-500">Erreur de sélection d\'équipe. Veuillez réessayer.</p>';
            return;
        }

        resultElement.innerHTML = `<p class="text-white">${levelData.isInfinite ? 'Plongée dans l\'Abîme Infini...' : 'Combat en cours contre ' + levelData.enemy.name + '...'}</p>`;
        if (animationsEnabled) {
            resultElement.classList.add("animate-pulse");
        }
        if (soundEnabled) battleSound.play();
        await new Promise(resolve => setTimeout(resolve, 1500));
        resultElement.classList.remove("animate-pulse");

        let playerPower = 0;
        selectedCharsObjects.forEach(char => {
            let battlePower = char.power;
            if (char.trait && char.trait.id && char.trait.grade > 0) {
                const traitDef = TRAIT_DEFINITIONS[char.trait.id];
                if (traitDef && traitDef.grades) {
                    const gradeDef = traitDef.grades.find(g => g.grade === char.trait.grade);
                    if (gradeDef) {
                        if (levelData.isInfinite && typeof gradeDef.powerMultiplierInfinite === 'number') {
                            battlePower *= (1 + gradeDef.powerMultiplierInfinite);
                        } else if (levelData.type === 'legendary' && typeof gradeDef.powerMultiplierLegend === 'number') {
                            battlePower *= (1 + gradeDef.powerMultiplierLegend);
                        } else if (levelData.type === 'challenge' && typeof gradeDef.powerMultiplierChallenge === 'number') {
                            battlePower *= (1 + gradeDef.powerMultiplierChallenge);
                        }
                    }
                }
            }
            playerPower += Math.floor(battlePower);
        });

        const enemyPower = levelData.enemy.power;
        const playerScore = playerPower * (1 + (Math.random() * 0.1));
        const enemyScore = enemyPower * (1 + (Math.random() * 0.1));

        let battleOutcomeMessage = "";

        if (levelData.isInfinite) {
            // Logique pour le niveau infini... (inchangée)
            const timeSurvived = Math.floor((Date.now() - infiniteLevelStartTime) / 1000);
            const baseGemsEarnedInfinite = Math.floor(timeSurvived / 60) * levelData.rewards.gemsPerMinute;
            let golderBonusGemsInfinite = 0;
            let golderMessagePartInfinite = "";

            selectedCharsObjects.forEach(char => {
                if (char.trait && char.trait.id === 'golder' && char.trait.grade > 0) {
                    const traitDef = TRAIT_DEFINITIONS['golder'];
                    const gradeDef = traitDef.grades.find(g => g.grade === char.trait.grade);
                    if (gradeDef && typeof gradeDef.gemBonusPercentageAllModes === 'number') {
                        golderBonusGemsInfinite += Math.floor(baseGemsEarnedInfinite * gradeDef.gemBonusPercentageAllModes);
                    }
                }
            });
            const totalGemsEarnedInfinite = baseGemsEarnedInfinite + golderBonusGemsInfinite;
            if (golderBonusGemsInfinite > 0) {
                golderMessagePartInfinite = ` (dont +${golderBonusGemsInfinite} grâce au trait Golder)`;
            }

            gems = Math.min(gems + totalGemsEarnedInfinite, 10000000);

            const expEarned = Math.floor(timeSurvived / 10);
            addExp(expEarned);
            selectedCharsObjects.forEach(char => {
                addCharacterExp(char, expEarned);
            });
            battleOutcomeMessage = `
                <p class="text-green-400 text-2xl font-bold mb-2">Survie Réussie !</p>
                <p class="text-white">Vous avez survécu ${timeSurvived} secondes dans l'Abîme Infini !</p>
                <p class="text-white">Récompenses: +${totalGemsEarnedInfinite} gemmes${golderMessagePartInfinite}, +${expEarned} EXP</p>`;
            if (animationsEnabled) confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
            infiniteLevelStartTime = null;

        } else {
            // Logique pour les niveaux normaux... (inchangée)
            if (playerScore > enemyScore) { 
                // Logique de VICTOIRE (inchangée)
                 let itemRewardText = '';

                if (levelData.type === "story" && !levelData.isInfinite) {
                    const storyWorldNames = [...new Set(baseStoryLevels.filter(l => l.type === 'story' && !l.isInfinite).map(l => ({world: l.world, firstId: Math.min(...baseStoryLevels.filter(sl => sl.world === l.world && sl.type === 'story' && !sl.isInfinite).map(sl => sl.id))})).sort((a, b) => a.firstId - b.firstId).map(w => w.world))];
                    const worldArrayIndex = storyWorldNames.indexOf(levelData.world);
                    const worldNumberForReward = worldArrayIndex !== -1 ? worldArrayIndex + 1 : null;

                    if (worldNumberForReward) {
                        const worldRewardDef = worldRewards.find(wr => wr.world === worldNumberForReward);
                        if (worldRewardDef && worldRewardDef.item) {
                            const itemQuantityStory = Math.floor(Math.random() * (worldRewardDef.maxQuantity - worldRewardDef.minQuantity + 1)) + worldRewardDef.minQuantity;
                            inventory[worldRewardDef.item] = (inventory[worldRewardDef.item] || 0) + itemQuantityStory;
                            itemRewardText += `${itemRewardText ? ', ' : ''}+${itemQuantityStory} ${worldRewardDef.item}`;
                        }
                    }
                }
                
                if ((levelData.type === "legendary" || levelData.type === "challenge" || levelData.type === "material") && levelData.rewards.itemChance) {
                    const chancesArray = Array.isArray(levelData.rewards.itemChance) ? levelData.rewards.itemChance : [levelData.rewards.itemChance];
                    chancesArray.forEach(chanceDef => {
                        if (chanceDef.item && typeof chanceDef.minQuantity === 'number' && typeof chanceDef.maxQuantity === 'number' && typeof chanceDef.probability === 'number') {
                            let finalDropProbability = chanceDef.probability;
                            let looterEffectAppliedToProbThisItem = false;
                            selectedCharsObjects.forEach(char => {
                                if (char.trait && char.trait.id === 'looter' && char.trait.grade > 0) {
                                    const traitDefLooter = TRAIT_DEFINITIONS['looter'];
                                    if (traitDefLooter) {
                                        const gradeDefLooter = traitDefLooter.grades.find(g => g.grade === char.trait.grade);
                                        if (gradeDefLooter && typeof gradeDefLooter.itemDropRateStoryBonusPercentage === 'number') {
                                            if (chanceDef.probability < 1.0) {
                                                const increasedProbability = chanceDef.probability * (1 + gradeDefLooter.itemDropRateStoryBonusPercentage);
                                                if (increasedProbability > finalDropProbability) {
                                                    finalDropProbability = Math.min(increasedProbability, 1.0);
                                                }
                                                if (finalDropProbability > chanceDef.probability) looterEffectAppliedToProbThisItem = true;
                                            }
                                        }
                                    }
                                }
                            });
                            if (Math.random() < finalDropProbability) {
                                const itemQuantity = Math.floor(Math.random() * (chanceDef.maxQuantity - chanceDef.minQuantity + 1)) + chanceDef.minQuantity;
                                inventory[chanceDef.item] = (inventory[chanceDef.item] || 0) + itemQuantity;
                                itemRewardText += `${itemRewardText ? ', ' : ''}+${itemQuantity} ${chanceDef.item}`;
                                if (looterEffectAppliedToProbThisItem) itemRewardText += ` (Looter actif)`;
                            }
                        }
                    });
                }

                let baseGemsRewardForLevel = levelData.rewards.gems;
                let baseCoinsRewardForLevel = levelData.rewards.coins;
                const expReward = levelData.rewards.exp;

                let gemsRewardToPlayer = baseGemsRewardForLevel;
                if (levelData.type !== 'challenge' && progress.completed) gemsRewardToPlayer = Math.floor(baseGemsRewardForLevel * 0.5);

                let fortuneBonusGems = 0, golderBonusGems = 0, golderBonusCoins = 0;
                selectedCharsObjects.forEach(char => {
                    if (char.trait && char.trait.id && char.trait.grade > 0) {
                        const traitDef = TRAIT_DEFINITIONS[char.trait.id];
                        const gradeDef = traitDef.grades.find(g => g.grade === char.trait.grade);
                        if (gradeDef) {
                            if (levelData.type === 'story' && char.trait.id === 'fortune' && typeof gradeDef.gemBonusPercentage === 'number') fortuneBonusGems += Math.floor(baseGemsRewardForLevel * gradeDef.gemBonusPercentage);
                            if (char.trait.id === 'golder') {
                                if (typeof gradeDef.gemBonusPercentageAllModes === 'number') golderBonusGems += Math.floor(baseGemsRewardForLevel * gradeDef.gemBonusPercentageAllModes);
                                if (typeof gradeDef.coinBonusPercentageAllModes === 'number') golderBonusCoins += Math.floor(baseCoinsRewardForLevel * gradeDef.coinBonusPercentageAllModes);
                            }
                        }
                    }
                });

                let fortuneMessagePart = fortuneBonusGems > 0 ? ` +${fortuneBonusGems} Gemmes` : "";
                let golderGemsMessagePart = golderBonusGems > 0 ? ` +${golderBonusGems} Gemmes` : "";
                let golderCoinsMessagePart = golderBonusCoins > 0 ? ` +${golderBonusCoins} Pièces` : "";
                addGems(gemsRewardToPlayer + fortuneBonusGems + golderBonusGems);
                coins = Math.min(coins + baseCoinsRewardForLevel + golderBonusCoins, 10000000);
                addExp(expReward);
                selectedCharsObjects.forEach(char => addCharacterExp(char, expReward));

                battleOutcomeMessage = `<p class="text-green-400 text-2xl font-bold mb-2">Victoire !</p><p class="text-white">Victoire contre ${levelData.enemy.name} !</p><p class="text-white">Récompenses: +${gemsRewardToPlayer} gemmes${(levelData.type !== 'challenge' && progress.completed && gemsRewardToPlayer !== baseGemsRewardForLevel) ? ' (réduit)' : ''}${fortuneMessagePart}${golderGemsMessagePart}, +${baseCoinsRewardForLevel} pièces${golderCoinsMessagePart}, +${expReward} EXP ${itemRewardText ? ', ' + itemRewardText : ''}</p>`;

                missions.forEach(mission => {
                    if (!mission.completed) {
                        if (levelData.type === 'story' && mission.type === 'complete_story_levels') mission.progress++;
                        else if (levelData.type === 'legendary' && mission.type === 'complete_legendary_levels') mission.progress++;
                        else if (levelData.type === 'challenge' && mission.type === 'complete_challenge_levels') mission.progress++;
                    }
                });
                if (!progress.completed) progress.completed = true;

                if (levelData.type === 'story' && !levelData.isInfinite) {
                    const nextSequentialLevelId = levelData.id + 1;
                    const nextSequentialLevelData = allGameLevels.find(l => l.id === nextSequentialLevelId);
                    if (nextSequentialLevelData) {
                        const nextSequentialLevelProgress = storyProgress.find(p => p.id === nextSequentialLevelId);
                        if (nextSequentialLevelProgress && nextSequentialLevelData.type === 'story' && !nextSequentialLevelData.isInfinite && nextSequentialLevelData.world === levelData.world && !nextSequentialLevelProgress.unlocked) {
                            nextSequentialLevelProgress.unlocked = true;
                            battleOutcomeMessage += `<p class="text-white mt-1">${nextSequentialLevelData.name} déverrouillé !</p>`;
                        }
                    }
                    const currentWorldStoryLevels = baseStoryLevels.filter(l => l.world === levelData.world && l.type === 'story' && !l.isInfinite);
                    if (currentWorldStoryLevels.length > 0) {
                        const maxIdInCurrentWorld = Math.max(...currentWorldStoryLevels.map(l => l.id));
                        if (levelData.id === maxIdInCurrentWorld) {
                            const storyWorldNames = [...new Set(baseStoryLevels.filter(l => l.type === 'story' && !l.isInfinite).map(l => ({ world: l.world, firstId: Math.min(...baseStoryLevels.filter(sl => sl.world === l.world && sl.type === 'story' && !sl.isInfinite).map(sl => sl.id)) })).sort((a, b) => a.firstId - b.firstId).map(w => w.world))];
                            const currentWorldIndexInList = storyWorldNames.indexOf(levelData.world);
                            if (currentWorldIndexInList !== -1 && currentWorldIndexInList < storyWorldNames.length - 1) {
                                const nextWorldNameInList = storyWorldNames[currentWorldIndexInList + 1];
                                const levelsInNextWorld = baseStoryLevels.filter(l => l.world === nextWorldNameInList && l.type === 'story' && !l.isInfinite);
                                if (levelsInNextWorld.length > 0) {
                                    const firstLevelOfNextWorldId = Math.min(...levelsInNextWorld.map(l => l.id));
                                    const firstLevelOfNextWorldData = levelsInNextWorld.find(l => l.id === firstLevelOfNextWorldId);
                                    if (firstLevelOfNextWorldData) {
                                        const firstLevelOfNextWorldProgress = storyProgress.find(p => p.id === firstLevelOfNextWorldData.id);
                                        if (firstLevelOfNextWorldProgress && !firstLevelOfNextWorldProgress.unlocked) {
                                            firstLevelOfNextWorldProgress.unlocked = true;
                                            battleOutcomeMessage += `<p class="text-white mt-1">Nouveau monde déverrouillé: ${firstLevelOfNextWorldData.name} !</p>`;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    const infiniteLevelIdToCheck = 49;
                    const infiniteLvlProgress = storyProgress.find(p => p.id === infiniteLevelIdToCheck);
                    const infiniteLvlDef = allGameLevels.find(l => l.id === infiniteLevelIdToCheck && l.isInfinite);
                    if (infiniteLvlProgress && infiniteLvlDef && !infiniteLvlProgress.unlocked) {
                        const allStandardStoryLevels = baseStoryLevels.filter(lvl => lvl.type === 'story' && !lvl.isInfinite);
                        const allStandardStoryLevelsNowCompleted = allStandardStoryLevels.every(stdLvl => {
                            const prog = storyProgress.find(p => p.id === stdLvl.id);
                            return prog && prog.completed;
                        });
                        if (allStandardStoryLevelsNowCompleted) {
                            infiniteLvlProgress.unlocked = true;
                            battleOutcomeMessage += `<p class="text-white mt-1 font-bold text-yellow-300">${infiniteLvlDef.name} déverrouillé ! Tous les mondes d'histoire ont été conquis !</p>`;
                            if (animationsEnabled) setTimeout(() => confetti({ particleCount: 200, spread: 120, origin: { y: 0.4 }, angle: 90, scalar: 1.5, colors: ['#FFD700', '#FF8C00', '#FFA500'] }), 500);
                        }
                    }
                }
                if (soundEnabled) winSound.play();
                if (animationsEnabled) confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });
                localStorage.setItem("inventory", JSON.stringify(inventory));
            } else { 
                // Logique de DÉFAITE (inchangée)
                battleOutcomeMessage = `<p class="text-red-400 text-2xl font-bold mb-2">Défaite !</p><p class="text-white">Défaite contre ${levelData.enemy.name} ! Votre puissance: ${playerPower.toFixed(0)} (Score: ${playerScore.toFixed(0)}), Ennemi: ${enemyPower.toFixed(0)} (Score: ${enemyScore.toFixed(0)})</p><p class="text-white">Mieux vous préparer et réessayez !</p>`;
                selectedCharsObjects.forEach(char => addCharacterExp(char, Math.floor(levelData.rewards.exp / 4)));
                if (soundEnabled) loseSound.play();
            }
        }

        resultElement.innerHTML = battleOutcomeMessage;
        setTimeout(() => {
            const currentResultHTML = resultElement.innerHTML;
            if (currentResultHTML.includes("Victoire !") || currentResultHTML.includes("Défaite !") || currentResultHTML.includes("Survie Réussie !")) {
                resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`;
            }
        }, 7000);

        selectedBattleCharacters.clear();
        updateLevelDisplay();
        updateLegendeDisplay();
        updateChallengeDisplay();
        updateCharacterDisplay();
        updateIndexDisplay();
        updateUI();
        updateItemDisplay();
        saveProgress();
    }

    function updateChallengeDisplay() {
        const challengeLevelListElement = document.getElementById("challenge-level-list");
        if (!challengeLevelListElement) return;

        challengeLevelListElement.innerHTML = ""; // Vider le contenu précédent

        if (challengeLevels.length === 0) {
            challengeLevelListElement.innerHTML = "<p class='text-white'>Aucun défi disponible pour le moment.</p>";
            return;
        }
        
        challengeLevels.forEach(level => {
            const progress = storyProgress.find(p => p.id === level.id) || { unlocked: true, completed: false };
            if (!storyProgress.find(p => p.id === level.id)) {
                storyProgress.push({ id: level.id, unlocked: true, completed: false });
            }

            const isDisabled = !progress.unlocked;
            const buttonText = `${level.name} ${progress.completed ? '(Terminé)' : ''}`;
            
            // Logique pour déterminer le style du bouton
            let buttonClass = 'bg-purple-600 hover:bg-purple-700'; // Style par défaut pour les challenges normaux
            if(level.type === 'minigame') {
                buttonClass = 'bg-red-600 hover:bg-red-700 border-2 border-yellow-400'; // Style spécial pour le mini-jeu
            }

            let itemDropText = '';
            if (level.rewards.itemChance) {
                const chancesArray = Array.isArray(level.rewards.itemChance) ? level.rewards.itemChance : [level.rewards.itemChance];
                const dropNames = chancesArray.map(chanceDef => {
                    if (chanceDef && chanceDef.item) {
                        return `${chanceDef.item} (${(chanceDef.probability * 100).toFixed(2)}%)`;
                    }
                    return '';
                }).filter(Boolean).join(', ');

                if (dropNames) {
                    itemDropText = `<p>Drop Spécial: ${dropNames}</p>`;
                }
            }

            const levelDiv = document.createElement('div');
            levelDiv.className = 'mb-6';
            levelDiv.innerHTML = `
                <h3 class="text-xl text-white font-bold mb-2">${level.world}</h3>
                <div class="grid gap-2">
                    <button class="${buttonClass} text-white py-2 px-4 rounded-lg transition-colors duration-200 ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}"
                            onclick="startLevel(${level.id})" ${isDisabled ? 'disabled' : ''}>
                        ${buttonText}
                    </button>
                    <div class="text-xs text-gray-300 px-2">
                      <p>Ennemi: ${level.enemy.name} (Vie: ${level.enemy.power.toLocaleString()})</p>
                      <p>Récompenses: ${level.rewards.gems}G, ${level.rewards.coins}P, ${level.rewards.exp}EXP</p>
                      ${itemDropText}
                    </div>
                </div>
            `;
            challengeLevelListElement.appendChild(levelDiv);
        });

        scheduleSave();
    }

    function addCharacterExp(character, amount) {
      const currentCharacterMaxLevel = character.maxLevelCap || 60; // Utiliser le cap actuel du personnage

      if (character.level >= currentCharacterMaxLevel) { // Vérifier par rapport au cap actuel
        character.exp = 0; // Si déjà au cap, s'assurer que l'exp est à 0
        return;
      }

      character.exp += Math.floor(amount * expMultiplier);
      let leveledUp = false;
      let expNeeded = getExpNeededForCharacterLevel(character.level, character.rarity);

      while (character.exp >= expNeeded && character.level < currentCharacterMaxLevel) { // Boucler tant qu'on est sous le cap actuel
        const currentStatModifier = character.statModifier || (statRanks[character.statRank]?.modifier || 1.0);
        const powerFromBaseAndStatRankBeforeLevelUp = character.basePower * currentStatModifier;
        const currentCurseEffectValue = character.curseEffect || 0;
        let curseRatioRelativeToBaseAndStatRank = 0;
        if (powerFromBaseAndStatRankBeforeLevelUp !== 0 && currentCurseEffectValue !== 0) {
            curseRatioRelativeToBaseAndStatRank = currentCurseEffectValue / powerFromBaseAndStatRankBeforeLevelUp;
        }

        character.exp -= expNeeded;
        character.level++;
        leveledUp = true;

        let powerIncreaseBase = 15;
        let powerIncreasePerRarity = 5;
        let rarityFactor = rarityOrder[character.rarity] || 1;
        const levelUpPowerGain = powerIncreaseBase + (rarityFactor * powerIncreasePerRarity);

        character.basePower += levelUpPowerGain;

        if (curseRatioRelativeToBaseAndStatRank !== 0) {
            const newPowerFromBaseAndStatRankAfterLevelUp = character.basePower * currentStatModifier;
            character.curseEffect = Math.round(newPowerFromBaseAndStatRankAfterLevelUp * curseRatioRelativeToBaseAndStatRank);
        }

        recalculateCharacterPower(character);

        if (character.level === currentCharacterMaxLevel) { // Si le cap actuel est atteint
          character.exp = 0;
          // Afficher un message plus générique car le cap peut être 60, 65, 70, etc.
          resultElement.innerHTML += `<p class="text-yellow-400">${character.name} a atteint le Niveau ${character.level} (Cap Actuel) !</p>`;
          break;
        }
        expNeeded = getExpNeededForCharacterLevel(character.level, character.rarity);
      }

      if (character.level < currentCharacterMaxLevel) { // Si toujours sous le cap actuel
          const currentExpNeededForDisplay = getExpNeededForCharacterLevel(character.level, character.rarity);
          if (character.exp >= currentExpNeededForDisplay) {
              character.exp = currentExpNeededForDisplay - 1;
          }
      } else { // Si au cap actuel (ou au-dessus par erreur, ce qui ne devrait pas arriver avec la boucle `while`)
          character.exp = 0;
      }

      if (leveledUp && character.level < currentCharacterMaxLevel) { // Si level up mais pas encore au cap
        resultElement.innerHTML += `<p class="text-green-400">${character.name} a atteint le niveau ${character.level} !</p>`;
      }
      // Le message pour avoir atteint le cap est déjà géré dans la boucle while.
    }

    // Existing functions (unchanged, included for completeness)
    function applySettings() {
      console.log("applySettings appelé, autosellSettings:", autosellSettings);
      soundToggle.checked = soundEnabled;
      animationsToggle.checked = animationsEnabled;
      themeSelect.value = theme;
      document.getElementById("autosell-rare").checked = autosellSettings.Rare || false;
      document.getElementById("autosell-epic").checked = autosellSettings.Épique || false;
      document.getElementById("autosell-legendary").checked = autosellSettings.Légendaire || false;
      document.getElementById("autosell-mythic").checked = autosellSettings.Mythic || false;
      document.getElementById("autosell-secret").checked = autosellSettings.Secret || false;
      document.body.classList.remove("dark-theme", "light-theme");
      document.body.classList.add(`${theme}-theme`);

      if (tabCurseButton && curseElement) {
        tabCurseButton.classList.toggle("hidden", theme !== "dark");
        if (theme !== "dark") {
            document.body.classList.remove("curse-tab-active-bg"); // Retirer le fond spécial si on passe en thème clair
            if (!curseElement.classList.contains("hidden")) {
              showTab("play");
            }
        } else {
            // Si le thème est sombre ET l'onglet curse est celui qui est actuellement affiché (non hidden)
            // alors s'assurer que le fond spécial est appliqué.
            if (!curseElement.classList.contains("hidden")) {
                document.body.classList.add("curse-tab-active-bg");
            } else {
                // Si le thème est sombre mais l'onglet curse n'est PAS actif, s'assurer que le fond spécial est retiré.
                // Ceci est utile si on change de thème vers sombre alors qu'on n'est pas sur l'onglet curse.
                document.body.classList.remove("curse-tab-active-bg");
            }
        }
      }
      console.log("Paramètres appliqués, checkboxes mises à jour");
    }
   

    function saveSettings() {
      console.log("saveSettings appelé");
      soundEnabled = soundToggle.checked;
      animationsEnabled = animationsToggle.checked;
      theme = themeSelect.value;
      autosellSettings = {
        Rare: document.getElementById("autosell-rare").checked,
        Épique: document.getElementById("autosell-epic").checked,
        Légendaire: document.getElementById("autosell-legendary").checked,
        Mythic: document.getElementById("autosell-mythic").checked,
        Secret: document.getElementById("autosell-secret").checked
      };
      localStorage.setItem("soundEnabled", soundEnabled);
      localStorage.setItem("animationsEnabled", animationsEnabled);
      localStorage.setItem("theme", theme);
      localStorage.setItem("autosellSettings", JSON.stringify(autosellSettings));
      applySettings();
      settingsModal.classList.add("hidden");
      console.log("Paramètres sauvegardés:", { soundEnabled, animationsEnabled, theme, autosellSettings });
    }

    function resetGame() {
        console.log("resetGame appelé");
        resetConfirmModal.classList.remove("hidden");
        // La confirmation se fera via le bouton de la modale
    }

    async function confirmReset() {
        console.log("Réinitialisation de la partie pour l'utilisateur:", currentUser.uid);
        resetConfirmModal.classList.add("hidden");

        // Supprimer la sauvegarde de la base de données
        if (currentUser) {
            await db.collection('playerSaves').doc(currentUser.uid).delete();
        }
        
        // --- NOUVEAU: Réinitialisation complète des paramètres ---
        // 1. Supprimer les clés de paramètres du localStorage
        localStorage.removeItem("soundEnabled");
        localStorage.removeItem("animationsEnabled");
        localStorage.removeItem("theme");
        localStorage.removeItem("autosellSettings");
        localStorage.removeItem("sortCriteria");
        localStorage.removeItem("battleSortCriteria");
        localStorage.removeItem("presetSortCriteria");
        localStorage.removeItem("battleSearchName");
        localStorage.removeItem("battleFilterRarity");
        localStorage.removeItem("presetSearchName");
        localStorage.removeItem("presetFilterRarity");
        localStorage.removeItem("fusionSearchName");
        localStorage.removeItem("fusionFilterRarity");
        localStorage.removeItem("inventoryFilterName");
        localStorage.removeItem("inventoryFilterRarity");
        localStorage.removeItem("inventoryFilterEvolvable");
        localStorage.removeItem("inventoryFilterLimitBreak");
        localStorage.removeItem("inventoryFilterCanReceiveExp");

        // 2. Réassigner les valeurs par défaut aux variables globales des paramètres
        soundEnabled = true;
        animationsEnabled = true;
        theme = "dark";
        autosellSettings = { Rare: false, Épique: false, Légendaire: false, Mythic: false, Secret: false };
        sortCriteria = "power";
        battleSortCriteria = "power";
        presetSortCriteria = "power";
        battleSearchName = "";
        battleFilterRarity = "all";
        presetSearchName = "";
        presetFilterRarity = "all";
        fusionSearchName = "";
        fusionFilterRarity = "all";
        inventoryFilterName = "";
        inventoryFilterRarity = "all";
        inventoryFilterEvolvable = false;
        inventoryFilterLimitBreak = false;
        inventoryFilterCanReceiveExp = false;
        // --- FIN NOUVEAU ---

        // Réinitialiser le reste du jeu à son état initial
        isGameInitialized = false; // Forcer la réinitialisation
        initializeGameData(null);
        
        // --- NOUVEAU: Appliquer les paramètres réinitialisés à l'UI
        applySettings();
        // --- FIN NOUVEAU ---

        disableNoScroll();

        resultElement.innerHTML = '<p class="text-green-400">Partie et paramètres réinitialisés avec succès !</p>';
        setTimeout(() => {
            if (resultElement.innerHTML.includes("Partie et paramètres réinitialisés")) {
                resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`;
            }
        }, 3000);
    }

    function cancelReset() {
      resetConfirmModal.classList.add("hidden");
    }

    function updateShopOffers() {
      shopOffers = [];
      const availableItems = [...shopItemPool];
      for (let i = 0; i < 3; i++) {
        if (availableItems.length === 0) break;
        const randomIndex = Math.floor(Math.random() * availableItems.length);
        shopOffers.push(availableItems.splice(randomIndex, 1)[0]);
      }
      shopRefreshTime = Date.now() + 2 * 60 * 60 * 1000;
      purchasedOffers = []; // Réinitialiser les offres achetées
      localStorage.setItem("shopOffers", JSON.stringify(shopOffers));
      localStorage.setItem("shopRefreshTime", shopRefreshTime);
      localStorage.setItem("purchasedOffers", JSON.stringify(purchasedOffers));
      updateShopDisplay();
    }

    function updateShopDisplay() {
      shopItemsElement.innerHTML = shopOffers.map((offer, index) => {
        const isPurchased = purchasedOffers.includes(index);
        return `
          <div class="bg-gray-800 bg-opacity-50 p-4 rounded-lg transition transform hover:scale-105">
            <p class="text-white font-semibold">${offer.description}</p>
            <p class="text-white">Coût: ${offer.cost} ${offer.currency}</p>
            <button 
              class="mt-2 bg-blue-500 text-white py-2 px-4 rounded-lg w-full transition transform hover:scale-105 
              ${isPurchased ? 'opacity-50 cursor-not-allowed' : 'hover:bg-blue-600'}" 
              ${isPurchased ? 'disabled' : `onclick="buyItem(${index})"`}
            >
              ${isPurchased ? 'Acheté' : 'Acheter'}
            </button>
          </div>
        `;
      }).join("");
    }


    function updateMissions() {
      missions.forEach(mission => {
        mission.completed = mission.progress >= mission.goal;
      });
      missionListElement.innerHTML = missions.map(m => {
        const progressPercent = m.goal > 0 ? Math.min((m.progress / m.goal) * 100, 100) : (m.completed ? 100 : 0);
        const isCompleted = m.completed;

        // SVG Icon for the gem
        const gemIcon = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-blue-300" viewBox="0 0 20 20" fill="currentColor"><path d="M10 12a2 2 0 100-4 2 2 0 000 4z" /><path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" /></svg>`;
        // SVG Icon for the checkmark
        const checkIcon = `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>`;

        return `
          <div class="mission-card ${isCompleted ? 'completed' : ''}">
            ${isCompleted ? `<div class="mission-completed-badge">${checkIcon} Terminé</div>` : ''}
            
            <div>
              <p class="text-white font-semibold text-lg pr-20">${m.description}</p>
              <p class="text-gray-300 text-sm mt-1">${m.progress} / ${m.goal}</p>
            </div>
            
            <div class="progress-bar-bg mt-auto">
              <div class="progress-bar-fill" style="width: ${progressPercent}%;"></div>
            </div>
            
            <div class="mission-reward">
              ${gemIcon}
              <span class="text-white font-bold">${m.reward.gems}</span>
            </div>
          </div>
        `;
      }).join("");
    }

    function updateMissionPool() {
      missions = [];
      const shuffledMissions = missionPool.sort(() => 0.5 - Math.random());
      missions = shuffledMissions.slice(0, 3).map(m => ({
        ...m,
        progress: 0,
        completed: false
      }));
      localStorage.setItem("missions", JSON.stringify(missions));
      updateMissions();
    }

    function updateTimer() {
      const now = Date.now();
      let timeLeft = shopRefreshTime - now;
      if (timeLeft <= 0) {
        shopRefreshTime = now + 2 * 60 * 60 * 1000;
        localStorage.setItem("shopRefreshTime", shopRefreshTime);
        updateShopOffers();
        updateMissionPool();
        timeLeft = shopRefreshTime - now;
      }
      const hours = Math.floor(timeLeft / (1000 * 60 * 60));
      const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
      const timerText = `${hours}h ${minutes}m`;
      shopTimerElement.textContent = timerText;
      missionTimerElement.textContent = timerText;
    }
    setInterval(updateTimer, 1000);

    function updateItemDisplay() {
      const now = Date.now();
      let expBoostStatus = expMultiplier > 1 && now < expBoostEndTime 
        ? `Actif (expire dans ${Math.floor((expBoostEndTime - now) / 1000 / 60)} min)`
        : "Inactif";
      const itemImages = {
        "Haricots": "https://static.wikia.nocookie.net/animeadventures/images/6/6c/Senzu_Bean.png/revision/latest?cb=20230101141509",
        "Fluide mystérieux": "https://static.wikia.nocookie.net/animeadventures/images/7/72/Mysterious_Fluid.png/revision/latest?cb=20230101141428",
        "Wisteria Flower": "https://static.wikia.nocookie.net/animeadventures/images/9/95/Wisteria_Flower.png/revision/latest/scale-to-width-down/115?cb=20230101141611",
        "Ramen Bowl": "https://static.wikia.nocookie.net/animeadventures/images/f/fd/Ramen_Bowl.png/revision/latest/scale-to-width-down/115?cb=20230101142002",
        "Ghoul Coffee": "https://static.wikia.nocookie.net/animeadventures/images/d/d4/Ghoul_Coffee.png/revision/latest/scale-to-width-down/115?cb=20230101141346",
        "Soul Candy": "https://static.wikia.nocookie.net/animeadventures/images/3/3c/Soul_Candy.png/revision/latest/scale-to-width-down/115?cb=20230101141254",
        "Cooked Fish": "https://static.wikia.nocookie.net/animeadventures/images/f/f6/Cooked_Fish.png/revision/latest/scale-to-width-down/115?cb=20230101141820",
        "Magical Artifact": "https://static.wikia.nocookie.net/animeadventures/images/0/05/Magical_Artifact.png/revision/latest/scale-to-width-down/115?cb=20230101142122",
        "Chocolate Bar's": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/e/ea/Chocolate_Bar%27s.png/revision/latest/scale-to-width-down/200?cb=20250507164414",
        "Curse Talisman": "https://static.wikia.nocookie.net/animeadventures/images/e/eb/Curse_Talisman.png/revision/latest/scale-to-width-down/115?cb=20230101141854",
        "Pièces": "https://via.placeholder.com/150?text=Pièces",
        "Pass XP": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/3/35/Pass_XP.png/revision/latest/scale-to-width-down/200?cb=20240912054111",
        "Stat Chip": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d4/Stat_Chip.png/revision/latest/scale-to-width-down/200?cb=20240925095125",
        "Cursed Token": "https://static.wikia.nocookie.net/animeadventures/images/9/9a/Cursed_Finger.png/revision/latest?cb=20250323070916", // Image mise à jour pour Cursed Token
        "Boost EXP x2": "https://via.placeholder.com/150?text=BoostEXP",
        "Shadow Tracer": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/11/Shadow_Trace.png/revision/latest/scale-to-width-down/200?cb=20240925095144",
        "Blood-Red Armor": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/4/42/Blood-Red_Armor.png/revision/latest/scale-to-width-down/200?cb=20240925095521",
        "Reroll Token": "https://static.wikia.nocookie.net/animeadventures/images/1/1e/Reroll_Token.png/revision/latest?cb=20230209202447",
        "Divin Wish": "https://static.wikia.nocookie.net/animeadventures/images/1/1d/DivineWish.webp/revision/latest?cb=20250214095329",
        "Hellsing Arms": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/5/56/Hellsing_Arms.png/revision/latest/scale-to-width-down/200?cb=20240925095219",
        "Green Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/7/7d/Green_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095259",
        "Yellow Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d6/Yellow_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095305",    
        "Red Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/fe/Red_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095246",
        "Blue Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/2/2a/Blue_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925100144",
        "Pink Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/5/5a/Pink_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095536",
        "Rainbow Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/c/c1/Rainbow_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095210",
        "Crystal": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/3/31/Crystal.png/revision/latest/scale-to-width-down/200?cb=20241108234506",
        "Purple Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/f2/Purple_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095542",
        "Magic Pendant": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/5/50/Magic_Pendant.png/revision/latest/scale-to-width-down/200?cb=20241228183321",
        "Head Captain's Coat": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/7/76/Head_Captain%27s_Coat.png/revision/latest/scale-to-width-down/200?cb=20250301094746",
        "Broken Sword": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/b7/Broken_Sword.png/revision/latest/scale-to-width-down/200?cb=20240925095613",
        "Chipped Blade": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d3/Chipped_Blade.png/revision/latest/scale-to-width-down/200?cb=20250301095941",
        "Cast Blades": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/e/e4/Cast_Blades.png/revision/latest/scale-to-width-down/200?cb=20241228195617",
        "Hardened Blood": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/2/2a/Hardened_Blood.png/revision/latest/scale-to-width-down/200?cb=20241027175015",
        "Silverite Sword": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9c/Silverite_Sword.png/revision/latest/scale-to-width-down/200?cb=20250129015816",
        "Cursed Finger": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9a/Cursed_Finger.png/revision/latest/scale-to-width-down/200?cb=20241108232910",
        "Magma Stone": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/3/33/Magma_Stone.png/revision/latest/scale-to-width-down/200?cb=20250325084958",
        "Magic Stone": "https://static.wikia.nocookie.net/animeadventures/images/6/63/Magic_Stone.png/revision/latest/scale-to-width-down/115?cb=20230101141650",
        "Broken Pendant": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d0/Broken_Pendant.png/revision/latest/scale-to-width-down/200?cb=20241027174604",
        "Stone Pendant": "https://static.wikia.nocookie.net/animeadventures/images/f/f7/Stone_Pendant.png/revision/latest/scale-to-width-down/115?cb=20230101141922",
        "Demon Beads": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/2/28/Demon_Beads.png/revision/latest/scale-to-width-down/200?cb=20240925095328",
        "Nichirin Cleavers": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d9/Nichirin_Cleavers.png/revision/latest/scale-to-width-down/200?cb=20240925095532",
        "Tavern Piece": "https://static.wikia.nocookie.net/animeadventures/images/c/cc/Tavern_Pie.png/revision/latest?cb=20230606150016",
        "Blue Chakra": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/bb/Blue_Chakra.png/revision/latest/scale-to-width-down/200?cb=20240908064022",
        "Red Chakra": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/1e/Red_Chakra.png/revision/latest/scale-to-width-down/200?cb=20240908064022",
        "Skin Patch": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/c/c7/Skin_Patch.png/revision/latest/scale-to-width-down/200?cb=20240925095526",
        "Snake Scale": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d5/Snake_Scale.png/revision/latest/scale-to-width-down/200?cb=20240925095139",
        "Senzu Bean": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/6/6c/Senzu_Bean.png/revision/latest/scale-to-width-down/200?cb=20250404123542",
        "Holy Corpse Eyes": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/a/a5/Holy_Corpse_Eyes.png/revision/latest/scale-to-width-down/200?cb=20241228041057",
        "Holy Corpse Arms": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9d/Holy_Corpse_Arms.png/revision/latest/scale-to-width-down/200?cb=20241228042407",
        "Completed Holy Corpse": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/91/Completed_Holy_Corpse.png/revision/latest/scale-to-width-down/200?cb=20241228201349",
        "Gorgon's Blindfold": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/1f/Gorgon%27s_Blindfold.png/revision/latest/scale-to-width-down/200?cb=20241228195652",
        "Caster's Headpiece": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/4/4f/Caster%27s_Headpiece.png/revision/latest/scale-to-width-down/200?cb=20241228195633",
        "Avalon": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/b7/Avalon.png/revision/latest/scale-to-width-down/200?cb=20241228195608",
        "Goddess' Sword": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/a/a5/Goddess%27_Sword.png/revision/latest/scale-to-width-down/200?cb=20241228195642",
        "Blade of Death": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/ba/Blade_of_Death.png/revision/latest/scale-to-width-down/200?cb=20241228195625",
        "Berserker's Blade": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/8/87/Berserker%27s_Blade.png/revision/latest/scale-to-width-down/200?cb=20250301095923",
        "Shunpo Spirit": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9b/Shunpo_Spirit.png/revision/latest/scale-to-width-down/200?cb=20250301094718",
        "Energy Arrow": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/c/c4/Energy_Arrow.png/revision/latest/scale-to-width-down/200?cb=20250301084925",
        "Hair Ornament": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/5/5d/Hair_Ornament.png/revision/latest/scale-to-width-down/200?cb=20250301094807",
        "Bucket Hat": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/2/2e/Bucket_Hat.png/revision/latest/scale-to-width-down/200?cb=20250301094814",
        "Horn of Salvation": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/f9/Horn_of_Salvation.png/revision/latest/scale-to-width-down/200?cb=20250301094802",
        "Energy Bone": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/2/21/Energy_Bone.png/revision/latest/scale-to-width-down/200?cb=20250301094756",
        "Prison Chair": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/b3/Prison_Chair.png/revision/latest/scale-to-width-down/200?cb=20250301084509",
        "Rotara Earring 2": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/10/Rotara_Earring_2.png/revision/latest/scale-to-width-down/200?cb=20250508200230",
        "Rotara Earring 1": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/f1/Rotara_Earring_1.png/revision/latest/scale-to-width-down/200?cb=20250507164632",
        "Z Blade": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/16/Z_Blade.png/revision/latest/scale-to-width-down/200?cb=20250507174034",
        "Champ's Belt": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/fb/Champ%27s_Belt.png/revision/latest/scale-to-width-down/200?cb=20250507164406",
        "Dog Bone": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9d/Dog_Bone.png/revision/latest/scale-to-width-down/200?cb=20250507160505",
        "Six Eyes": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/91/Six_Eyes.png/revision/latest/scale-to-width-down/200?cb=20241108232222",
        "Tome of Wisdom": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/0/02/Tome_Of_Wisdom.png/revision/latest?cb=20250130224612",
        "Corrupted Visor": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/4/48/Corrupted_Visor.png/revision/latest/scale-to-width-down/200?cb=20250205094632",
        "Tainted Ribbon": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/0/0e/Tainted_Ribbon.png/revision/latest/scale-to-width-down/200?cb=20250301095928",
        "Demon Chalice": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/8/8c/Demon_Chalice.png/revision/latest/scale-to-width-down/200?cb=20250205094729",
        "Essence of the Spirit King": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/4/44/Essence_of_the_Spirit_King.png/revision/latest/scale-to-width-down/200?cb=20250301094735",
        "Ring of Friendship": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/7/75/Ring_of_Friendship.png/revision/latest/scale-to-width-down/200?cb=20250321000834",
        "Red Jewel": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/7/74/Red_Jewel.png/revision/latest/scale-to-width-down/200?cb=20250321000706",
        "Majan Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/6/63/Mojon_Essence.png/revision/latest/scale-to-width-down/200?cb=20250507174026",
        "Donut": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9b/Donut.png/revision/latest/scale-to-width-down/200?cb=20250507160557",
        "Atomic Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/6/6a/Atomic_Essence.png/revision/latest/scale-to-width-down/200?cb=20250507160544",
        "Plume Céleste": "https://png.pngtree.com/png-vector/20250517/ourlarge/pngtree-vibrant-and-detailed-feather-on-white-background-png-image_16308203.png",
        "Sablier Ancien": "https://static.wikia.nocookie.net/animeadventures/images/5/5f/Miracle_Timepiece.png/revision/latest?cb=20221119040302",
        "Restricting Headband": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/fd/Restricting_Headband.png/revision/latest/scale-to-width-down/200?cb=20250603203745",
        "Toil Ribbon" : "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/bb/Tail_Ribbon.png/revision/latest/scale-to-width-down/200?cb=20250603203730",
    };
    
      let itemsHtmlOutput = "";

      if (expMultiplier > 1 && now < expBoostEndTime) {
        itemsHtmlOutput += `
          <div class="bg-gray-700 bg-opacity-40 p-2 rounded-lg border border-gray-600 flex flex-col items-center justify-around text-center h-full min-h-[140px] sm:min-h-[160px]">
            <img src="${itemImages['Boost EXP x2']}" alt="Boost EXP x2" class="w-16 h-16 sm:w-20 sm:h-20 object-contain rounded mb-1">
            <div>
              <p class="text-white font-semibold text-xs sm:text-sm">Boost EXP x2</p>
              <p class="text-white text-xs">${expBoostStatus}</p>
            </div>
          </div>
        `;
      }

      const ownedItemEntries = Object.entries(inventory)
        .filter(([item, quantity]) => {
            if (item === "Pass XP") return pullTickets > 0; // Afficher Pass XP si des tickets sont disponibles
            return quantity > 0; // Pour les autres objets, vérifier la quantité dans l'inventaire
        });

      // Si aucun objet possédé (en tenant compte du Boost EXP et des Pass XP)
      if (ownedItemEntries.length === 0 && !(expMultiplier > 1 && now < expBoostEndTime)) {
        itemDisplay.innerHTML = '<p class="text-white col-span-full text-center">Votre inventaire d\'objets est vide.</p>';
        return;
      }

      ownedItemEntries.forEach(([item, quantity]) => {
        const displayQuantity = item === "Pass XP" ? pullTickets : quantity;
        // S'assurer de ne pas afficher des items avec une quantité de 0 (surtout après la logique Pass XP)
        if (displayQuantity <= 0) return; 

        itemsHtmlOutput += `
          <div class="bg-gray-700 bg-opacity-40 p-2 rounded-lg border border-gray-600 flex flex-col items-center justify-around text-center h-full min-h-[140px] sm:min-h-[160px]">
            <img src="${itemImages[item] || 'https://via.placeholder.com/150?text=Item'}" alt="${item}" class="w-16 h-16 sm:w-20 sm:h-20 object-contain rounded mb-1">
            <div>
              <p class="text-white font-semibold text-xs sm:text-sm">${item}</p>
              <p class="text-white text-xs">Quantité: ${displayQuantity}</p>
            </div>
          </div>
        `;
      });

      // Mettre à jour le DOM une seule fois avec tout le HTML généré
      itemDisplay.innerHTML = itemsHtmlOutput;
      // #item-display est déjà `grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4`
      // Chaque div générée sera un enfant direct et prendra une cellule de cette grille.
    }

    async function _performSave() {
        if (!currentUser || !isGameInitialized) {
            // Ne pas sauvegarder si l'utilisateur n'est pas connecté ou si le jeu n'est pas prêt
            return;
        }
        console.log(`%c[SAVE] Déclenchement de la sauvegarde sur Firestore... (Gemmes: ${gems})`, 'color: #7CFC00');
        
        // Créer un objet contenant toutes les données à sauvegarder
        const saveData = {
            characterIdCounter, gems, coins, pullCount, ownedCharacters, level, exp,
            pullTickets, missions, shopOffers, shopRefreshTime, storyProgress, inventory,
            characterPreset, presetConfirmed, standardPityCount, specialPityCount,
            lastUsedBattleTeamIds, autosellSettings, expMultiplier, expBoostEndTime, discoveredCharacters,
            everOwnedCharacters,
            // Ajoutez toutes les autres variables d'état ici
        };

        try {
            await db.collection('playerSaves').doc(currentUser.uid).set(saveData);
            console.log("%c[SAVE] Progression sauvegardée avec succès !", 'color: #7CFC00');
        } catch (error) {
            console.error("Erreur lors de la sauvegarde de la progression:", error);
        }
    }

    // Nouvelle fonction qui planifie une sauvegarde. C'est celle-ci que nous appellerons partout.
    function scheduleSave() {
        // Annuler toute sauvegarde précédemment planifiée
        if (saveTimeoutId) {
            clearTimeout(saveTimeoutId);
        }
        // Planifier une nouvelle sauvegarde après le délai
        console.log(`[SAVE] Sauvegarde planifiée dans ${SAVE_DELAY_MS / 1000}s...`);
        saveTimeoutId = setTimeout(() => {
            _performSave();
            saveTimeoutId = null; // Réinitialiser l'ID après l'exécution
        }, SAVE_DELAY_MS);
    }

    async function loadProgress(userId) {
        const docRef = db.collection('playerSaves').doc(userId);
        try {
            const doc = await docRef.get();
            if (doc.exists) {
                initializeGameData(doc.data());
            } else {
                // C'est un nouvel utilisateur, il n'a pas de sauvegarde
                initializeGameData(null);
            }
        } catch (error) {
            console.error("Erreur lors du chargement de la progression:", error);
            // En cas d'erreur, on initialise une nouvelle partie pour éviter de bloquer le joueur
            initializeGameData(null);
        }
    }

    function updateUI() {
      gemsElement.textContent = gems;
      coinsElement.textContent = coins;
      pullCountElement.textContent = pullCount;
      levelElement.textContent = level;
      expElement.textContent = exp;
      expNeededElement.textContent = 50 * level * level;

      pullButton.disabled = gems < 100 && pullTickets === 0;
      multiPullButton.disabled = gems < 1000; // CORRECTED: 1000
      specialPullButton.disabled = gems < 150 && pullTickets === 0;
      
      const specialMultiPullButtonElement = document.getElementById("special-multi-pull-button");
      if (specialMultiPullButtonElement) { // ADDED: Disable logic for special multi pull
        specialMultiPullButtonElement.disabled = gems < 1500;
        specialMultiPullButtonElement.classList.toggle("opacity-50", gems < 1500);
        specialMultiPullButtonElement.classList.toggle("cursor-not-allowed", gems < 1500);
      }

      pullButton.classList.toggle("opacity-50", pullButton.disabled);
      pullButton.classList.toggle("cursor-not-allowed", pullButton.disabled);
      
      multiPullButton.classList.toggle("opacity-50", multiPullButton.disabled); // CORRECTED: uses multiPullButton.disabled
      multiPullButton.classList.toggle("cursor-not-allowed", multiPullButton.disabled); // CORRECTED: uses multiPullButton.disabled
      
      specialPullButton.classList.toggle("opacity-50", specialPullButton.disabled);
      specialPullButton.classList.toggle("cursor-not-allowed", specialPullButton.disabled);
      
      deleteButton.textContent = isDeleteMode ? "Confirmer la suppression" : "Activer le mode suppression";
      deleteButton.classList.toggle("bg-red-700", isDeleteMode);
      deleteButton.classList.toggle("bg-red-500", !isDeleteMode);

      const stats = { Rare: 0, Épique: 0, Légendaire: 0, Mythic: 0, Secret: 0 };
      ownedCharacters.forEach(char => stats[char.rarity]++);
      rareCountElement.textContent = stats.Rare;
      epicCountElement.textContent = stats.Épique;
      legendaryCountElement.textContent = stats.Légendaire;
      mythicCountElement.textContent = stats.Mythic;
      secretCountElement.textContent = stats.Secret;
      const standardPityDisplay = document.getElementById("standard-pity-display");
      const specialPityDisplay = document.getElementById("special-pity-display");
      if (standardPityDisplay) standardPityDisplay.textContent = standardPityCount;
      if (specialPityDisplay) specialPityDisplay.textContent = specialPityCount;

      updateShopDisplay(); 
    }

    function getRarityBorderClass(rarity) {
      const borderClasses = {
          Rare: "border-gray-400",
          Épique: "border-purple-400",
          Légendaire: "border-yellow-400",
          Mythic: "rainbow-border",
          Secret: "border-secret",
          Vanguard: "border-vanguard" // NOUVEAU
      };
      return borderClasses[rarity] || "border-gray-400";
    }


    function addExp(amount) {
      exp += Math.floor(amount * expMultiplier);
      missions.forEach(mission => {
        if (mission.type === "exp_gain" && !mission.completed) {
          mission.progress += amount;
        }
      });
      let leveledUp = false;
      while (exp >= 50 * level * level) {
        exp -= 50 * level * level;
        level++;
        leveledUp = true;
        gems = Math.min(gems + 100, 10000000);
        coins = Math.min(coins + 20, 1000000);
        resultElement.innerHTML = `<p class="text-green-400">Niveau ${level} atteint ! +100 gemmes, +20 pièces</p>`;
      }
      if (leveledUp) {
        missions.forEach(mission => {
          if (mission.type === "level_up" && !mission.completed) {
            mission.progress++;
          }
        });
      }
      checkMissions();
      updateUI();
    }

    function getCharacterFromSpecialBanner(characters) {
      const totalChance = characters.reduce((sum, char) => sum + char.chance, 0);
      let random = Math.random() * totalChance;
      for (const char of characters) {
        random -= char.chance;
        if (random <= 0) {
          return char;
        }
      }
      return characters[characters.length - 1]; // Fallback
    }

    function getCharacterFromStandardBanner() {
        const rand = Math.random();
        let cumulativeChance = 0;

        // 1. Déterminer la rareté
        let chosenRarity = null;
        for (const rarity in BANNER_CONFIG) {
            cumulativeChance += BANNER_CONFIG[rarity].overallChance;
            if (rand <= cumulativeChance) {
                chosenRarity = rarity;
                break;
            }
        }
        if (!chosenRarity) chosenRarity = "Rare"; // Fallback

        const rarityConfig = BANNER_CONFIG[chosenRarity];
        const featuredCharacterNames = currentStandardBanner[chosenRarity] || [];
        const allCharsOfThisRarity = standardCharacters.filter(char => char.rarity === chosenRarity);

        // 2. Déterminer si c'est un personnage en vedette ou non
        const isFeaturedPull = Math.random() < rarityConfig.featuredPoolRatio;

        if (isFeaturedPull && featuredCharacterNames.length > 0) {
            // Tirer parmi les personnages en vedette
            if (chosenRarity === "Mythic" && rarityConfig.featuredRelativeWeights && rarityConfig.featuredRelativeWeights.length === featuredCharacterNames.length) {
                // Utiliser les poids relatifs pour les Mythics vedettes
                const mythicRand = Math.random();
                let mythicCumulative = 0;
                for (let i = 0; i < featuredCharacterNames.length; i++) {
                    mythicCumulative += rarityConfig.featuredRelativeWeights[i];
                    if (mythicRand <= mythicCumulative) {
                        const foundChar = allCharsOfThisRarity.find(c => c.name === featuredCharacterNames[i]);
                        return foundChar || allCharsOfThisRarity[0]; // Fallback si non trouvé
                    }
                }
                // Fallback si la somme des poids n'atteint pas 1 ou autre souci
                const foundChar = allCharsOfThisRarity.find(c => c.name === featuredCharacterNames[0]);
                return foundChar || allCharsOfThisRarity[0];
            } else {
                // Répartition égale pour les autres raretés vedettes
                const randomFeaturedIndex = Math.floor(Math.random() * featuredCharacterNames.length);
                const foundChar = allCharsOfThisRarity.find(c => c.name === featuredCharacterNames[randomFeaturedIndex]);
                return foundChar || allCharsOfThisRarity[0];
            }
        } else {
            // Tirer parmi les personnages non-vedette
            const nonFeaturedChars = allCharsOfThisRarity.filter(char => !featuredCharacterNames.includes(char.name));
            if (nonFeaturedChars.length > 0) {
                const randomNonFeaturedIndex = Math.floor(Math.random() * nonFeaturedChars.length);
                return nonFeaturedChars[randomNonFeaturedIndex];
            } else if (allCharsOfThisRarity.length > 0) {
                // Fallback: si tous les persos de la rareté sont en vedette et qu'on tire un "non-vedette"
                // (ou s'il n'y a pas de non-vedette), on tire quand même un de cette rareté.
                const randomIndex = Math.floor(Math.random() * allCharsOfThisRarity.length);
                return allCharsOfThisRarity[randomIndex];
            }
        }
        
        // Ultime fallback: si rien n'est trouvé (ne devrait pas arriver)
        return standardCharacters.find(c => c.rarity === "Rare") || standardCharacters[0];
    }


    async function animatePull(characters, additionalMessage = '') {
      resultElement.innerHTML = `<p class="text-white">Tirage en cours...</p>`;
      if (animationsEnabled) {
        resultElement.classList.add("animate-pulse");
      }
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Ne pas afficher les personnages, juste nettoyer l'animation
      if (animationsEnabled) {
        resultElement.classList.remove("animate-pulse");
      }

      // Afficher le message de coût (par exemple, "100 gemmes dépensées")
      resultElement.innerHTML = `<p class="text-green-400">${additionalMessage}</p>`;
      
      // Attendre un court instant pour montrer le message de coût
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Revenir au message initial
      resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`;
    }

    async function pullCharacter() {
        console.log("pullCharacter (standard banner) appelé");
        currentPullType = "standard"; 
        const standardPullCost = 100; // Coût fixe pour un tirage standard x1

        if (pullTickets > 0) {
            openPullMethodModal(currentPullType); // openPullMethodModal vérifiera les gemmes si l'option gemmes est choisie
        } else {
            // Si pas de ticket, tenter directement avec des gemmes
            if (gems < standardPullCost) {
                 resultElement.innerHTML = '<p class="text-red-400">Pas assez de gemmes (100 requis) !</p>';
                 return;
            }

            executePull(false); 
        }
    }

    async function multiPull() {
      console.log("multiPull (standard banner) appelé, gemmes:", gems, "autosellSettings:", autosellSettings);
      const cost = 1000;
      const expectedPulls = 10;
      const expGainForMulti = 100;

      if (gems < cost) {
        resultElement.innerHTML = `<p class="text-red-400">Pas assez de gemmes (${cost} requis) !</p>`;
        console.log("Échec du tirage multiple: pas assez de gemmes. Gemmes actuelles:", gems, "Coût:", cost);
        return;
      }

      gems -= cost;

      missions.forEach(mission => {
          if (mission.type === "spend_gems" && !mission.completed) {
              mission.progress += cost; // Remplacez 'cost' par 'gemCost' dans la fonction executePull
          }
      });

      pullCount += expectedPulls;
      const pulledCharsForDisplay = []; // Pour l'animation
      let autoSoldCharactersInfo = [];
      let hasPulledEpicOrBetter = false; // Pour la garantie d'un Épique minimum

      let pityMessagePart = ""; // Pour stocker le message de Pity

      for (let i = 0; i < expectedPulls; i++) {
        let char = getCharacterFromStandardBanner(); 

        // Logique de garantie d'un Épique ou mieux pour le dernier tirage du multi
        if (i === (expectedPulls - 1) && !hasPulledEpicOrBetter) {
          let attempts = 0;
          while (rarityOrder[char.rarity] < rarityOrder["Épique"] && attempts < 20) {
            char = getCharacterFromStandardBanner();
            attempts++;
          }
        }
        if (rarityOrder[char.rarity] >= rarityOrder["Épique"]) {
          hasPulledEpicOrBetter = true;
        }

        if (char.rarity === "Mythic") {
            missions.forEach(mission => {
                if (mission.type === "mythic_chars" && !mission.completed) {
                    mission.progress++;
                }
            });
        }

        // --- DÉBUT LOGIQUE PITY pour multiPull Standard ---
        standardPityCount++;
        let pulledCharIsMythicOrBetterThisIteration = (rarityOrder[char.rarity] >= rarityOrder.Mythic);

        if (standardPityCount >= STANDARD_MYTHIC_PITY_THRESHOLD && !pulledCharIsMythicOrBetterThisIteration) {
            let mythicsInStandard = standardCharacters.filter(c => c.rarity === "Mythic");
            if (mythicsInStandard.length > 0) {
                char = mythicsInStandard[Math.floor(Math.random() * mythicsInStandard.length)];
                pityMessagePart += ` Pity (tirage ${i+1})! ${char.name} (Mythic) garanti.`; // Ajouter au message global du multi
                pulledCharIsMythicOrBetterThisIteration = true;
                console.log(`Pity (multi standard) tirage ${i+1}: ${char.name} (Mythic) garanti.`);
            } else {
                console.error("PITY ERROR (multi standard): Aucun Mythic à forcer.");
            }
        }

        if (pulledCharIsMythicOrBetterThisIteration) {
            standardPityCount = 0; // Réinitialiser si un Mythic ou mieux est obtenu (naturellement ou par pity)
        }
        // --- FIN LOGIQUE PITY pour multiPull Standard ---
        // `char` est maintenant soit l'original, soit celui du pity.

        const newStatRank = getRandomStatRank(true); 
        const characterWithId = {
            ...char, 
            id: `char_${characterIdCounter++}`,
            level: 1,
            exp: 0,
            locked: false,
            hasEvolved: false,
            curseEffect: 0,
            basePower: char.power, 
            statRank: newStatRank,
            statModifier: statRanks[newStatRank].modifier,
            trait: { id: null, grade: 0 } 
        };
        recalculateCharacterPower(characterWithId); 

        if (!discoveredCharacters.includes(char.name)) {
          discoveredCharacters.push(char.name);
        }

        if (autosellSettings[char.rarity] === true) {
          const rewards = autoSellCharacter(characterWithId);
          autoSoldCharactersInfo.push({ name: char.name, rarity: char.rarity, gems: rewards.gems, coins: rewards.coins });
        } else {
          pulledCharsForDisplay.push(characterWithId); // Pour l'animation
          ownedCharacters.unshift(characterWithId);
          if (!everOwnedCharacters.includes(char.name)) {
            everOwnedCharacters.push(char.name);
          }
        }

        missions.forEach(mission => {
          if (!mission.completed) {
            if (mission.type === "pulls") mission.progress++;
            if (mission.type === "epic_chars" && char.rarity === "Épique") mission.progress++;
            if (mission.type === "legendary_chars" && char.rarity === "Légendaire") mission.progress++;
          }
        });
      } // Fin de la boucle for

      checkMissions();
      let message = `${cost} gemmes dépensées.`;
      if (pityMessagePart) { // Ajouter le message de Pity s'il y en a eu un
          message += pityMessagePart;
      }
      if (autoSoldCharactersInfo.length > 0) {
        const totalAutoSellGems = autoSoldCharactersInfo.reduce((sum, charInfo) => sum + charInfo.gems, 0);
        const totalAutoSellCoins = autoSoldCharactersInfo.reduce((sum, charInfo) => sum + charInfo.coins, 0);
        message += ` ${autoSoldCharactersInfo.length} personnage(s) auto-vendu(s) pour +${totalAutoSellGems} gemmes, +${totalAutoSellCoins} pièces.`;
      }

      await animatePull(pulledCharsForDisplay, message); // Utilise pulledCharsForDisplay pour l'animation
      if (pulledCharsForDisplay.some(c => (c.rarity === "Mythic" || c.rarity === "Secret" || c.rarity === "Vanguard")) && animationsEnabled) {
        confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });
      }

      addExp(expGainForMulti);
      updateCharacterDisplay();
      updateIndexDisplay();
      updateUI(); // Mettra à jour l'affichage du Pity
      localStorage.setItem("characterIdCounter", characterIdCounter);
      scheduleSave();
      console.log("multiPull (standard banner) terminé, ownedCharacters:", ownedCharacters.length);
    }

    function specialPull() {
      console.log("specialPull appelé");
      currentPullType = "special";
        if (pullTickets > 0) {
            // Afficher la modale si au moins un ticket est disponible
            pullMethodModal.classList.remove("hidden");
            document.body.classList.add("no-scroll");
        } else {
            // Effectuer un tirage avec des gemmes si aucun ticket n'est disponible
            executePull(false);
        }
    }

    async function executePull(useTicket) {
        console.log("executePull appelé, useTicket:", useTicket, "currentPullType:", currentPullType);
        let message = "";
        let autoSold = false;
        let autoSellRewards = { gems: 0, coins: 0 };
        
        let selectedCharacter;
        let gemCost;
        let expGain;

        // --- DÉBUT LOGIQUE PITY PARTIE 1 : Détermination coût & type ---
        if (currentPullType === "standard") {
            selectedCharacter = getCharacterFromStandardBanner();
            if (selectedCharacter.rarity === "Mythic") {
                missions.forEach(mission => {
                    if (mission.type === "mythic_chars" && !mission.completed) {
                        mission.progress++;
                    }
                });
            }
            gemCost = 100; 
            expGain = 10;
        } else if (currentPullType === "special") {
            selectedCharacter = getCharacterFromSpecialBanner(specialCharacters); 
            gemCost = 150; 
            expGain = 15;
        } else {
            console.error("Type de tirage inconnu:", currentPullType);
            return;
        }
        // --- FIN LOGIQUE PITY PARTIE 1 ---

        if (useTicket) {
            if (pullTickets <= 0) {
                resultElement.innerHTML = '<p class="text-red-400">Pas de tickets disponibles !</p>';
                return;
            }
            pullTickets--;
            inventory["Pass XP"] = Math.max(0, (inventory["Pass XP"] || 0) - 1); 
            message = "Pass utilisé !";
        } else {
            if (gems < gemCost) {
                resultElement.innerHTML = `<p class="text-red-400">Pas assez de gemmes (${gemCost} requis) !</p>`;
                return;
            }
            gems -= gemCost;

            missions.forEach(mission => {
                if (mission.type === "spend_gems" && !mission.completed) {
                    mission.progress += cost; // Remplacez 'cost' par 'gemCost' dans la fonction executePull
                }
            });

            message = `${gemCost} gemmes dépensées.`;
        }

        pullCount++;

        // --- DÉBUT LOGIQUE PITY PARTIE 2 : Vérification et Forçage Pity ---
        let characterPulledIsPityTargetOrBetter = false; // Pour le reset du pity

        if (currentPullType === "standard") {
            standardPityCount++;
            if (rarityOrder[selectedCharacter.rarity] >= rarityOrder.Mythic) { // Mythic ou mieux
                characterPulledIsPityTargetOrBetter = true;
            }

            if (standardPityCount >= STANDARD_MYTHIC_PITY_THRESHOLD && !characterPulledIsPityTargetOrBetter) {
                let mythicsInStandard = standardCharacters.filter(c => c.rarity === "Mythic");
                if (mythicsInStandard.length > 0) {
                    selectedCharacter = mythicsInStandard[Math.floor(Math.random() * mythicsInStandard.length)];
                    message += ` Pity atteint! ${selectedCharacter.name} (Mythic) garanti.`;
                    characterPulledIsPityTargetOrBetter = true; 
                    console.log("Pity Standard (x1) déclenché. Personnage:", selectedCharacter.name);
                } else {
                    console.error("PITY ERROR (standard x1): Aucun Mythic à forcer.");
                }
            }
            if (characterPulledIsPityTargetOrBetter) {
                standardPityCount = 0;
            }
        } else if (currentPullType === "special") {
            specialPityCount++;
            // Vérifie si le personnage tiré naturellement est un "Secret" ou "Vanguard"
            const isSpecialBannerTargetNaturally = specialCharacters.some(sc => sc.name === selectedCharacter.name && (sc.rarity === "Secret" || sc.rarity === "Vanguard"));
            if (isSpecialBannerTargetNaturally) {
                characterPulledIsPityTargetOrBetter = true;
            }

            if (specialPityCount >= SPECIAL_BANNER_PITY_THRESHOLD && !characterPulledIsPityTargetOrBetter) {
                let secretCharsInSpecial = specialCharacters.filter(c => c.rarity === "Secret");
                if (secretCharsInSpecial.length > 0) {
                    selectedCharacter = secretCharsInSpecial[Math.floor(Math.random() * secretCharsInSpecial.length)];
                    message += ` Pity atteint! ${selectedCharacter.name} (Secret) garanti.`;
                    characterPulledIsPityTargetOrBetter = true; // Un Secret est une cible de pity
                    console.log("Pity Spécial (x1) déclenché. Personnage Secret:", selectedCharacter.name);
                } else {
                    // Fallback si aucun Secret n'est défini dans specialCharacters
                    console.warn("PITY WARNING (spécial x1): Aucun personnage 'Secret' trouvé dans la bannière spéciale pour la pity. Tirage normal appliqué.");
                    selectedCharacter = getCharacterFromSpecialBanner(specialCharacters); // Comportement original
                    message += ` Pity atteint! ${selectedCharacter.name} (${selectedCharacter.rarity}) garanti (fallback).`;
                    // Vérifier si le fallback est quand même une cible (Secret ou Vanguard)
                    if (selectedCharacter.rarity === "Secret" || selectedCharacter.rarity === "Vanguard") {
                        characterPulledIsPityTargetOrBetter = true;
                    }
                }
            }
            if (characterPulledIsPityTargetOrBetter) {
                specialPityCount = 0;
            }
        }
        // --- FIN LOGIQUE PITY PARTIE 2 ---
        
        const newStatRank = getRandomStatRank(true); 
        const characterWithId = {
            ...selectedCharacter, 
            id: `char_${characterIdCounter++}`,
            level: 1,
            exp: 0,
            locked: false,
            hasEvolved: false,
            curseEffect: 0,
            basePower: selectedCharacter.power, 
            statRank: newStatRank,
            statModifier: statRanks[newStatRank].modifier,
            trait: { id: null, grade: 0 } 
        };
        recalculateCharacterPower(characterWithId);

        if (!discoveredCharacters.includes(selectedCharacter.name)) {
            discoveredCharacters.push(selectedCharacter.name);
        }

        if (autosellSettings[selectedCharacter.rarity] === true) {
            autoSellRewards = autoSellCharacter(characterWithId);
            autoSold = true;
            message += ` ${selectedCharacter.name} auto-vendu pour +${autoSellRewards.gems} gemmes, +${autoSellRewards.coins} pièces.`;
        } else {
            ownedCharacters.unshift(characterWithId);
            if (!everOwnedCharacters.includes(selectedCharacter.name)) {
                everOwnedCharacters.push(selectedCharacter.name);
            }
        }

        missions.forEach(mission => {
            if (!mission.completed) {
                if (currentPullType === "standard" && mission.type === "pulls") mission.progress++;
                if (currentPullType === "special" && mission.type === "special_pulls") mission.progress++;
                if (mission.type === "epic_chars" && selectedCharacter.rarity === "Épique") mission.progress++;
                if (mission.type === "legendary_chars" && selectedCharacter.rarity === "Légendaire") mission.progress++;
                if (currentPullType === "special" && mission.type === "special_chars") mission.progress++;
            }
        });

        await animatePull(autoSold ? [] : [characterWithId], message);
        if (!autoSold && animationsEnabled && (characterWithId.rarity === "Mythic" || characterWithId.rarity === "Secret" || characterWithId.rarity === "Vanguard")) {
            confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });
        }

        addExp(expGain);
        checkMissions();
        updateCharacterDisplay();
        updateIndexDisplay();
        updateItemDisplay();
        updateUI();
        localStorage.setItem("characterIdCounter", characterIdCounter);
        scheduleSave();
        console.log("executePull (x1) terminé, ownedCharacters:", ownedCharacters.length);
    }

    async function specialMultiPull() {
      console.log("specialMultiPull appelé, gemmes:", gems, "autosellSettings:", autosellSettings);
      const cost = 1500;
      const expectedPulls = 10;
      const expGain = 150;

      if (gems < cost) {
        resultElement.innerHTML = '<p class="text-red-400">Pas assez de gemmes (' + cost + ' requis) ! Vous avez ' + gems + '.</p>';
        console.log("Échec du tirage spécial multiple: pas assez de gemmes. Gemmes actuelles:", gems, "Coût:", cost);
        return;
      }

      gems -= cost;

      missions.forEach(mission => {
          if (mission.type === "spend_gems" && !mission.completed) {
              mission.progress += cost; // Remplacez 'cost' par 'gemCost' dans la fonction executePull
          }
      });

      pullCount += expectedPulls;
      const results = []; 
      let autoSoldCharacters = []; 
      let totalAutoSellGems = 0;
      let totalAutoSellCoins = 0;
      let pityMessagePart = ""; 

      for (let i = 0; i < expectedPulls; i++) {
        let char = getCharacterFromSpecialBanner(specialCharacters); 

        // --- DÉBUT LOGIQUE PITY pour specialMultiPull ---
        specialPityCount++;
        // Vérifie si le personnage tiré naturellement est un "Secret" ou "Vanguard"
        let isSpecialBannerTargetPulledThisIteration = specialCharacters.some(sc => sc.name === char.name && (sc.rarity === "Secret" || sc.rarity === "Vanguard"));

        if (specialPityCount >= SPECIAL_BANNER_PITY_THRESHOLD && !isSpecialBannerTargetPulledThisIteration) {
            let secretCharsInSpecial = specialCharacters.filter(c => c.rarity === "Secret");
            if (secretCharsInSpecial.length > 0) {
                char = secretCharsInSpecial[Math.floor(Math.random() * secretCharsInSpecial.length)];
                pityMessagePart += ` Pity (tirage ${i+1})! ${char.name} (Secret) garanti.`;
                isSpecialBannerTargetPulledThisIteration = true; // Un Secret est une cible
                console.log(`Pity (multi spécial) tirage ${i+1}: ${char.name} (Secret) garanti.`);
            } else {
                // Fallback si aucun Secret n'est défini dans specialCharacters
                console.warn(`PITY WARNING (multi spécial tirage ${i+1}): Aucun personnage 'Secret' trouvé dans la bannière spéciale pour la pity. Tirage normal appliqué.`);
                char = getCharacterFromSpecialBanner(specialCharacters); // Comportement original
                pityMessagePart += ` Pity (tirage ${i+1})! ${char.name} (${char.rarity}) garanti (fallback).`;
                // Vérifier si le fallback est quand même une cible (Secret ou Vanguard)
                if (char.rarity === "Secret" || char.rarity === "Vanguard") {
                     isSpecialBannerTargetPulledThisIteration = true;
                }
            }
        }

        if (isSpecialBannerTargetPulledThisIteration) {
            specialPityCount = 0; 
        }
        // --- FIN LOGIQUE PITY pour specialMultiPull ---
        
        const newStatRank = getRandomStatRank(true);
        const characterWithId = {
            ...char, 
            id: `char_${characterIdCounter++}`,
            level: 1,
            exp: 0,
            locked: false,
            hasEvolved: false,
            curseEffect: 0,
            basePower: char.power,
            statRank: newStatRank,
            statModifier: statRanks[newStatRank].modifier,
            trait: { id: null, grade: 0 }
        };
        recalculateCharacterPower(characterWithId);

        if (!discoveredCharacters.includes(char.name)) {
          discoveredCharacters.push(char.name);
        }

        if (autosellSettings[char.rarity] === true) {
          const rewards = autoSellCharacter(characterWithId);
          autoSoldCharacters.push({ ...char, gems: rewards.gems, coins: rewards.coins }); 
          totalAutoSellGems += rewards.gems;
          totalAutoSellCoins += rewards.coins;
        } else {
          results.push(characterWithId); 
          ownedCharacters.unshift(characterWithId);
          if (!everOwnedCharacters.includes(char.name)) {
            everOwnedCharacters.push(char.name);
          }
        }

        missions.forEach(mission => {
          if (!mission.completed) {
            if (mission.type === "special_pulls") mission.progress++;
            if (mission.type === "epic_chars" && char.rarity === "Épique") mission.progress++;
            if (mission.type === "legendary_chars" && char.rarity === "Légendaire") mission.progress++;
            if (mission.type === "special_chars") mission.progress++;
          }
        });
      } // Fin de la boucle for

      checkMissions();

      let message = `${cost} gemmes dépensées.`;
      if (pityMessagePart) { 
          message += pityMessagePart;
      }
      if (autoSoldCharacters.length > 0) {
        message += ` ${autoSoldCharacters.length} personnage(s) auto-vendu(s) pour +${totalAutoSellGems} gemmes, +${totalAutoSellCoins} pièces.`;
      }
      await animatePull(results, message);

      if (results.some(c => (c.rarity === "Mythic" || c.rarity === "Secret" || c.rarity === "Vanguard")) && animationsEnabled) {
        confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });
      }

      addExp(expGain);
      updateCharacterDisplay();
      updateIndexDisplay();
      updateUI(); 
      localStorage.setItem("characterIdCounter", characterIdCounter);
      scheduleSave();
      console.log("specialMultiPull terminé, ownedCharacters:", ownedCharacters.length);
    }

    function awardLevelRewards(level) {
        const isLevelCompleted = level.completed; // Vérifie si le niveau est déjà complété
        const rewardMultiplier = isLevelCompleted ? 0.5 : 1; // Réduction à 50 % si déjà complété

        // Appliquer les récompenses avec le multiplicateur
        const gemsReward = Math.floor(level.rewards.gems * rewardMultiplier);
        const coinsReward = level.rewards.coins; // Pas de réduction pour les pièces (optionnel, ajustez si nécessaire)
        const expReward = Math.floor(level.rewards.exp * rewardMultiplier);

        gems += gemsReward;
        coins += coinsReward;
        addExp(expReward);

        // Afficher le résultat avec une indication si réduit
        resultElement.innerHTML = `<p class="text-green-400">Niveau ${level.name} terminé !</p>
            <p class="text-white">+${gemsReward} gemmes${isLevelCompleted ? ' (réduit)' : ''}, +${coinsReward} pièces, +${expReward} EXP${isLevelCompleted ? ' (réduit)' : ''}</p>`;

        // Mettre à jour l'interface
        updateUI();
        scheduleSave();
        }

        // Exemple d'appel dans une fonction de complétion de niveau (à adapter selon votre code)
        function completeLevel(levelId) {
        const level = baseStoryLevels.find(l => l.id === levelId);
        if (level && !level.completed) {
            level.completed = true;
        }
        awardLevelRewards(level);
    }

    function showCharacterStats(id) {
        const char = ownedCharacters.find(c => c.id === id);
        if (!char) return;
        const baseChar = allCharacters.find(c => c.name === char.name);

        const currentCharacterMaxLevel = char.maxLevelCap || 60; // Utiliser maxLevelCap
        const isAtCurrentMaxLevel = char.level >= currentCharacterMaxLevel;
        const expNeeded = isAtCurrentMaxLevel ? 0 : getExpNeededForCharacterLevel(char.level, char.rarity);
        const expPercentage = isAtCurrentMaxLevel ? 100 : Math.min((char.exp / expNeeded) * 100, 100).toFixed(2);

        let curseInfoHtml = '';
        if (char.curseEffect && char.curseEffect !== 0) {
            const referencePowerForPercentage = (char.basePower * char.statModifier);
            let percentageChange = 0;
            if (referencePowerForPercentage !== 0) {
                percentageChange = ((char.curseEffect / referencePowerForPercentage) * 100); // Correction: curseEffect au lieu de char.curseEffect()
            } else if (char.basePower !== 0) {
                percentageChange = ((char.curseEffect / char.basePower) * 100);
            }
            const displayPercentage = percentageChange.toFixed(percentageChange % 1 === 0 ? 0 : (Math.abs(percentageChange) < 1 ? 2 : 1));
            const curseClass = char.curseEffect > 0 ? 'text-green-400' : 'text-red-400';
            const sign = char.curseEffect > 0 ? '+' : '';
            curseInfoHtml = `<p><strong>Malédiction:</strong> <span class="${curseClass}">${sign}${displayPercentage}%</span></p>`;
        }

        let traitInfoHtml = '<p><strong>Trait:</strong> Aucun</p>';
        if (char.trait && char.trait.id && char.trait.grade > 0) {
            const traitDef = TRAIT_DEFINITIONS[char.trait.id];
            if (traitDef && traitDef.grades) {
                const gradeDef = traitDef.grades.find(g => g.grade === char.trait.grade);
                if (gradeDef) {
                    let traitNameDisplay = traitDef.name;
                    if (traitDef.gradeProbabilities && traitDef.gradeProbabilities.length > 0) {
                        traitNameDisplay += ` (Grade ${gradeDef.grade})`;
                    }

                    let nameStyle = ""; // Sera utilisé pour le nom du trait
                    let descriptionClass = "text-xs text-gray-300"; // Classe par défaut pour la description
                    
                    // Spécifiquement pour "Golder" et sa description
                    if (traitDef.id === "golder" && gradeDef.description === "+15% Gemmes & Pièces (Tous modes)") {
                        nameStyle = 'class="text-gold-brilliant"'; // Utilisation de la classe pour le nom
                        descriptionClass = "text-xs text-gold-brilliant"; // Et pour la description
                        // text-shadow est déjà dans la classe .text-gold-brilliant
                        traitInfoHtml = `
                            <p><strong>Trait:</strong> <span ${nameStyle}>${traitNameDisplay}</span></p>
                            ${gradeDef.description ? `<p class="${descriptionClass}"><em>Effet: ${gradeDef.description}</em></p>` : ''}
                        `;
                    } else {
                        traitInfoHtml = `
                            <p><strong>Trait:</strong> ${traitNameDisplay}</p>
                            ${gradeDef.description ? `<p class="${descriptionClass}"><em>Effet: ${gradeDef.description}</em></p>` : ''}
                        `;
                    }
                }
            }
        }

        modalContent.innerHTML = `
            <p><strong>Nom:</strong> ${char.name}</p>
            <p><strong>Rareté:</strong> <span class="${char.rarity === 'Mythic' ? 'rainbow-text' : (char.rarity === 'Secret' ? 'text-secret' : (char.rarity === 'Vanguard' ? 'text-vanguard' : char.color))}">${char.rarity}</span> ${char.locked ? '🔒' : ''}</p>
            <p><strong>Niveau:</strong> ${char.level}${isAtCurrentMaxLevel ? ` (Max Actuel: ${currentCharacterMaxLevel})` : ` / ${currentCharacterMaxLevel}`}</p>
            <p><strong>Puissance:</strong> ${char.power}</p>
            <p><strong><span class='${statRanks[char.statRank]?.color || "text-white"}'>Rang Stat:</span></strong> ${char.statRank}</p>
            ${curseInfoHtml}
            ${traitInfoHtml}
            <p class="mt-2"><strong>EXP:</strong> ${isAtCurrentMaxLevel ? 'Max' : `${char.exp}/${expNeeded}`}</p>
            <div class="w-full bg-gray-700 rounded h-4 mt-2">
                <div class="bg-green-500 h-full rounded transition-all duration-300" style="width: ${expPercentage}%"></div>
            </div>
        `;

        statsModal.classList.remove("hidden");
        enableNoScroll(); 

        fuseButton.disabled = isAtCurrentMaxLevel || isDeleteMode || ownedCharacters.length <= 1 || char.locked;
        fuseButton.classList.toggle("opacity-50", fuseButton.disabled);
        fuseButton.classList.toggle("cursor-not-allowed", fuseButton.disabled);
        fuseButton.onclick = () => startFusion(id);

        const hasPowerItem = Object.entries(inventory).some(([item, quantity]) => quantity > 0 && itemEffects[item]?.power);
        giveItemsButton.disabled = isDeleteMode || (isAtCurrentMaxLevel && !hasPowerItem); 
        giveItemsButton.classList.toggle("opacity-50", giveItemsButton.disabled);
        giveItemsButton.classList.toggle("cursor-not-allowed", giveItemsButton.disabled);
        giveItemsButton.onclick = () => startGiveItems(id);

        const lockButton = document.getElementById("lock-button");
        lockButton.textContent = char.locked ? "Déverrouiller" : "Verrouiller";
        lockButton.disabled = isDeleteMode;
        lockButton.classList.toggle("opacity-50", lockButton.disabled);
        lockButton.classList.toggle("cursor-not-allowed", lockButton.disabled);
        lockButton.classList.toggle("bg-red-500", char.locked); 
        lockButton.classList.toggle("hover:bg-red-600", char.locked);
        lockButton.classList.toggle("bg-gray-500", !char.locked);
        lockButton.classList.toggle("hover:bg-gray-600", !char.locked);
        lockButton.onclick = () => toggleLockCharacter(id); 

        const existingEvolveButton = document.getElementById("evolve-button");
        if (existingEvolveButton) existingEvolveButton.remove(); 

        if (baseChar.evolutionRequirements && baseChar.evolutionRequirements.length > 0 && !char.hasEvolved) { 
            const evolveButton = document.createElement("button");
            evolveButton.id = "evolve-button";
            evolveButton.className = "bg-pink-500 hover:bg-pink-600 text-white py-2 px-4 rounded-lg text-sm sm:text-base";
            evolveButton.textContent = "Évoluer";
            evolveButton.disabled = isDeleteMode || char.locked; 
            evolveButton.classList.toggle("opacity-50", evolveButton.disabled);
            evolveButton.classList.toggle("cursor-not-allowed", evolveButton.disabled);
            evolveButton.onclick = () => startEvolution(id);
            if(fuseButton.parentNode) {
                fuseButton.parentNode.appendChild(evolveButton);
            }
        }
    }
            
    function deleteCharacter(id) {
      const char = ownedCharacters.find(c => c.id === id); // Trouver le personnage
      if (!char) return; // Sécurité

      if (isDeleteMode && !char.locked) {
        if (selectedCharacterIndices.has(id)) {
          selectedCharacterIndices.delete(id);
        } else {
          selectedCharacterIndices.add(id);
        }
        updateCharacterDisplay();
        updateUI();
      } else if (isDeleteMode && char.locked) {
        console.log("Personnage verrouillé, ne peut pas être sélectionné pour suppression.");
        resultElement.innerHTML = `<p class="text-yellow-400">Ce personnage est verrouillé et ne peut pas être supprimé.</p>`;
        setTimeout(() => { resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`; }, 3000);
      }
    }

    function closeModal() {
      statsModal.classList.add("hidden");
      disableNoScroll(); // <--- AJOUTER CETTE LIGNE
    }

    function toggleDeleteMode() {
      isDeleteMode = !isDeleteMode;
      if (!isDeleteMode) {
        deleteSelectedCharacters();
      }
      selectedCharacterIndices.clear();
      updateCharacterDisplay();
      updateUI();
    }

    function selectCharacter(id) {
      if (isDeleteMode) {
        if (selectedCharacterIndices.has(id)) {
          selectedCharacterIndices.delete(id);
        } else {
          selectedCharacterIndices.add(id);
        }
        updateCharacterDisplay();
        updateUI();
      } else {
        showCharacterStats(id);
      }
    }

    function deleteSelectedCharacters() {
      if (selectedCharacterIndices.size > 0) {
        let totalGemsGained = 0; // Renommé pour clarté
        let totalCoinsGained = 0; // Renommé pour clarté
        const idsToDelete = Array.from(selectedCharacterIndices);
        let actualDeletedCount = 0;

        idsToDelete.forEach(id => {
          const index = ownedCharacters.findIndex(c => c.id === id);
          if (index === -1) return;

          const char = ownedCharacters[index];
          
          if (char.locked) {
            console.log(`Tentative de suppression du personnage verrouillé ${char.name} ignorée.`);
            return; 
          }

          let gemValue = 0;
          let coinValue = 0;

          switch (char.rarity) {
            case "Rare":
              gemValue = 10;
              coinValue = 5;
              break;
            case "Épique":
              gemValue = 50;
              coinValue = 15;
              break;
            case "Légendaire":
              gemValue = 100;
              coinValue = 30;
              break;
            case "Mythic":
              gemValue = 500;
              coinValue = 100;
              break;
            case "Secret": // Assumant que Secret donne aussi des ressources
              gemValue = 1000;
              coinValue = 200;
              break;
            default:
              gemValue = 1; // Fallback minimal
              coinValue = 1;
          }
          
          totalGemsGained += gemValue;
          totalCoinsGained += coinValue; // << CORRECTION ICI: Utiliser totalCoinsGained

          missions.forEach(mission => {
            if (!mission.completed) {
              if (mission.type === "sell_chars") mission.progress++;
              if (mission.type === "sell_rare_chars" && char.rarity === "Rare") mission.progress++;
            }
          });
          actualDeletedCount++;
        });

        // Filtrer ownedCharacters pour retirer ceux qui sont sélectionnés ET non verrouillés
        ownedCharacters = ownedCharacters.filter(char => {
            return !selectedCharacterIndices.has(char.id) || (selectedCharacterIndices.has(char.id) && char.locked);
        });

        if (actualDeletedCount > 0) {
            addGems(totalGemsGained); // Utilise la fonction addGems
            coins = Math.min(coins + totalCoinsGained, 10000000); // << CORRECTION ICI: Ajouter totalCoinsGained
            resultElement.innerHTML = `<p class="text-green-400">${actualDeletedCount} personnage(s) non verrouillé(s) supprimé(s) ! +${totalGemsGained} gemmes, +${totalCoinsGained} pièces</p>`;
        } else {
            resultElement.innerHTML = `<p class="text-yellow-400">Aucun personnage non verrouillé n'a été sélectionné pour la suppression.</p>`;
        }
        
        selectedCharacterIndices.clear();
        checkMissions();
        updateCharacterDisplay();
        updateIndexDisplay();
        updateUI();
        scheduleSave(); // Sauvegarder après modification de coins
      }
    }

    function buyItem(index) {
      const offer = shopOffers[index];
      if (!offer) return;

      if (purchasedOffers.includes(index)) {
        resultElement.innerHTML = '<p class="text-red-400">Cette offre a déjà été achetée !</p>';
        return;
      }

      if (offer.currency === 'gems' && gems < offer.cost) {
        resultElement.innerHTML = '<p class="text-red-400">Pas assez de gemmes !</p>';
        return;
      }
      if (offer.currency === 'coins' && coins < offer.cost) {
        resultElement.innerHTML = '<p class="text-red-400">Pas assez de pièces !</p>';
        return;
      }

      if (offer.currency === 'gems') {
        gems -= offer.cost;
      } else if (offer.currency === 'coins') {
        coins -= offer.cost;
        missions.forEach(mission => {
            if (mission.type === "spend_coins" && !mission.completed) {
                mission.progress += offer.cost;
            }
        });
      }

      purchasedOffers.push(index);
      localStorage.setItem("purchasedOffers", JSON.stringify(purchasedOffers));

      if (soundEnabled) buySound.play();
      missions.forEach(mission => {
        if (mission.type === "shop_purchase" && !mission.completed) {
          mission.progress++;
        }
      });

      switch (offer.type) {
        case 'gems':
            addGems(offer.amount); // Remplace gems += offer.amount
            resultElement.innerHTML = `<p class="text-green-400">Achat réussi ! +${Math.min(offer.amount, 1000000000 - gems)} gemmes</p>`;
            break;
        case 'exp-boost':
          expMultiplier = offer.amount;
          expBoostEndTime = Date.now() + 30 * 60 * 1000;
          setTimeout(() => {
            expMultiplier = 1;
            expBoostEndTime = 0;
            localStorage.setItem("expMultiplier", expMultiplier);
            localStorage.setItem("expBoostEndTime", expBoostEndTime);
            resultElement.innerHTML = `<p class="text-yellow-400">Boost EXP x${offer.amount} terminé !</p>`;
            updateUI();
            updateItemDisplay();
          }, 30 * 60 * 1000);
          resultElement.innerHTML = `<p class="text-green-400">Boost EXP x${offer.amount} activé pour 30 minutes !</p>`;
          break;
        case 'pull-ticket':
          pullTickets += offer.amount;
          inventory["Pass XP"] += offer.amount; // Mettre à jour l'inventaire
          resultElement.innerHTML = `<p class="text-green-400">Achat réussi ! +${offer.amount} ticket(s) de tirage</p>`;
          break;
        case 'special-character':
          const character = specialCharacters.find(char => char.name === (offer.description.includes("Sakura") ? "Sakura" : "Yuki-no-Kami"));
          const characterWithId = { ...char, id: `char_${characterIdCounter++}`, level: 1, exp: 0, locked: false, hasEvolved: false };
          ownedCharacters.unshift(characterWithId);
          updateCharacterDisplay();
          resultElement.innerHTML = `<p class="text-green-400">Personnage spécial ${character.name} débloqué !</p>`;
          break;
      }
      checkMissions();
      updateUI();
      updateShopDisplay();
      updateItemDisplay(); // Mettre à jour l'affichage de l'inventaire
      localStorage.setItem("characterIdCounter", characterIdCounter);
      scheduleSave();
    }

    function checkMissions() {
      missions.forEach(mission => {
        if (mission.progress >= mission.goal && !mission.completed) {
          mission.completed = true;
          addGems(mission.reward.gems); // Remplace gems += mission.reward.gems
          resultElement.innerHTML = `<p class="text-green-400">Mission "${mission.description}" complétée ! +${Math.min(mission.reward.gems, 1000000000 - gems)} gemmes</p>`;
        }
      });
      updateMissions();
      updateUI();
    }

    function canCharacterEvolve(char) {
      if (char.hasEvolved) return false;

      // Utiliser char.originalName si présent (après une première évolution), sinon char.name
      const baseNameToFind = char.originalName || char.name;
      const baseCharDef = allCharacters.find(c => c.name === baseNameToFind);

      if (!baseCharDef || !baseCharDef.evolutionRequirements || baseCharDef.evolutionRequirements.length === 0) {
          return false; // Pas de définition de base ou pas d'exigences d'évolution
      }

      // Vérifier les exigences par rapport à l'inventaire et aux pièces
      return baseCharDef.evolutionRequirements.every(req => {
          if (req.item) {
              return (inventory[req.item] || 0) >= req.quantity;
          } else if (req.coins) {
              return coins >= req.coins;
          }
          return true; // Pour d'autres types d'exigences futures
      });
    }

    function updateCharacterDisplay() {
      if (!ownedCharacters.length && !inventoryFilterName && inventoryFilterRarity === "all" && !inventoryFilterEvolvable && !inventoryFilterLimitBreak && !inventoryFilterCanReceiveExp) {
          characterDisplay.innerHTML = '<p class="text-white col-span-full text-center">Aucun personnage possédé.</p>'; // Modifié pour s'adapter à la grille
          return;
      }

      let filteredCharacters = [...ownedCharacters];

      // Appliquer les filtres
      if (inventoryFilterName) {
          filteredCharacters = filteredCharacters.filter(char =>
              (char.name || "").toLowerCase().includes(inventoryFilterName.toLowerCase())
          );
      }

      if (inventoryFilterRarity !== "all") {
          filteredCharacters = filteredCharacters.filter(char => char.rarity === inventoryFilterRarity);
      }

      if (inventoryFilterEvolvable) {
          filteredCharacters = filteredCharacters.filter(char => canCharacterEvolve(char));
      }

      if (inventoryFilterLimitBreak) {
          filteredCharacters = filteredCharacters.filter(char => {
              const currentMaxCap = char.maxLevelCap || 60;
              return char.level >= currentMaxCap && currentMaxCap < MAX_POSSIBLE_LEVEL_CAP;
          });
      }

      if (inventoryFilterCanReceiveExp) {
          filteredCharacters = filteredCharacters.filter(char => {
              const currentMaxCap = char.maxLevelCap || 60;
              return char.level < currentMaxCap;
          });
      }

      // Trier les personnages
      const sortedAndFilteredCharacters = filteredCharacters.sort((a, b) => {
            let primaryComparison = 0;
            // Tri principal basé sur sortCriteria (contrôlé par le sélecteur de l'inventaire)
            if (sortCriteria === "power") primaryComparison = (b.power || 0) - (a.power || 0);
            else if (sortCriteria === "rarity") primaryComparison = (rarityOrder[b.rarity] ?? -1) - (rarityOrder[a.rarity] ?? -1);
            else if (sortCriteria === "level") primaryComparison = (b.level || 0) - (a.level || 0);
            else if (sortCriteria === "name") primaryComparison = (a.name || "").localeCompare(b.name || "");
            // Si sortCriteria est "none" ou une autre valeur, primaryComparison restera 0

            if (primaryComparison !== 0) return primaryComparison;

            // Tri secondaire fixe pour la stabilité (par nom, ascendant) si le tri principal est égal
            // Ignorer la variable globale sortCriteriaSecondary pour l'inventaire ici.
            return (a.name || "").localeCompare(b.name || "");
        });

      if (!sortedAndFilteredCharacters.length) {
          characterDisplay.innerHTML = '<p class="text-white col-span-full text-center">Aucun personnage ne correspond à vos filtres.</p>'; // Modifié pour s'adapter à la grille
          return;
      }

      characterDisplay.innerHTML = sortedAndFilteredCharacters.map((char) => {
          const isSelected = selectedCharacterIndices.has(char.id);
          let rarityTextColorClass = char.color;
          if (char.rarity === "Mythic") rarityTextColorClass = "rainbow-text";
          else if (char.rarity === "Vanguard") rarityTextColorClass = "text-vanguard";
          else if (char.rarity === "Secret") rarityTextColorClass = "text-secret";
          // ... (autres if/else if pour couleurs de rareté)

          let statRankDisplayHtml = '';
          if (char.statRank && statRanks[char.statRank]) {
              statRankDisplayHtml = `<p class="text-center text-white text-xs">Stat: <span class="${statRanks[char.statRank].color || 'text-white'}">${char.statRank}</span></p>`;
          }

          let cardClasses = `relative p-2 rounded-lg border cursor-pointer`;
          let onclickAction = `showCharacterStats('${char.id}')`;

          if (isDeleteMode) {
              if (char.locked) {
                  cardClasses += ` ${getRarityBorderClass(char.rarity)} opacity-50 cursor-not-allowed`;
              } else {
                  cardClasses += ` ${isSelected ? 'selected-character' : getRarityBorderClass(char.rarity)}`;
                  onclickAction = `deleteCharacter('${char.id}')`;
              }
          } else {
              cardClasses += ` ${getRarityBorderClass(char.rarity)}`;
          }

          return `
          <div class="${cardClasses}" onclick="${onclickAction}">
              ${char.locked ? '<span class="absolute top-1 right-1 text-xl text-white bg-black bg-opacity-50 rounded p-1">🔒</span>' : ''}
              <img src="${char.image}" alt="${char.name}" class="w-full h-32 object-contain rounded">
              <p class="text-center text-white font-semibold mt-2 text-sm">${char.name}</p>
              <p class="text-center ${rarityTextColorClass} text-xs">${char.rarity}</p>
              <p class="text-center text-white text-xs">Niveau: ${char.level} / ${char.maxLevelCap || 60}</p>
              ${statRankDisplayHtml}
              <p class="text-center text-white text-xs">Puissance: ${char.power}</p>
          </div>
          `;
      }).join("");
    }

    function updateCharacterSelectionDisplay() {
      characterSelectionList.innerHTML = "";
      const currentMaxTeamSize = calculateMaxTeamSize();

      const modalTitle = document.getElementById("character-selection-title");
      if (modalTitle) {
          modalTitle.textContent = `Sélectionner ${currentMaxTeamSize} Personnage(s) pour le Combat`;
      }

      // Restaurer les valeurs des filtres depuis les variables globales
      const searchNameInput = document.getElementById("battle-search-name");
      const filterRaritySelect = document.getElementById("battle-filter-rarity");
      if (searchNameInput) searchNameInput.value = battleSearchName;
      if (filterRaritySelect) filterRaritySelect.value = battleFilterRarity;

      let charactersToDisplay = [...ownedCharacters];

      // Appliquer le filtre par nom (utilise la variable globale battleSearchName)
      if (battleSearchName) {
          charactersToDisplay = charactersToDisplay.filter(char => char.name.toLowerCase().includes(battleSearchName));
      }

      // Appliquer le filtre par rareté (utilise la variable globale battleFilterRarity)
      if (battleFilterRarity !== "all") {
          charactersToDisplay = charactersToDisplay.filter(char => char.rarity === battleFilterRarity);
      }

      const sortedCharacters = charactersToDisplay.sort((a, b) => {
        if (battleSortCriteria === "power") { // <--- CORRIGÉ
          return (b.power || 0) - (a.power || 0);
        } else if (battleSortCriteria === "rarity") { // <--- CORRIGÉ
          const rarityAValue = rarityOrder[a.rarity] ?? -1;
          const rarityBValue = rarityOrder[b.rarity] ?? -1;
          return rarityBValue - rarityAValue;
        } else if (battleSortCriteria === "level") { // <--- CORRIGÉ
          return (b.level || 0) - (a.level || 0);
        } else if (battleSortCriteria === "name") { // <--- AJOUTÉ POUR COHÉRENCE
          return (a.name || "").localeCompare(b.name || "");
        }
        return 0;
      });

      const selectedCharacterNames = new Set();
      for (const selectedIdx of selectedBattleCharacters) {
          if(ownedCharacters[selectedIdx]) {
              selectedCharacterNames.add(ownedCharacters[selectedIdx].name);
          }
      }
      
      if (sortedCharacters.length === 0) {
          characterSelectionList.innerHTML = `<p class="text-white col-span-full text-center">Aucun personnage ne correspond à vos filtres.</p>`;
      } else {
          sortedCharacters.forEach((char) => {
              const originalIndex = ownedCharacters.findIndex(c => c.id === char.id);
              if (originalIndex === -1) return;

              const charElement = document.createElement("div");

              let isCurrentlySelected = selectedBattleCharacters.has(originalIndex);
              let isSelectable = true;
              let additionalClasses = "";

              if (!isCurrentlySelected && selectedBattleCharacters.size < currentMaxTeamSize) {
                  if (selectedCharacterNames.has(char.name)) {
                      isSelectable = false;
                      additionalClasses = "non-selectable-for-battle";
                  }
              } else if (!isCurrentlySelected && selectedBattleCharacters.size >= currentMaxTeamSize) {
                  isSelectable = false;
                  additionalClasses = "opacity-50";
              }

              let rarityTextClass = char.color;
              if (char.rarity === "Mythic") rarityTextClass = "rainbow-text";
              else if (char.rarity === "Secret") rarityTextClass = "text-secret";
              else if (char.rarity === "Vanguard") rarityTextClass = "text-vanguard";

              charElement.className = `bg-gray-800 bg-opacity-50 p-4 rounded-lg transition transform hover:scale-105 cursor-pointer border-2 ${getRarityBorderClass(char.rarity)} ${
                  isCurrentlySelected ? 'selected-for-battle' : ''
              } ${additionalClasses}`;
              
              charElement.innerHTML = `
                <img src="${char.image}" alt="${char.name}" class="w-full h-32 object-cover rounded mb-2">
                <p class="${rarityTextClass} font-semibold">${char.name} (<span class="${rarityTextClass}">${char.rarity}</span>, Niv. ${char.level})</p>
                <p class="text-white">Puissance: ${char.power}</p> 
              `;
              
              if (isSelectable || isCurrentlySelected) {
                  charElement.addEventListener("click", () => {
                      selectBattleCharacter(originalIndex);
                  });
              }
              
              characterSelectionList.appendChild(charElement);
          });
      }

      selectedCountElement.textContent = `${selectedBattleCharacters.size}/${currentMaxTeamSize}`;
      confirmSelectionButton.disabled = selectedBattleCharacters.size !== currentMaxTeamSize;
      confirmSelectionButton.classList.toggle("opacity-50", selectedBattleCharacters.size !== currentMaxTeamSize);
      confirmSelectionButton.classList.toggle("cursor-not-allowed", selectedBattleCharacters.size !== currentMaxTeamSize);
      
      const battleSortCriteriaSelect = document.getElementById("battle-sort-criteria");
      if (battleSortCriteriaSelect) battleSortCriteriaSelect.value = battleSortCriteria;
    }

    function selectBattleCharacter(index) {
      const characterToAdd = ownedCharacters[index];
      let currentMaxTeamSize = calculateMaxTeamSize();

      if (selectedBattleCharacters.has(index)) {
          selectedBattleCharacters.delete(index);
      } else {
          // Recalculer la taille max *potentielle* si ce personnage était ajouté
          let potentialSelected = new Set(selectedBattleCharacters);
          potentialSelected.add(index);
          let potentialMaxTeamSize = 3;
          let potentialBonus = 0;
          potentialSelected.forEach(idx => {
              const char = ownedCharacters[idx];
              if (char && char.passive && typeof char.passive.teamSizeBonus === 'number') {
                  potentialBonus = Math.max(potentialBonus, char.passive.teamSizeBonus);
              }
          });
          potentialMaxTeamSize += potentialBonus;

          if (selectedBattleCharacters.size < potentialMaxTeamSize) { // Vérifier par rapport à la taille potentielle
              let alreadySelectedSameName = false;
              for (const selectedIndex of selectedBattleCharacters) {
                  if (ownedCharacters[selectedIndex].name === characterToAdd.name) {
                      alreadySelectedSameName = true;
                      break;
                  }
              }
              if (!alreadySelectedSameName) {
                  selectedBattleCharacters.add(index);
              } else {
                  // console.log(`Personnage ${characterToAdd.name} déjà sélectionné.`);
              }
          }
      }
      updateCharacterSelectionDisplay(); // Ceci va recalculer et réafficher avec la bonne taille max
    }

    function cancelSelection() {
      selectedBattleCharacters.clear();
      characterSelectionModal.classList.add("hidden");
      updateLevelDisplay();
      disableNoScroll();
      updateCharacterSelectionDisplay();
    }

    function startFusion(id) {
      console.log("startFusion appelé avec id:", id);

      // 1. Trouver le personnage d'abord
      const char = ownedCharacters.find(c => c.id === id);
      if (!char) { // S'assurer que le personnage existe
        console.log("Personnage non trouvé pour id:", id);
        resultElement.innerHTML = '<p class="text-red-400">Personnage non trouvé !</p>';
        return;
      }

      // 2. Vérifier le niveau maximum APRÈS avoir trouvé le personnage
      if (char.level >= (char.maxLevelCap || 60)) {
        resultElement.innerHTML = `<p class="text-red-400">${char.name} est déjà à son niveau maximum actuel (${char.maxLevelCap || 60}) et ne peut pas être fusionné !</p>`;
        return;
      }

      // 3. Vérifier s'il y a assez de personnages pour une fusion
      if (ownedCharacters.filter(c => c.id !== currentFusionCharacterId && !c.locked).length < 1 && ownedCharacters.length <=1 ) { // Vérifie s'il y a au moins un autre perso non lock à fusionner
        resultElement.innerHTML = '<p class="text-red-400">Pas assez d\'autres personnages (non verrouillés) pour fusionner !</p>';
        return;
      }


      currentFusionCharacterId = id;
      selectedFusionCharacters.clear();
      statsModal.classList.add("hidden"); // Fermer la modale stats si elle était ouverte
      fusionModal.classList.remove("hidden");
      enableNoScroll(); // Assurer la gestion correcte du scroll

      console.log("Personnage principal pour fusion:", char.name);

      // Assigner directement les gestionnaires d'événements pour éviter l'accumulation
      // et s'assurer qu'ils pointent vers les bonnes fonctions.
      // Pas besoin de removeEventListener si on assigne directement à onclick.
      const confirmBtn = document.getElementById("confirm-fusion");
      const cancelBtn = document.getElementById("cancel-fusion");

      confirmBtn.onclick = () => {
        console.log("Bouton Confirmer Fusion cliqué");
        confirmFusion();
      };
      cancelBtn.onclick = () => {
        console.log("Bouton Annuler Fusion cliqué");
        cancelFusion();
      };

      updateFusionSelectionDisplay();
    }

    function updateFusionSelectionDisplay() {
      fusionSelectionList.innerHTML = "";
      // Filtrez les personnages non verrouillés et différents du personnage principal
      const availableForFusion = ownedCharacters.filter(char => char.id !== currentFusionCharacterId && !char.locked); 

      availableForFusion.forEach((char) => { // Utilisez la liste filtrée
        // if (char.id === currentFusionCharacterId) return; // Ce check est déjà fait par le filter
        const charElement = document.createElement("div");
        charElement.className = `bg-gray-800 bg-opacity-50 p-4 rounded-lg transition transform hover:scale-105 cursor-pointer border-2 ${getRarityBorderClass(char.rarity)} ${
          selectedFusionCharacters.has(char.id) ? 'selected-for-fusion' : ''
        }`;
        charElement.innerHTML = `
          <img src="${char.image}" alt="${char.name}" class="w-full h-32 object-cover rounded mb-2">
          <p class="${char.color} font-semibold">${char.name} (<span class="${char.rarity === 'Mythic' ? 'rainbow-text' : ''}">${char.rarity}</span>, Niv. ${char.level})</p>
          <p class="text-white">Puissance: ${char.power}</p>
        `;
        charElement.addEventListener("click", () => {
          console.log("Clic sur personnage pour fusion, id:", char.id);
          selectFusionCharacter(char.id);
        });
        fusionSelectionList.appendChild(charElement);
      });

      if (availableForFusion.length === 0) {
         fusionSelectionList.innerHTML = '<p class="text-gray-400 col-span-full">Aucun personnage non verrouillé disponible pour la fusion.</p>';
      }

      fusionSelectedCountElement.textContent = selectedFusionCharacters.size;
      confirmFusionButton.disabled = selectedFusionCharacters.size === 0;
      confirmFusionButton.classList.toggle("opacity-50", selectedFusionCharacters.size === 0);
      confirmFusionButton.classList.toggle("cursor-not-allowed", selectedFusionCharacters.size === 0);
    }

    function selectFusionCharacter(id) {
      console.log("selectFusionCharacter appelé avec id:", id);
      if (selectedFusionCharacters.has(id)) {
        selectedFusionCharacters.delete(id);
      } else {
        selectedFusionCharacters.add(id);
      }
      console.log("selectedFusionCharacters après mise à jour:", Array.from(selectedFusionCharacters));
      updateFusionSelectionDisplay();
    }

    function cancelFusion() {
      console.log("cancelFusion appelé");
      selectedFusionCharacters.clear();
      fusionModal.classList.add("hidden");
      document.body.classList.remove("no-scroll");
      updateCharacterDisplay();
    }

    function confirmFusion() {
      console.log("confirmFusion appelé");
      if (selectedFusionCharacters.size === 0) {
        console.log("Aucun personnage sélectionné pour la fusion");
        return;
      }
      const mainChar = ownedCharacters.find(c => c.id === currentFusionCharacterId);
      if (!mainChar) {
        console.log("Personnage principal non trouvé, currentFusionCharacterId:", currentFusionCharacterId);
        resultElement.innerHTML = '<p class="text-red-400">Personnage principal non trouvé !</p>';
        fusionModal.classList.add("hidden");
        document.body.classList.remove("no-scroll");
        return;
      }
      if (mainChar.level >= 100) {
        console.log("Personnage au niveau maximum");
        resultElement.innerHTML = '<p class="text-red-400">Ce personnage est déjà au niveau maximum (100) !</p>';
        fusionModal.classList.add("hidden");
        document.body.classList.remove("no-scroll");
        return;
      }

      const expByRarity = {
        Rare: 25,
        Épique: 50,
        Légendaire: 100,
        Mythic: 200,
        Secret: 300
      };
      let totalExpGained = 0;
      const fusionSummary = {};
      const idsToDelete = Array.from(selectedFusionCharacters);
      idsToDelete.forEach(id => {
        const char = ownedCharacters.find(c => c.id === id);
        if (!char) {
          console.log("Personnage à fusionner non trouvé, id:", id);
          return;
        }
        const expGained = expByRarity[char.rarity] || 25;
        totalExpGained += expGained;
        fusionSummary[char.rarity] = (fusionSummary[char.rarity] || 0) + 1;
      });

      mainChar.basePower += 10;
      addCharacterExp(mainChar, totalExpGained);

      ownedCharacters = ownedCharacters.filter(c => !selectedFusionCharacters.has(c.id));

      missions.forEach(mission => {
          if (mission.type === "fuse_chars" && !mission.completed) {
              mission.progress += idsToDelete.length;
          }
      });

      missions.forEach(mission => {
          if (mission.type === "fuse_chars" && !mission.completed) {
              mission.progress += charactersToFuse.length;
          }
      });

      addExp(totalExpGained);

      const summaryText = Object.entries(fusionSummary)
        .map(([rarity, count]) => `${count} ${rarity} (+${count * expByRarity[rarity]} EXP)`)
        .join(", ");
      resultElement.innerHTML = `
        <p class="text-green-400">Fusion réussie pour ${mainChar.name} !</p>
        <p class="text-white">Puissance augmentée à ${mainChar.power}</p>
        <p class="text-white">${idsToDelete.length} personnage(s) fusionné(s): ${summaryText}</p>
        <p class="text-white">Total +${totalExpGained} EXP gagné pour ${mainChar.name} et le joueur</p>
      `;
      selectedFusionCharacters.clear();
      fusionModal.classList.add("hidden");
      document.body.classList.remove("no-scroll");
      updateCharacterDisplay();
      updateUI();
      scheduleSave();
    }

    function loadOrGenerateStandardBanner() {
        const savedBannerJSON = localStorage.getItem("currentStandardBanner");
        let savedBanner = null;

        if (savedBannerJSON) {
            try {
                savedBanner = JSON.parse(savedBannerJSON);
            } catch (e) {
                console.error("Erreur lors du parsing de la bannière Mythic sauvegardée:", e);
                savedBanner = null;
            }
        }

        let shouldRegenerate = !savedBanner; // Régénérer s'il n'y a pas de bannière sauvegardée

        if (savedBanner && !shouldRegenerate) { // Si une bannière est sauvegardée et qu'on ne doit pas déjà régénérer
            const mythicConfig = BANNER_CONFIG.Mythic;
            // Vérifier la validité de la structure de la bannière
            if (!savedBanner.Mythic || !Array.isArray(savedBanner.Mythic) || savedBanner.Mythic.length !== mythicConfig.numFeatured) {
                console.warn(`Bannière Mythic sauvegardée invalide (structure). Régénération.`);
                shouldRegenerate = true;
            } else {
                for (const charName of savedBanner.Mythic) {
                    const charExists = standardCharacters.find(c => c.name === charName && c.rarity === "Mythic");
                    if (!charExists) {
                        console.warn(`Mythic en vedette "${charName}" n'existe plus ou a une rareté différente. Régénération.`);
                        shouldRegenerate = true;
                        break;
                    }
                }
            }

            // Vérifier l'âge de la bannière si elle est toujours considérée valide structurellement
            if (!shouldRegenerate && savedBanner.generatedAt) {
                if (Date.now() - savedBanner.generatedAt > TWO_HOURS_MS) {
                    console.log("La bannière Mythic sauvegardée a plus de 2 heures. Régénération.");
                    shouldRegenerate = true;
                }
            } else if (!savedBanner.generatedAt) { // Si pas de timestamp, régénérer par sécurité
                 console.warn("Bannière Mythic sauvegardée n'a pas de timestamp 'generatedAt'. Régénération.");
                 shouldRegenerate = true;
            }
        }


        if (shouldRegenerate) {
            console.log("Génération des Mythics en vedette.");
            generateNewStandardBanner();
        } else {
            currentStandardBanner = savedBanner;
            console.log("Mythics en vedette chargés depuis localStorage:", currentStandardBanner);
        }
        updateProbabilitiesDisplay();
    }

    function generateNewStandardBanner() {
        const newBannerData = { Mythic: [], generatedAt: Date.now() }; // Mettre à jour le timestamp
        const mythicConfig = BANNER_CONFIG.Mythic;
        const allMythicChars = standardCharacters.filter(char => char.rarity === "Mythic");

        if (allMythicChars.length < mythicConfig.numFeatured) {
            console.warn(`Pas assez de Mythics (${allMythicChars.length}) pour en mettre ${mythicConfig.numFeatured} en vedette. Utilisation de tous.`);
            newBannerData.Mythic = allMythicChars.map(char => char.name);
        } else {
            const shuffled = [...allMythicChars].sort(() => 0.5 - Math.random());
            newBannerData.Mythic = shuffled.slice(0, mythicConfig.numFeatured).map(char => char.name);
        }
        
        currentStandardBanner = newBannerData;
        localStorage.setItem("currentStandardBanner", JSON.stringify(currentStandardBanner));
        console.log("Nouveaux Mythics en vedette générés et sauvegardés:", currentStandardBanner);
    }

    // Optionnel: Mettre à jour la bannière périodiquement si le jeu reste ouvert
    // Cela n'est pas strictement nécessaire si l'actualisation au chargement suffit.
    // Si vous voulez une mise à jour "en direct" sans recharger la page:
    /*
    setInterval(() => {
        if (currentStandardBanner.generatedAt && (Date.now() - currentStandardBanner.generatedAt > TWO_HOURS_MS)) {
            console.log("Mise à jour automatique de la bannière (jeu ouvert depuis > 2h sans refresh de bannière).");
            generateNewStandardBanner();
            updateProbabilitiesDisplay();
            // Informer potentiellement l'utilisateur que la bannière a changé
            const resultElement = document.getElementById("result"); // S'assurer que resultElement est accessible
            if (resultElement) { // Vérifier si resultElement existe avant de l'utiliser
                 resultElement.innerHTML = '<p class="text-yellow-400">La sélection de personnages en vedette a été mise à jour !</p>';
                 setTimeout(() => {
                    if (resultElement.innerHTML.includes("personnages en vedette a été mise à jour")) {
                         resultElement.innerHTML = '<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>';
                    }
                 }, 5000);
            }
        }
    }, 5 * 60 * 1000); // Vérifier toutes les 5 minutes, par exemple
    */



    // Variable globale pour la largeur de la barre de défilement
    let scrollbarWidth = 0;
    let isNoScrollActive = false;

    // Calculer la largeur de la barre de défilement
    function calculateScrollbarWidth() {
      const outer = document.createElement("div");
      outer.style.visibility = "hidden";
      outer.style.overflow = "scroll";
      outer.style.width = "100px";
      outer.style.position = "absolute";
      outer.style.top = "-9999px";
      document.body.appendChild(outer);
      const inner = document.createElement("div");
      inner.style.width = "100%";
      outer.appendChild(inner);
      scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
      document.body.removeChild(outer);
      return scrollbarWidth || 15;
    }

    // Calculer au chargement
    document.addEventListener("DOMContentLoaded", () => {
      scrollbarWidth = calculateScrollbarWidth();
      console.log("Largeur de la barre de défilement calculée:", scrollbarWidth);
    });

        // Gérer no-scroll
    function enableNoScroll() {
      if (isNoScrollActive) return;
      document.body.classList.add("no-scroll");
      // document.body.style.paddingRight = `${scrollbarWidth}px`; // Ligne commentée/supprimée
      isNoScrollActive = true;
      console.log("no-scroll activé (overflow: hidden appliqué au body)"); // Log optionnel mis à jour
    }

    function disableNoScroll() {
      if (!isNoScrollActive) return;
      document.body.classList.remove("no-scroll");
      // document.body.style.paddingRight = ""; // Ligne commentée/supprimée
      isNoScrollActive = false;
      console.log("no-scroll désactivé (overflow: hidden retiré du body)"); // Log optionnel mis à jour
    }

    // Modale "Donner des objets"
    function startGiveItems(id) {
      console.log("startGiveItems appelé avec id:", id);
      const char = ownedCharacters.find(c => c.id === id);
      if (!char) { // AJOUT: Vérifier si le personnage est au max de son cap actuel
        console.log("Personnage non trouvé pour id:", id);
        resultElement.innerHTML = '<p class="text-red-400">Personnage non trouvé !</p>';
        return;
      }
      const currentCharacterMaxLevel = char.maxLevelCap || 60;
      const isMaxLevel = char.level >= currentCharacterMaxLevel;
      const hasPowerItem = Object.entries(inventory).some(([item, quantity]) => quantity > 0 && itemEffects[item]?.power);

      if (isMaxLevel && !hasPowerItem) {
        resultElement.innerHTML = `<p class="text-red-400">${char.name} est à son niveau maximum actuel (${currentCharacterMaxLevel}) et vous n'avez pas d'objets augmentant la puissance à lui donner.</p>`;
        return; // Ne pas ouvrir la modale
      }
      currentGiveItemsCharacterId = id;
      selectedItemsForGiving.clear();
      statsModal.classList.add("hidden");
      giveItemsModal.classList.remove("hidden");
      enableNoScroll();
      updateItemSelectionDisplay();
    }

    function cancelGiveItems() {
      console.log("cancelGiveItems appelé");
      selectedItemsForGiving.clear();
      giveItemsModal.classList.add("hidden");
      disableNoScroll();
      updateItemDisplay();
    }

    function updateItemSelectionDisplay() {
      itemSelectionList.innerHTML = "";
      const itemImages = {
        "Haricots": "https://static.wikia.nocookie.net/animeadventures/images/6/6c/Senzu_Bean.png/revision/latest?cb=20230101141509",
        "Fluide mystérieux": "https://static.wikia.nocookie.net/animeadventures/images/7/72/Mysterious_Fluid.png/revision/latest?cb=20230101141428",
        "Wisteria Flower": "https://static.wikia.nocookie.net/animeadventures/images/9/95/Wisteria_Flower.png/revision/latest/scale-to-width-down/115?cb=20230101141611",
        "Ramen Bowl": "https://static.wikia.nocookie.net/animeadventures/images/f/fd/Ramen_Bowl.png/revision/latest/scale-to-width-down/115?cb=20230101142002",
        "Ghoul Coffee": "https://static.wikia.nocookie.net/animeadventures/images/d/d4/Ghoul_Coffee.png/revision/latest/scale-to-width-down/115?cb=20230101141346",
        "Soul Candy": "https://static.wikia.nocookie.net/animeadventures/images/3/3c/Soul_Candy.png/revision/latest/scale-to-width-down/115?cb=20230101141254",
        "Cooked Fish": "https://static.wikia.nocookie.net/animeadventures/images/f/f6/Cooked_Fish.png/revision/latest/scale-to-width-down/115?cb=20230101141820",
        "Magical Artifact": "https://static.wikia.nocookie.net/animeadventures/images/0/05/Magical_Artifact.png/revision/latest/scale-to-width-down/115?cb=20230101142122",
        "Magic Pendant": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/5/50/Magic_Pendant.png/revision/latest/scale-to-width-down/200?cb=20241228183321",
        "Crystal": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/3/31/Crystal.png/revision/latest/scale-to-width-down/200?cb=20241108234506",
        "Chocolate Bar's": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/e/ea/Chocolate_Bar%27s.png/revision/latest/scale-to-width-down/200?cb=20250507164414",
        "Curse Talisman": "https://static.wikia.nocookie.net/animeadventures/images/e/eb/Curse_Talisman.png/revision/latest/scale-to-width-down/115?cb=20230101141854",
        "Pièces": "https://via.placeholder.com/150?text=Pièces",
        "Stat Chip": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d4/Stat_Chip.png/revision/latest/scale-to-width-down/200?cb=20240925095125",
        "Tickets de Tirage": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/3/35/Pass_XP.png/revision/latest/scale-to-width-down/200?cb=20240912054111",
        "Cursed Token": "https://via.placeholder.com/150?text=Fragments",
        "Shadow Tracer": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/11/Shadow_Trace.png/revision/latest/scale-to-width-down/200?cb=20240925095144",
        "Blood-Red Armor": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/4/42/Blood-Red_Armor.png/revision/latest/scale-to-width-down/200?cb=20240925095521",
        "Head Captain's Coat": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/7/76/Head_Captain%27s_Coat.png/revision/latest/scale-to-width-down/200?cb=20250301094746",
        "Magic Stone": "https://static.wikia.nocookie.net/animeadventures/images/6/63/Magic_Stone.png/revision/latest/scale-to-width-down/115?cb=20230101141650",
        "Stone Pendant": "https://static.wikia.nocookie.net/animeadventures/images/f/f7/Stone_Pendant.png/revision/latest/scale-to-width-down/115?cb=20230101141922",
        "Alien Core": "https://static.wikia.nocookie.net/animeadventures/images/e/e9/Alien_Core.png/revision/latest?cb=20230129102904",
        "Tavern Piece": "https://static.wikia.nocookie.net/animeadventures/images/c/cc/Tavern_Pie.png/revision/latest?cb=20230606150016",
        "Plume Céleste": "https://png.pngtree.com/png-vector/20250517/ourlarge/pngtree-vibrant-and-detailed-feather-on-white-background-png-image_16308203.png",
        "Sablier Ancien": "https://static.wikia.nocookie.net/animeadventures/images/5/5f/Miracle_Timepiece.png/revision/latest?cb=20221119040302",
        // Ajoutez d'autres images d'objets si nécessaire
      };

      Object.entries(inventory)
        .filter(([item, quantity]) => quantity > 0 && itemEffects[item])
        .forEach(([item, quantity]) => {
          const itemElement = document.createElement("div");
          const selectedQuantity = selectedItemsForGiving.get(item) || 0;
          // Remplace les espaces par des tirets pour un ID HTML valide
          const itemIdSanitized = item.replace(/\s+/g, '-').replace(/[^a-zA-Z0-9-]/g, '');


          itemElement.className = `bg-gray-800 bg-opacity-50 p-4 rounded-lg transition transform hover:scale-105 border-2 border-gray-400 ${
            selectedQuantity > 0 ? 'selected-for-giving' : ''
          }`;
          itemElement.innerHTML = `
            <img src="${itemImages[item] || 'https://via.placeholder.com/150?text=Item'}" alt="${item}" class="w-full h-24 object-contain rounded mb-1">
            <p class="text-white font-semibold">${item}</p>
            <p class="text-white">Disponible: ${quantity}</p>
            <p class="text-white">Sélectionné: <span id="selected-qty-${itemIdSanitized}">${selectedQuantity}</span></p>
            <div class="mt-2">
              <input type="range" min="0" max="${quantity}" value="${selectedQuantity}" class="w-full item-slider cursor-pointer" data-item="${item}" data-item-id-sanitized="${itemIdSanitized}">
            </div>
          `;
          itemSelectionList.appendChild(itemElement);
        });

      // Mettre à jour le compteur total et l'état du bouton de confirmation initialement
      const totalSelectedInitial = Array.from(selectedItemsForGiving.values()).reduce((sum, qty) => sum + qty, 0);
      itemSelectedCountElement.textContent = totalSelectedInitial;

      const allInitiallyZero = Array.from(selectedItemsForGiving.values()).every(v => v === 0);
      const nothingInitiallySelected = selectedItemsForGiving.size === 0 || allInitiallyZero;
      confirmGiveItemsButton.disabled = nothingInitiallySelected;
      confirmGiveItemsButton.classList.toggle("opacity-50", nothingInitiallySelected);
      confirmGiveItemsButton.classList.toggle("cursor-not-allowed", nothingInitiallySelected);


      // Attacher les écouteurs d'événements pour les sliders
      document.querySelectorAll(".item-slider").forEach(slider => {
        slider.addEventListener("input", (event) => {
          const item = event.target.dataset.item;
          const itemIdSanitized = event.target.dataset.itemIdSanitized;
          const newQuantity = parseInt(event.target.value, 10);

          const selectedQtySpan = document.getElementById(`selected-qty-${itemIdSanitized}`);
          if (selectedQtySpan) {
            selectedQtySpan.textContent = newQuantity;
          }

          if (newQuantity === 0) {
            selectedItemsForGiving.delete(item);
          } else {
            selectedItemsForGiving.set(item, newQuantity);
          }

          // Mettre à jour le compteur total
          itemSelectedCountElement.textContent = Array.from(selectedItemsForGiving.values()).reduce((sum, qty) => sum + qty, 0);

          // Mettre à jour l'état du bouton de confirmation
          const allZero = Array.from(selectedItemsForGiving.values()).every(v => v === 0);
          const nothingSelected = selectedItemsForGiving.size === 0 || allZero;

          confirmGiveItemsButton.disabled = nothingSelected;
          confirmGiveItemsButton.classList.toggle("opacity-50", nothingSelected);
          confirmGiveItemsButton.classList.toggle("cursor-not-allowed", nothingSelected);

          // Mettre à jour le style de la bordure de la carte de l'objet
          const itemCard = slider.closest('div.bg-gray-800');
          if (itemCard) {
            if (newQuantity > 0) {
              itemCard.classList.add('selected-for-giving');
            } else {
              itemCard.classList.remove('selected-for-giving');
            }
          }
        });
      });
    }

    function cancelGiveItems() {
      console.log("cancelGiveItems appelé");
      selectedItemsForGiving.clear();
      giveItemsModal.classList.add("hidden");
      document.body.classList.remove("no-scroll");
      updateItemDisplay();
    }

    function confirmGiveItems() {
      console.log("confirmGiveItems appelé");
      if (selectedItemsForGiving.size === 0) {
        console.log("Aucun objet sélectionné pour donner");
        return;
      }
      const char = ownedCharacters.find(c => c.id === currentGiveItemsCharacterId);
      if (!char) {
        // ... (message d'erreur existant)
        return;
      }

      let totalExpGained = 0;
      let totalPowerGained = 0;
      const summary = [];
      // --- MODIFIÉ : Vérifier si le personnage peut encore gagner de l'EXP basé sur son maxLevelCap ---
      const canGainExp = char.level < (char.maxLevelCap || 60);

      selectedItemsForGiving.forEach((quantity, item) => {
        const effect = itemEffects[item];
        let itemSummary = `${quantity} ${item} (`;
        let effectsApplied = [];

        // --- MODIFICATION : Ajouter l'EXP seulement si possible ---
        if (effect.exp && canGainExp) {
          totalExpGained += effect.exp * quantity;
          effectsApplied.push(`+${effect.exp * quantity} EXP`);
        } else if (effect.exp && !canGainExp) {
          effectsApplied.push(`EXP ignoré (Niv. Max)`);
        }
        // --- FIN MODIFICATION ---

        if (effect.power) {
          totalPowerGained += effect.power * quantity;
          effectsApplied.push(`+${effect.power * quantity} Puissance`);
        }
        inventory[item] -= quantity;
        itemSummary += effectsApplied.join(', ') + ')';
        summary.push(itemSummary);
      });

      // Appeler addCharacterExp seulement si de l'EXP a été calculée et si nécessaire
      if (totalExpGained > 0) {
         addCharacterExp(char, totalExpGained); // La fonction gère le cap interne
      }
      if (totalPowerGained > 0) {
            char.basePower += totalPowerGained; // MODIFIÉ: Affecte basePower
            recalculateCharacterPower(char);  // MODIFIÉ: Recalculer
        }

      // --- MODIFICATION : Message de résultat plus précis ---
      resultElement.innerHTML = `
        <p class="text-green-400">Objets donnés à ${char.name} (Niv. ${char.level}) !</p>
        ${totalExpGained > 0 ? `<p class="text-white">EXP ajoutée: ${totalExpGained}</p>` : (selectedItemsForGiving.has(item => itemEffects[item]?.exp) && !canGainExp ? `<p class="text-yellow-400">EXP des objets ignorée (Niveau Max atteint).</p>` : '')}
        ${totalPowerGained > 0 ? `<p class="text-white">Puissance augmentée à ${char.power}</p>` : ''}
        <p class="text-white">Objets utilisés: ${summary.join(", ")}</p>
      `;
      // --- FIN MODIFICATION ---

      selectedItemsForGiving.clear();
      giveItemsModal.classList.add("hidden");
      disableNoScroll();
      updateCharacterDisplay();
      updateItemDisplay();
      updateUI();
      scheduleSave();
    }

    function updateLimitBreakTabDisplay() {
      console.log("--- updateLimitBreakTabDisplay ---");

      // Vérification des éléments DOM essentiels
      if (!transcendenceOrbCountElement) {
          console.error("ERREUR: transcendenceOrbCountElement est null! L'élément HTML avec l'ID 'transcendence-orb-count' est manquant ou non chargé.");
          // Vous pourriez afficher un message d'erreur dans l'onglet lui-même si c'est critique
          if (limitBreakElement) limitBreakElement.innerHTML = "<p class='text-red-500'>Erreur: Impossible d'afficher le compteur d'orbes.</p>";
          return;
      }
      if (!limitBreakSelectedCharDisplayElement) {
          console.error("ERREUR: limitBreakSelectedCharDisplayElement est null!");
          return;
      }
      if (!limitBreakCharSelectionGridElement) {
          console.error("ERREUR: limitBreakCharSelectionGridElement est null!");
          return;
      }
      if (!applyLimitBreakButton) {
          console.error("ERREUR: applyLimitBreakButton est null!");
          return;
      }
      if (!inventory) {
          console.error("ERREUR: L'objet inventory n'est pas défini !");
          transcendenceOrbCountElement.textContent = "Erreur";
          return;
      }


      transcendenceOrbCountElement.textContent = inventory["Divin Wish"] || 0;
      const searchInput = document.getElementById("limit-break-char-search"); // Peut être null si l'ID est incorrect ou l'élément n'est pas dans l'onglet
      const searchTerm = searchInput ? searchInput.value.toLowerCase() : "";

      let char = null;
      if (currentLimitBreakCharacterId) {
          char = ownedCharacters.find(c => c.id === currentLimitBreakCharacterId);
      }

      if (char) {
          const currentCharacterMaxLevel = char.maxLevelCap || 60;
          limitBreakSelectedCharDisplayElement.innerHTML = `
              <div class="bg-gray-800 bg-opacity-50 p-3 rounded-lg border-2 ${getRarityBorderClass(char.rarity)} w-full max-w-xs mx-auto">
                  <img src="${char.image}" alt="${char.name}" class="w-full h-28 object-contain rounded mb-1">
                  <p class="${char.color} font-semibold text-center text-sm">${char.name} (${char.rarity})</p>
                  <p class="text-white text-center text-xs">Niveau: ${char.level} / ${currentCharacterMaxLevel}</p>
                  <p class="text-white text-center text-xs">Puissance: ${char.power}</p>
                  ${currentCharacterMaxLevel >= MAX_POSSIBLE_LEVEL_CAP ? '<p class="text-center text-yellow-400 text-xs font-bold">Cap Max Atteint!</p>' : ''}
              </div>
          `;
      } else {
          limitBreakSelectedCharDisplayElement.innerHTML = '<p class="text-gray-400">Aucun personnage sélectionné.</p>';
      }

      limitBreakCharSelectionGridElement.innerHTML = "";
      const availableCharacters = ownedCharacters.filter(c => c.name.toLowerCase().includes(searchTerm));

      if (availableCharacters.length === 0) {
          limitBreakCharSelectionGridElement.innerHTML = `<p class="text-gray-400 col-span-full">${searchTerm ? 'Aucun personnage trouvé pour "' + searchTerm + '".' : 'Aucun personnage.'}</p>`;
      } else {
          availableCharacters.sort((a, b) => b.power - a.power).forEach(c => {
              const charElement = document.createElement("div");
              const currentMax = c.maxLevelCap || 60;
              const isAtCurrentCap = c.level >= currentMax;
              const canBreakLimit = isAtCurrentCap && currentMax < MAX_POSSIBLE_LEVEL_CAP && (inventory["Divin Wish"] || 0) >= LIMIT_BREAK_COST;

              charElement.className = `bg-gray-800 bg-opacity-50 p-2 rounded-lg transition transform hover:scale-105 cursor-pointer border-2
                  ${currentLimitBreakCharacterId === c.id ? 'border-amber-500' : (getRarityBorderClass(c.rarity) || 'border-gray-600 hover:border-gray-500')}
                  ${!isAtCurrentCap && currentMax < MAX_POSSIBLE_LEVEL_CAP ? 'opacity-60' : ''} 
                  ${currentMax >= MAX_POSSIBLE_LEVEL_CAP ? 'opacity-40' : ''}`;

              charElement.innerHTML = `
                  <img src="${c.image}" alt="${c.name}" class="w-full h-20 object-contain rounded mb-1">
                  <p class="${c.rarity === 'Secret' ? 'text-secret' : c.color} font-semibold text-xs text-center">${c.name} ${c.locked ? '🔒' : ''}</p>
                  <p class="text-white text-xs text-center">Niv: ${c.level} / ${currentMax}</p>
                  ${currentMax >= MAX_POSSIBLE_LEVEL_CAP ? '<p class="text-yellow-500 text-xs text-center">Cap Ultime Atteint</p>' : (isAtCurrentCap ? (canBreakLimit ? '<p class="text-green-400 text-xs text-center">Prêt pour Limit Break</p>' : '<p class="text-red-400 text-xs text-center">Orbes manquants</p>') : `<p class="text-gray-400 text-xs text-center">Atteindre Niv. ${currentMax}</p>`)}
              `;
              charElement.addEventListener("click", () => selectLimitBreakCharacter(c.id));
              limitBreakCharSelectionGridElement.appendChild(charElement);
          });
      }

      const isCharacterSelected = char !== null;
      const hasOrbs = (inventory["Divin Wish"] || 0) >= LIMIT_BREAK_COST;
      const characterAtCap = isCharacterSelected && char.level >= (char.maxLevelCap || 60);
      const notAtHardCap = isCharacterSelected && (char.maxLevelCap || 60) < MAX_POSSIBLE_LEVEL_CAP;

      applyLimitBreakButton.disabled = !(isCharacterSelected && hasOrbs && characterAtCap && notAtHardCap);
      applyLimitBreakButton.classList.toggle("opacity-50", applyLimitBreakButton.disabled);
      applyLimitBreakButton.classList.toggle("cursor-not-allowed", applyLimitBreakButton.disabled);
      console.log("--- Fin updateLimitBreakTabDisplay ---");
    }

    function selectLimitBreakCharacter(charId) {
        currentLimitBreakCharacterId = (currentLimitBreakCharacterId === charId) ? null : charId;
        updateLimitBreakTabDisplay();
    }

    function applyLimitBreak() {
        if (!currentLimitBreakCharacterId || (inventory["Divin Wish"] || 0) < LIMIT_BREAK_COST) return;
        const charIndex = ownedCharacters.findIndex(c => c.id === currentLimitBreakCharacterId);
        if (charIndex === -1) return;
        const char = ownedCharacters[charIndex];
        if (char.level < (char.maxLevelCap || 60) || (char.maxLevelCap || 60) >= MAX_POSSIBLE_LEVEL_CAP) return;

        inventory["Divin Wish"]--;

        missions.forEach(mission => {
            if (mission.type === "limit_break_char" && !mission.completed) {
                mission.progress++;
            }
        });

        char.maxLevelCap = (char.maxLevelCap || 60) + LIMIT_BREAK_LEVEL_INCREASE;
        
        resultElement.innerHTML = `<p class="text-amber-400">${char.name} a brisé ses limites ! Nouveau cap: ${char.maxLevelCap}.</p>`;
        if (animationsEnabled) confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: ['#F59E0B', '#FBBF24', '#FCD34D'] });
        
        updateLimitBreakTabDisplay();
        updateCharacterDisplay();
        updateItemDisplay();
        updateUI();
        scheduleSave();
    }

    function startEvolution(id) {
        console.log("startEvolution appelé avec id:", id);
        const char = ownedCharacters.find(c => c.id === id);
        if (!char) {
            console.log("Personnage non trouvé pour id:", id);
            resultElement.innerHTML = '<p class="text-red-400">Personnage non trouvé !</p>';
            return;
        }
        if (char.hasEvolved) {
            resultElement.innerHTML = `<p class="text-yellow-400">${char.name} a déjà évolué et ne peut pas évoluer à nouveau.</p>`;
            return;
        }
        const baseChar = allCharacters.find(c => c.name === char.name);
        if (!baseChar.evolutionRequirements || baseChar.evolutionRequirements.length === 0) {
            resultElement.innerHTML = '<p class="text-red-400">Ce personnage ne peut pas évoluer !</p>';
            return;
        }
        currentEvolutionCharacterId = id;
        selectedEvolutionItems.clear();
        statsModal.classList.add("hidden");
        evolutionModal.classList.remove("hidden");
        enableNoScroll();
        updateEvolutionSelectionDisplay();
    }

    function updateEvolutionSelectionDisplay() {
        const char = ownedCharacters.find(c => c.id === currentEvolutionCharacterId);
        if (!char) return;

        const baseChar = allCharacters.find(c => c.name === char.name);
        const requirements = baseChar.evolutionRequirements || [];

        // Afficher les exigences, y compris le coût en pièces
        evolutionRequirementsElement.innerHTML = `
        <p><strong>Exigences pour évoluer ${char.name} (${char.rarity}):</strong></p>
        ${requirements.length > 0 ? `
        <ul class="list-disc pl-5">
            ${requirements.map(req => {
            if (req.item) {
                const available = inventory[req.item] || 0;
                const sufficient = available >= req.quantity;
                return `<li class="${sufficient ? 'text-green-400' : 'text-red-400'}">${req.quantity} ${req.item} (Possédé: ${available})</li>`;
            } else if (req.coins) {
                const sufficient = coins >= req.coins;
                return `<li class="${sufficient ? 'text-green-400' : 'text-red-400'}">${req.coins} Pièces (Possédé: ${coins})</li>`;
            }
            return '';
            }).join('')}
        </ul>
        ` : '<p class="text-white">Aucune exigence d\'évolution pour ce personnage.</p>'}
        `;

        evolutionSelectionList.innerHTML = "";
        const itemImages = {
        "Haricots": "https://static.wikia.nocookie.net/animeadventures/images/6/6c/Senzu_Bean.png/revision/latest?cb=20230101141509",
        "Fluide mystérieux": "https://static.wikia.nocookie.net/animeadventures/images/7/72/Mysterious_Fluid.png/revision/latest?cb=20230101141428",
        "Pièces": "https://via.placeholder.com/150?text=Pièces",
        "Tickets de Tirage": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/3/35/Pass_XP.png/revision/latest/scale-to-width-down/200?cb=20240912054111",
        "Cursed Token": "https://via.placeholder.com/150?text=Fragments",
        "Shadow Tracer": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/11/Shadow_Trace.png/revision/latest/scale-to-width-down/200?cb=20240925095144",
        "Blood-Red Armor": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/4/42/Blood-Red_Armor.png/revision/latest/scale-to-width-down/200?cb=20240925095521",
        "Green Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/7/7d/Green_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095259",
        "Yellow Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d6/Yellow_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095305",
        "Purple Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/f2/Purple_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095542",
        "Red Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/fe/Red_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095246",
        "Blue Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/2/2a/Blue_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925100144",
        "Pink Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/5/5a/Pink_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095536",
        "Rainbow Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/c/c1/Rainbow_Essence.png/revision/latest/scale-to-width-down/200?cb=20240925095210",
        "Head Captain's Coat": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/7/76/Head_Captain%27s_Coat.png/revision/latest/scale-to-width-down/200?cb=20250301094746",
        "Broken Sword": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/b7/Broken_Sword.png/revision/latest/scale-to-width-down/200?cb=20240925095613",
        "Chipped Blade": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d3/Chipped_Blade.png/revision/latest/scale-to-width-down/200?cb=20250301095941",
        "Cast Blades": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/e/e4/Cast_Blades.png/revision/latest/scale-to-width-down/200?cb=20241228195617",
        "Hellsing Arms": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/5/56/Hellsing_Arms.png/revision/latest/scale-to-width-down/200?cb=20240925095219",
        "Hardened Blood": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/2/2a/Hardened_Blood.png/revision/latest/scale-to-width-down/200?cb=20241027175015",
        "Silverite Sword": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9c/Silverite_Sword.png/revision/latest/scale-to-width-down/200?cb=20250129015816",
        "Cursed Finger": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9a/Cursed_Finger.png/revision/latest/scale-to-width-down/200?cb=20241108232910",
        "Magma Stone": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/3/33/Magma_Stone.png/revision/latest/scale-to-width-down/200?cb=20250325084958",
        "Broken Pendant": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d0/Broken_Pendant.png/revision/latest/scale-to-width-down/200?cb=20241027174604",
        "Demon Beads": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/2/28/Demon_Beads.png/revision/latest/scale-to-width-down/200?cb=20240925095328",
        "Broken Heart": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9e/Broken_Heart.png/revision/latest/scale-to-width-down/200?cb=20240925095301",
        "Nichirin Cleavers": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d9/Nichirin_Cleavers.png/revision/latest/scale-to-width-down/200?cb=20240925095532",
        "Blue Chakra": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/bb/Blue_Chakra.png/revision/latest/scale-to-width-down/200?cb=20240908064022",
        "Red Chakra": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/1e/Red_Chakra.png/revision/latest/scale-to-width-down/200?cb=20240908064022",
        "Skin Patch": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/c/c7/Skin_Patch.png/revision/latest/scale-to-width-down/200?cb=20240925095526",
        "Snake Scale": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/d/d5/Snake_Scale.png/revision/latest/scale-to-width-down/200?cb=20240925095139",
        "Senzu Bean": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/6/6c/Senzu_Bean.png/revision/latest/scale-to-width-down/200?cb=20250404123542",
        "Holy Corpse Eyes": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/a/a5/Holy_Corpse_Eyes.png/revision/latest/scale-to-width-down/200?cb=20241228041057",
        "Holy Corpse Arms": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9d/Holy_Corpse_Arms.png/revision/latest/scale-to-width-down/200?cb=20241228042407",
        "Completed Holy Corpse": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/91/Completed_Holy_Corpse.png/revision/latest/scale-to-width-down/200?cb=20241228201349",
        "Gorgon's Blindfold": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/1f/Gorgon%27s_Blindfold.png/revision/latest/scale-to-width-down/200?cb=20241228195652",
        "Caster's Headpiece": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/4/4f/Caster%27s_Headpiece.png/revision/latest/scale-to-width-down/200?cb=20241228195633",
        "Avalon": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/b7/Avalon.png/revision/latest/scale-to-width-down/200?cb=20241228195608",
        "Goddess' Sword": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/a/a5/Goddess%27_Sword.png/revision/latest/scale-to-width-down/200?cb=20241228195642",
        "Blade of Death": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/ba/Blade_of_Death.png/revision/latest/scale-to-width-down/200?cb=20241228195625",
        "Berserker's Blade": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/8/87/Berserker%27s_Blade.png/revision/latest/scale-to-width-down/200?cb=20250301095923",
        "Shunpo Spirit": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9b/Shunpo_Spirit.png/revision/latest/scale-to-width-down/200?cb=20250301094718",
        "Energy Arrow": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/c/c4/Energy_Arrow.png/revision/latest/scale-to-width-down/200?cb=20250301084925",
        "Hair Ornament": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/5/5d/Hair_Ornament.png/revision/latest/scale-to-width-down/200?cb=20250301094807",
        "Bucket Hat": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/2/2e/Bucket_Hat.png/revision/latest/scale-to-width-down/200?cb=20250301094814",
        "Horn of Salvation": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/f9/Horn_of_Salvation.png/revision/latest/scale-to-width-down/200?cb=20250301094802",
        "Energy Bone": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/2/21/Energy_Bone.png/revision/latest/scale-to-width-down/200?cb=20250301094756",
        "Prison Chair": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/b3/Prison_Chair.png/revision/latest/scale-to-width-down/200?cb=20250301084509",
        "Rotara Earring 2": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/10/Rotara_Earring_2.png/revision/latest/scale-to-width-down/200?cb=20250508200230",
        "Rotara Earring 1": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/f1/Rotara_Earring_1.png/revision/latest/scale-to-width-down/200?cb=20250507164632",
        "Z Blade": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/1/16/Z_Blade.png/revision/latest/scale-to-width-down/200?cb=20250507174034",
        "Champ's Belt": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/fb/Champ%27s_Belt.png/revision/latest/scale-to-width-down/200?cb=20250507164406",
        "Dog Bone": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9d/Dog_Bone.png/revision/latest/scale-to-width-down/200?cb=20250507160505",
        "Six Eyes": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/91/Six_Eyes.png/revision/latest/scale-to-width-down/200?cb=20241108232222",
        "Tome of Wisdom": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/0/02/Tome_Of_Wisdom.png/revision/latest?cb=20250130224612",
        "Corrupted Visor": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/4/48/Corrupted_Visor.png/revision/latest/scale-to-width-down/200?cb=20250205094632",
        "Tainted Ribbon": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/0/0e/Tainted_Ribbon.png/revision/latest/scale-to-width-down/200?cb=20250301095928",
        "Demon Chalice": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/8/8c/Demon_Chalice.png/revision/latest/scale-to-width-down/200?cb=20250205094729",
        "Essence of the Spirit King": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/4/44/Essence_of_the_Spirit_King.png/revision/latest/scale-to-width-down/200?cb=20250301094735",
        "Ring of Friendship": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/7/75/Ring_of_Friendship.png/revision/latest/scale-to-width-down/200?cb=20250321000834",
        "Red Jewel": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/7/74/Red_Jewel.png/revision/latest/scale-to-width-down/200?cb=20250321000706",
        "Majan Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/6/63/Mojon_Essence.png/revision/latest/scale-to-width-down/200?cb=20250507174026",
        "Donut": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/9/9b/Donut.png/revision/latest/scale-to-width-down/200?cb=20250507160557",
        "Atomic Essence": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/6/6a/Atomic_Essence.png/revision/latest/scale-to-width-down/200?cb=20250507160544",
        "Restricting Headband": "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/f/fd/Restricting_Headband.png/revision/latest/scale-to-width-down/200?cb=20250603203745",
        "Toil Ribbon" : "https://static.wikia.nocookie.net/rbx-anime-vanguards/images/b/bb/Tail_Ribbon.png/revision/latest/scale-to-width-down/200?cb=20250603203730",
        };
      
        requirements.forEach(req => {
        if (!req.item) return; // Ignorer les exigences de pièces pour la sélection d'objets
        const item = req.item;
        const quantity = req.quantity;
        const availableQuantity = inventory[item] || 0;
        const selectedQuantity = selectedEvolutionItems.get(item) || 0;
        const itemElement = document.createElement("div");
        itemElement.className = `bg-gray-800 bg-opacity-50 p-4 rounded-lg transition transform hover:scale-105 cursor-pointer border-2 border-gray-400 ${
            selectedQuantity > 0 ? 'selected-for-evolution' : ''
        }`;
        itemElement.innerHTML = `
            <img src="${itemImages[item]}" alt="${item}" class="w-full h-24 object-contain rounded mb-1">
            <p class="text-white font-semibold">${item}</p>
            <p class="text-white">Requis: ${quantity}</p>
            <p class="text-white">Disponible: ${availableQuantity}</p>
            <p class="text-white">Sélectionné: ${selectedQuantity}</p>
            <div class="flex gap-2 mt-2">
            <button class="bg-blue-500 hover:bg-blue-600 text-white py-1 px-2 rounded-lg decrease-evolution-item" data-item="${item}">-</button>
            <button class="bg-blue-500 hover:bg-blue-600 text-white py-1 px-2 rounded-lg increase-evolution-item" data-item="${item}">+</button>
            </div>
        `;
        evolutionSelectionList.appendChild(itemElement);
        });

        // Vérifier si toutes les exigences sont satisfaites, y compris les pièces
        const canEvolve = requirements.every(req => {
        if (req.item) {
            return (selectedEvolutionItems.get(req.item) || 0) >= req.quantity;
        } else if (req.coins) {
            return coins >= req.coins;
        }
        return true;
        });
        evolutionSelectedCountElement.textContent = Array.from(selectedEvolutionItems.values()).reduce((sum, qty) => sum + qty, 0);
        confirmEvolutionButton.disabled = !canEvolve;
        confirmEvolutionButton.classList.toggle("opacity-50", !canEvolve);
        confirmEvolutionButton.classList.toggle("cursor-not-allowed", !canEvolve);

        // Attacher les écouteurs pour les boutons +/-
        document.querySelectorAll(".increase-evolution-item").forEach(button => {
        button.addEventListener("click", () => {
            const item = button.dataset.item;
            selectEvolutionItem(item, 1);
        });
        });
        document.querySelectorAll(".decrease-evolution-item").forEach(button => {
        button.addEventListener("click", () => {
            const item = button.dataset.item;
            selectEvolutionItem(item, -1);
        });
        });
    }

    function selectEvolutionItem(item, change) {
        const char = ownedCharacters.find(c => c.id === currentEvolutionCharacterId);
        if (!char) return;
        const baseChar = allCharacters.find(c => c.name === char.name);
        const requirements = baseChar.evolutionRequirements || [];
        const req = requirements.find(r => r.item === item);
        if (!req) return;
        const currentQuantity = selectedEvolutionItems.get(item) || 0;
        const availableQuantity = inventory[item] || 0;
        const maxQuantity = req.quantity;
        const newQuantity = Math.max(0, Math.min(currentQuantity + change, Math.min(availableQuantity, maxQuantity)));
        if (newQuantity === 0) {
            selectedEvolutionItems.delete(item);
        } else {
            selectedEvolutionItems.set(item, newQuantity);
        }
        updateEvolutionSelectionDisplay();
    }

    function cancelEvolution() {
      console.log("cancelEvolution appelé");
      selectedEvolutionItems.clear();
      evolutionModal.classList.add("hidden");
      disableNoScroll();
      updateEvolutionDisplay();
    }

    function confirmEvolution() {
      const charIndex = ownedCharacters.findIndex(c => c.id === currentEvolutionCharacterId);
      if (charIndex === -1) {
          resultElement.innerHTML = '<p class="text-red-400">Personnage non trouvé !</p>';
          evolutionModal.classList.add("hidden");
          disableNoScroll();
          return;
      }
      const char = ownedCharacters[charIndex]; // Obtenir la référence directe à l'objet

      const baseCharDefinition = allCharacters.find(c => c.name === (char.originalName || char.name));
      if (!baseCharDefinition) {
          resultElement.innerHTML = '<p class="text-red-400">Erreur de configuration du personnage de base !</p>';
          evolutionModal.classList.add("hidden");
          disableNoScroll();
          return;
      }

      const requirements = baseCharDefinition.evolutionRequirements || [];
      const canEvolve = requirements.every(req => {
          if (req.item) {
              return (selectedEvolutionItems.get(req.item) || 0) >= req.quantity;
          } else if (req.coins) {
              return coins >= req.coins;
          }
          return true; // Pour des exigences futures qui ne sont ni item ni coins
      });

      if (!canEvolve) {
          resultElement.innerHTML = '<p class="text-red-400">Exigences d\'évolution non satisfaites !</p>';
          // Garder la modale ouverte pour que l'utilisateur voie ce qui manque
          return;
      }
      if (char.hasEvolved) {
          resultElement.innerHTML = `<p class="text-yellow-400">${char.name} a déjà évolué.</p>`;
          evolutionModal.classList.add("hidden");
          disableNoScroll();
          return;
      }

      const evolutionData = baseCharDefinition.evolutionData;
      let evolutionMessageParts = [];

      if (evolutionData) {
          // Stocker le nom original seulement si ce n'est pas déjà fait ET si le nom va effectivement changer
          if (!char.originalName && evolutionData.newName && evolutionData.newName !== char.name) {
              char.originalName = char.name;
          }

          if (evolutionData.newName) {
              char.name = evolutionData.newName;
              evolutionMessageParts.push(`nommé ${char.name}`);
          }
          if (evolutionData.newImage) {
              char.image = evolutionData.newImage;
          }
          if (typeof evolutionData.basePowerIncrease === 'number') {
              char.basePower = (char.basePower || 0) + evolutionData.basePowerIncrease;
              evolutionMessageParts.push(`puissance de base augmentée de ${evolutionData.basePowerIncrease}`);
          }
          if (evolutionData.newRarity) {
              char.rarity = evolutionData.newRarity;
              // S'assurer que la couleur est bien celle de la NOUVELLE rareté
              if (evolutionData.newColor) {
                  char.color = evolutionData.newColor;
              } else {
                  // Fallback si newColor n'est pas spécifié dans evolutionData
                  const rarityColors = { "Rare": "text-gray-400", "Épique": "text-purple-400", "Légendaire": "text-yellow-400", "Mythic": "rainbow-text", "Secret": "text-secret" };
                  char.color = rarityColors[char.rarity] || "text-white";
              }
              evolutionMessageParts.push(`rareté à ${char.rarity}`);
          }

          if (evolutionData.additionalEffects) {
              for (const [effect, value] of Object.entries(evolutionData.additionalEffects)) {
                  if (typeof char[effect] === 'number') {
                      char[effect] = (char[effect] || 0) + value;
                  } else {
                      char[effect] = value;
                  }
                  evolutionMessageParts.push(`${effect} augmenté(e)`);
              }
          }
      } else {
          // Fallback si evolutionData n'existe pas (ne devrait pas arriver si bien configuré)
          const fallbackPowerBonus = 100;
          char.basePower = (char.basePower || 0) + fallbackPowerBonus;
          evolutionMessageParts.push(`puissance augmentée (fallback +${fallbackPowerBonus})`);
          console.warn(`EvolutionData manquant pour ${baseCharDefinition.name}, application d'un bonus de puissance fallback.`);
      }

      char.hasEvolved = true; // Marquer comme évolué

      // AJOUTER CE BLOC POUR LA MISSION
      missions.forEach(mission => {
          if (mission.type === "evolve_char" && !mission.completed) {
              mission.progress++;
          }
      });

      // Recalculer la puissance APRÈS toutes les modifications de basePower, statModifier (si la rareté le change), etc.
      recalculateCharacterPower(char); // Ceci met à jour char.power

      // Déduire les objets et les pièces de l'inventaire
      let coinsUsed = 0;
      selectedEvolutionItems.forEach((quantity, item) => {
          inventory[item] = (inventory[item] || 0) - quantity;
          if (inventory[item] < 0) inventory[item] = 0; // S'assurer de ne pas avoir de quantité négative
      });
      requirements.forEach(req => {
          if (req.coins) {
              coins -= req.coins;
              coinsUsed = req.coins;
          }
      });

      // Construire le message de résultat
      let resultText = `<p class="text-green-400">Évolution réussie pour ${char.name} !</p>`;
      if (evolutionMessageParts.length > 0) {
          resultText += `<p class="text-white">Le personnage a été ${evolutionMessageParts.join(', ')}.</p>`;
      }
      resultText += `<p class="text-white">Nouvelle Puissance totale: ${char.power}</p>`; // Afficher la puissance MISE À JOUR
      resultText += `<p class="text-white">Ressources utilisées: ${[
          ...Array.from(selectedEvolutionItems.entries()).map(([item, qty]) => `${qty} ${item}`),
          coinsUsed > 0 ? `${coinsUsed} Pièces` : ''
      ].filter(Boolean).join(", ")}</p>`;

      resultElement.innerHTML = resultText;

      if (animationsEnabled) {
          confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 }, colors: ['#EC4899', '#DB2777', '#FBCFE8'] });
      }
      if (soundEnabled) { /* Si vous avez un son d'évolution: evolutionSound.play(); */ }

      // Nettoyage et mise à jour de l'UI
      selectedEvolutionItems.clear();
      evolutionModal.classList.add("hidden");
      disableNoScroll();

      updateEvolutionDisplay();   // Pour rafraîchir la liste des persos encore évoluables
      updateCharacterDisplay();   // Pour rafraîchir l'inventaire principal avec le perso évolué
      updateItemDisplay();        // Pour refléter les objets consommés
      updateIndexDisplay();       // Si le nom ou l'image change dans l'index
      updateUI();                 // Pour les stats générales (gemmes, pièces, etc.)
      scheduleSave();             // Sauvegarder toutes les modifications
    }

    function updateEvolutionDisplay() {
      const eligibleCharacters = ownedCharacters.filter(char => {
          // Pour un personnage non évolué, char.name EST son nom de base.
          // La recherche de baseChar devrait donc fonctionner avec char.name.
          const baseChar = allCharacters.find(c => c.name === char.name);

          if (!baseChar) {
              // Si aucune définition de base n'est trouvée pour le nom actuel du personnage,
              // il ne peut pas être considéré pour l'évolution (cela pourrait arriver pour des noms évolués
              // ou des données incohérentes, mais !char.hasEvolved devrait déjà filtrer les noms évolués).
              return false;
          }

          // Le personnage est éligible s'il a des conditions d'évolution
          // ET si CETTE INSTANCE du personnage n'a PAS ENCORE évolué.
          const hasRequirements = baseChar.evolutionRequirements && baseChar.evolutionRequirements.length > 0;
          const notYetEvolved = !char.hasEvolved;

          return hasRequirements && notYetEvolved;
      });

      if (!eligibleCharacters.length) {
          evolutionDisplay.innerHTML = '<p class="text-white">Aucun personnage éligible pour l\'évolution pour le moment.</p>';
          return;
      }

      // Trier les personnages éligibles (votre logique de tri existante)
      const sortedCharacters = eligibleCharacters.sort((a, b) => {
          if (sortCriteria === "power") {
              return b.power - a.power;
          } else if (sortCriteria === "rarity") {
              return rarityOrder[b.rarity] - rarityOrder[a.rarity];
          } else if (sortCriteria === "level") {
              return b.level - a.level;
          }
          return 0;
      });

      evolutionDisplay.innerHTML = sortedCharacters.map(char => {
          // Pour l'affichage, on utilise toujours char.name qui est le nom de base ici,
          // car on a filtré pour n'avoir que les personnages non évolués.
          const baseCharForDisplay = allCharacters.find(c => c.name === char.name);
          const requirements = baseCharForDisplay.evolutionRequirements || []; // S'assurer que requirements existe

          // Vérifier si toutes les exigences matérielles (items + pièces) sont satisfaites
          // Cette vérification est pour l'affichage ("Évolution possible" / "Exigences non satisfaites")
          // La vérification finale se fait dans startEvolution/confirmEvolution.
          let canEvolveDisplayCheck = true; // Supposons que oui initialement
          if (requirements.length > 0) {
              canEvolveDisplayCheck = requirements.every(req => {
                  if (req.item) {
                      return (inventory[req.item] || 0) >= req.quantity;
                  } else if (req.coins) {
                      return coins >= req.coins;
                  }
                  return true; // Pour les exigences futures
              });
          } else {
              canEvolveDisplayCheck = false; // S'il n'y a pas d'requirements, il ne peut pas évoluer par ce biais
          }


          let rarityTextColorClass = char.color;
          if (char.rarity === "Mythic") rarityTextColorClass = "rainbow-text";
          else if (char.rarity === "Secret") rarityTextColorClass = "text-secret";

          return `
          <div class="relative p-2 rounded-lg border ${getRarityBorderClass(char.rarity)} cursor-pointer" 
              onclick="startEvolution('${char.id}')">
              <img src="${char.image}" alt="${char.name}" class="w-full h-32 object-contain rounded">
              <p class="text-center text-white font-semibold mt-2">${char.name}</p>
              <p class="text-center ${rarityTextColorClass}">${char.rarity}</p>
              <p class="text-center text-white">Niveau: ${char.level}</p>
              <p class="text-center text-white">Puissance: ${char.power}</p>
              <p class="text-center text-sm ${canEvolveDisplayCheck ? 'text-green-400' : 'text-red-400'}">${canEvolveDisplayCheck ? 'Prêt à évoluer' : 'Matériaux manquants'}</p>
          </div>
          `;
      }).join("");
    }

    function toggleLockCharacter(id) {
        const charIndex = ownedCharacters.findIndex(c => c.id === id);
        if (charIndex === -1) return;

        ownedCharacters[charIndex].locked = !ownedCharacters[charIndex].locked; // Inverse l'état locked
        const char = ownedCharacters[charIndex]; // Récupère le personnage mis à jour

        // Mettre à jour le texte et le style du bouton de verrouillage dans la modale
        const lockButton = document.getElementById("lock-button");
        if (lockButton) {
            lockButton.textContent = char.locked ? "Déverrouiller" : "Verrouiller";
            lockButton.disabled = isDeleteMode; // Le bouton lock/unlock lui-même ne doit pas être désactivé par l'état lock
            lockButton.classList.toggle("opacity-50", lockButton.disabled);
            lockButton.classList.toggle("cursor-not-allowed", lockButton.disabled);
            lockButton.classList.toggle("bg-red-500", char.locked);
            lockButton.classList.toggle("hover:bg-red-600", char.locked);
            lockButton.classList.toggle("bg-gray-500", !char.locked);
            lockButton.classList.toggle("hover:bg-gray-600", !char.locked);
        }

        // --- AJOUT : Mettre à jour explicitement l'état des autres boutons ---
        const fuseButton = document.getElementById("fuse-button");
        const evolveButton = document.getElementById("evolve-button"); // Peut exister ou non
        const giveItemsButton = document.getElementById("give-items-button");

        if (fuseButton) {
            fuseButton.disabled = char.level >= 100 || isDeleteMode || ownedCharacters.length <= 1 || char.locked;
            fuseButton.classList.toggle("opacity-50", fuseButton.disabled);
            fuseButton.classList.toggle("cursor-not-allowed", fuseButton.disabled);
        }
        if (evolveButton) {
            evolveButton.disabled = isDeleteMode || char.locked;
            evolveButton.classList.toggle("opacity-50", evolveButton.disabled);
            evolveButton.classList.toggle("cursor-not-allowed", evolveButton.disabled);
        }
        // Donner objets n'est pas affecté par le verrouillage, seulement par le mode suppression
        if (giveItemsButton) {
            giveItemsButton.disabled = isDeleteMode;
            giveItemsButton.classList.toggle("opacity-50", giveItemsButton.disabled);
            giveItemsButton.classList.toggle("cursor-not-allowed", giveItemsButton.disabled);
        }
        // --- FIN DE L'AJOUT ---

        console.log(`Personnage ${char.name} ${char.locked ? 'verrouillé' : 'déverrouillé'}.`);
        updateCharacterDisplay(); // Met à jour l'affichage de l'inventaire pour montrer/cacher l'icône
        scheduleSave(); // Sauvegarde le nouvel état
    }

        function showTab(tabId) {
        // Cacher tous les contenus d'onglets principaux
        shopElement.classList.add("hidden");
        missionsElement.classList.add("hidden");
        inventoryElement.classList.add("hidden");
        playElement.classList.add("hidden");
        indexElement.classList.add("hidden");
        evolutionElement.classList.add("hidden");
        statChangeElement.classList.add("hidden");
        curseElement.classList.add("hidden");
        traitElement.classList.add("hidden");
        limitBreakElement.classList.add("hidden");

        // Retirer la classe spéciale d'arrière-plan du body par défaut
        document.body.classList.remove("curse-tab-active-bg");

        // Afficher le contenu de l'onglet sélectionné
        const tabToShow = document.getElementById(tabId);
        if (tabToShow) {
            tabToShow.classList.remove("hidden");
        }

        // Mettre à jour l'apparence des boutons d'onglet
        const allVisibleTabButtons = document.querySelectorAll(".tab-button:not(.hidden)");
        allVisibleTabButtons.forEach(btn => {
            btn.classList.toggle("border-blue-500", btn.dataset.tab === tabId);
            btn.classList.toggle("border-transparent", btn.dataset.tab !== tabId);
        });

        // Logique spécifique à chaque onglet lors de son affichage
        if (tabId === "inventory") {
            showSubTab("units");
        } else if (tabId === "play") {
            showSubTab("story");
        } else if (tabId === "index") {
            updateIndexDisplay();
        } else if (tabId === "evolution") {
            updateEvolutionDisplay();
        } else if (tabId === "stat-change") {
            updateStatChangeTabDisplay();
        } else if (tabId === "curse") {
            updateCurseTabDisplay();
            if (theme === "dark") {
                document.body.classList.add("curse-tab-active-bg");
            }
        } else if (tabId === "trait") {
            updateTraitTabDisplay();
        } else if (tabId === "limit-break") {
            updateLimitBreakTabDisplay(); // Appel correct ici
        } else {
            if (isDeleteMode) {
                isDeleteMode = false;
                selectedCharacterIndices.clear();
                updateCharacterDisplay();
            }
        }
        updateUI();
    }


    function showSubTab(subtabId) {
        // Cacher les sous-onglets de Play
        document.getElementById("story")?.classList.add("hidden");
        document.getElementById("legende")?.classList.add("hidden");
        document.getElementById("challenge")?.classList.add("hidden");
        document.getElementById("materiaux")?.classList.add("hidden");
        // Cacher les sous-onglets d'Inventory
        document.getElementById("units")?.classList.add("hidden");
        document.getElementById("items")?.classList.add("hidden");

        // Afficher le bon
        const subTabElement = document.getElementById(subtabId);
        if (subTabElement) {
            subTabElement.classList.remove("hidden");
        }


        let currentSubtabButtons;
        if (playElement.contains(subTabElement)) { // Si le sous-onglet est dans "Play"
            currentSubtabButtons = document.querySelectorAll('#play .subtab-button');
        } else if (inventoryElement.contains(subTabElement)) { // Si le sous-onglet est dans "Inventory"
            currentSubtabButtons = document.querySelectorAll('#inventory .subtab-button');
        }
        // Note: Les sous-onglets d'Évolution sont gérés par showSubTabEvolution

        if (currentSubtabButtons) {
            currentSubtabButtons.forEach(btn => {
                btn.classList.toggle("border-blue-500", btn.dataset.subtab === subtabId);
                btn.classList.toggle("border-transparent", btn.dataset.subtab !== subtabId);
            });
        }

      if (subtabId !== "units") {
        isDeleteMode = false;
        selectedCharacterIndices.clear();
        updateCharacterDisplay();
      }

      if (subtabId === "items") {
        updateItemDisplay();
      } else if (subtabId === "story") {
        updateLevelDisplay();
      } else if (subtabId === "legende") {
        updateLegendeDisplay();
      } else if (subtabId === "challenge") { // AJOUT
        updateChallengeDisplay();
      } else if (subtabId === "materiaux") { // AJOUT DE CETTE CONDITION
        updateMaterialFarmDisplay();
      }
      updateUI();
    }

    function updateStatChangeTabDisplay() {
        document.getElementById("stat-chip-count").textContent = inventory["Stat Chip"] || 0;
        const selectedCharDisplay = document.getElementById("stat-change-selected-char-display");
        const charSelectionGrid = document.getElementById("stat-change-char-selection-grid");
        const applyButton = document.getElementById("apply-stat-change-button");
        const searchInput = document.getElementById("stat-change-search");
        const searchTerm = searchInput.value.toLowerCase();

        let disableApplyButton = !currentStatChangeCharacterId || (inventory["Stat Chip"] || 0) < 1;
        let char = null;

        clearTimeout(statChangeInfoTimeoutId);
        statChangeInfoTimeoutId = null;

        if (resultElement.innerHTML.includes("Info: Le personnage") || resultElement.innerHTML.includes("Info:")) {
            resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`;
        }

        if (currentStatChangeCharacterId) {
            char = ownedCharacters.find(c => c.id === currentStatChangeCharacterId);
            if (char) {
                selectedCharDisplay.innerHTML = `
                    <div class="bg-gray-800 bg-opacity-50 p-4 rounded-lg border-2 ${statRanks[char.statRank]?.borderColor || 'border-gray-400'} w-full max-w-xs mx-auto">
                        <img src="${char.image}" alt="${char.name}" class="w-full h-32 object-contain rounded mb-2">
                        <p class="${char.color} font-semibold text-center">${char.name} (${char.rarity}) ${char.locked ? '🔒' : ''}</p>
                        <p class="text-white text-center">Niv: ${char.level}, P: ${char.power}</p>
                        <p class="text-center font-bold ${statRanks[char.statRank]?.color || 'text-white'}">Stat Actuel: ${char.statRank}</p>
                    </div>
                `;

                const currentRankIsSSS = (char.statRank === "SSS");
                const currentSelectedTargetRanks = Array.from(statTargetRanksSelectionElement.querySelectorAll(".stat-target-rank-checkbox:checked")).map(cb => cb.value);
                
                let infoMsgContent = "";

                if (currentRankIsSSS) {
                    infoMsgContent = `Info: ${char.name} a le rang SSS. "Changer Stat" demandera confirmation.`;
                } else if (statKeepBetterToggle.checked && currentSelectedTargetRanks.length > 0 && currentSelectedTargetRanks.includes(char.statRank)) {
                    infoMsgContent = `Info: ${char.name} a le rang cible coché "${char.statRank}". "Changer Stat" demandera confirmation pour continuer à chercher d'autres cibles (ou le même rang).`;
                }
                // Si aucune des conditions ci-dessus n'est remplie, aucun message d'info spécifique lié à une cible atteinte ou SSS.
                // Le bouton reste actif tant qu'il y a des chips.

                if (infoMsgContent && (inventory["Stat Chip"] || 0) >= 1 && !disableApplyButton) {
                     if (!resultElement.innerHTML.includes("Changement de Stat pour") && 
                         !resultElement.innerHTML.includes("Changement de stat annulé") &&
                         !resultElement.innerHTML.includes("malédiction") && 
                         !resultElement.innerHTML.includes("a été maudit")) {
                        resultElement.innerHTML = `<p class="text-blue-400">${infoMsgContent}</p>`;
                        statChangeInfoTimeoutId = setTimeout(() => {
                            if (resultElement.innerHTML.includes("Info:")) {
                                resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`;
                            }
                            statChangeInfoTimeoutId = null;
                        }, 7000);
                    }
                }
            } else { // char non trouvé
                selectedCharDisplay.innerHTML = '<p class="text-gray-400">Personnage non trouvé.</p>';
                currentStatChangeCharacterId = null;
                disableApplyButton = true;
            }
        } else { // Aucun perso sélectionné
            selectedCharDisplay.innerHTML = '<p class="text-gray-400">Aucun personnage sélectionné.</p>';
            disableApplyButton = true;
        }

        charSelectionGrid.innerHTML = "";
        const availableCharacters = ownedCharacters
            .filter(c => c.name.toLowerCase().includes(searchTerm));

        if (availableCharacters.length === 0) {
            charSelectionGrid.innerHTML = `<p class="text-gray-400 col-span-full">${searchTerm ? 'Aucun personnage trouvé pour "' + searchTerm + '".' : 'Aucun personnage disponible.'}</p>`;
        } else {
            availableCharacters.sort((a,b) => (statRanks[b.statRank]?.order || 0) - (statRanks[a.statRank]?.order || 0) || b.power - a.power)
            .forEach(c => {
                const charElement = document.createElement("div");
                charElement.className = `bg-gray-800 bg-opacity-50 p-2 rounded-lg transition transform hover:scale-105 cursor-pointer border-2 
                    ${currentStatChangeCharacterId === c.id ? 'border-green-500' : (statRanks[c.statRank]?.borderColor || 'border-gray-600')}
                    hover:border-gray-500`;
                charElement.innerHTML = `
                    <img src="${c.image}" alt="${c.name}" class="w-full h-24 object-contain rounded mb-1">
                    <p class="${c.rarity === 'Secret' ? 'text-secret' : c.color} font-semibold text-xs text-center">${c.name} ${c.locked ? '🔒' : ''}</p>
                    <p class="text-white text-xs text-center ${statRanks[c.statRank]?.color || 'text-white'}">Stat: ${c.statRank}</p>
                    <p class="text-white text-xs text-center">P: ${c.power}</p>
                `;
                charElement.addEventListener("click", () => {
                  selectStatChangeCharacter(c.id);
                });
                charSelectionGrid.appendChild(charElement);
            });
        }

        // La logique de disableApplyButton est maintenant plus simple:
        // elle est vraie si pas de perso sélectionné ou pas de chips.
        // Les confirmations dans applyStatChange gèrent les cas SSS ou cible cochée.
        applyButton.disabled = disableApplyButton;
        applyButton.classList.toggle("opacity-50", disableApplyButton);
        applyButton.classList.toggle("cursor-not-allowed", disableApplyButton);

        const checkboxesDisabled = !statKeepBetterToggle.checked;
        statTargetRanksSelectionElement.classList.toggle("stat-target-ranks-disabled", checkboxesDisabled);
        statTargetRanksSelectionElement.querySelectorAll(".stat-target-rank-checkbox").forEach(cb => {
            cb.disabled = checkboxesDisabled;
            if (checkboxesDisabled) {
                cb.checked = false; 
            }
        });
    }

    function calculateMaxTeamSize() {
      let baseSize = 3;
      let bonus = 0;
      selectedBattleCharacters.forEach(index => {
          const char = ownedCharacters[index];
          // AJOUT DE LA VÉRIFICATION : s'assurer que char existe ET qu'il a un passif valide
          if (char && char.passive && typeof char.passive.teamSizeBonus === 'number') {
              bonus = Math.max(bonus, char.passive.teamSizeBonus);
          }
      });
      return baseSize + bonus;
    }
    
    function calculateMaxPresetTeamSize() { // NOUVELLE FONCTION
      let baseSize = 3;
      let bonus = 0;
      selectedPresetCharacters.forEach(index => { // Utilise selectedPresetCharacters
          const char = ownedCharacters[index];
          if (char && char.passive && typeof char.passive.teamSizeBonus === 'number') {
              bonus = Math.max(bonus, char.passive.teamSizeBonus);
          }
      });
      return baseSize + bonus;
    }

    function openStatChangeConfirmModal(message, callback) {
        statChangeConfirmMessageElement.textContent = message;
        statChangeConfirmationCallback = callback;
        statChangeConfirmContinueModal.classList.remove("hidden"); // Affiche la modale
        enableNoScroll();
    }

    function closeStatChangeConfirmModal() {
        statChangeConfirmContinueModal.classList.add("hidden");
        statChangeConfirmationCallback = null;
        disableNoScroll();
    }

    function selectStatChangeCharacter(id) {
        currentStatChangeCharacterId = (currentStatChangeCharacterId === id) ? null : id;
        updateStatChangeTabDisplay();
    }

    async function applyStatChange() {
        if (!currentStatChangeCharacterId) {
            resultElement.innerHTML = '<p class="text-red-400">Veuillez sélectionner un personnage.</p>';
            return;
        }
        if ((inventory["Stat Chip"] || 0) < 1) {
            resultElement.innerHTML = '<p class="text-red-400">Vous n\'avez pas de Stat Chips !</p>';
            return;
        }

        const charIndex = ownedCharacters.findIndex(c => c.id === currentStatChangeCharacterId);
        if (charIndex === -1) {
            resultElement.innerHTML = '<p class="text-red-400">Personnage sélectionné non trouvé !</p>';
            currentStatChangeCharacterId = null;
            updateStatChangeTabDisplay();
            return;
        }

        const char = ownedCharacters[charIndex];
        const oldStatRank = char.statRank;
        const selectedTargetRanks = Array.from(statTargetRanksSelectionElement.querySelectorAll(".stat-target-rank-checkbox:checked")).map(cb => cb.value);
        let needsConfirmation = false;
        let confirmMessage = "";

        // Confirmation si SSS
        if (oldStatRank === "SSS") {
            needsConfirmation = true;
            confirmMessage = `Le personnage ${char.name} a déjà le rang de stat exceptionnel "SSS". Si vous continuez, un Stat Chip sera utilisé et un nouveau rang (qui pourrait être inférieur) sera appliqué. Êtes-vous sûr ?`;
        } 
        // Confirmation si le toggle "garder si meilleur" est coché ET que le rang actuel est une des cibles cochées
        else if (statKeepBetterToggle.checked && selectedTargetRanks.length > 0 && selectedTargetRanks.includes(oldStatRank)) {
            needsConfirmation = true;
            confirmMessage = `Le personnage ${char.name} a déjà le rang de stat "${oldStatRank}", qui est l'un de vos rangs cibles cochés. Voulez-vous vraiment utiliser un Stat Chip pour tenter un autre rang ? Le nouveau rang obtenu sera appliqué.`;
        }

        if (needsConfirmation) {
            const userConfirmed = await new Promise(resolve => {
                statChangeConfirmationCallback = (confirmed) => resolve(confirmed);
                openStatChangeConfirmModal(confirmMessage, statChangeConfirmationCallback);
            });
            statChangeConfirmationCallback = null; 

            if (!userConfirmed) {
                resultElement.innerHTML = `<p class="text-blue-400">Changement de stat annulé. Aucun Stat Chip utilisé.</p>`;
                updateStatChangeTabDisplay(); 
                return; 
            }
        }
        
        // S'assurer que le chip est toujours disponible après une confirmation asynchrone
        if ((inventory["Stat Chip"] || 0) < 1) { 
             resultElement.innerHTML = '<p class="text-red-500">Erreur : Plus de Stat Chips disponibles après confirmation.</p>';
             updateStatChangeTabDisplay();
             return;
        }
        
        inventory["Stat Chip"]--;

        missions.forEach(mission => {
            if (mission.type === "change_stat_rank" && !mission.completed) {
                mission.progress++;
            }
        });
        
        const newStatRankKey = getRandomStatRank(); // Obtenir un nouveau rang aléatoire
        
        // Le nouveau rang est TOUJOURS appliqué ici
        char.statRank = newStatRankKey;
        char.statModifier = statRanks[newStatRankKey].modifier;
        recalculateCharacterPower(char);

        let resultMessageContent = `
            <p class="text-green-400">Changement de Stat pour ${char.name} !</p>
            <p class="text-white"><span class="font-semibold">Ancien:</span> ${oldStatRank} -> <span class="font-semibold ${statRanks[newStatRankKey]?.color || ''}">Nouveau:</span> ${newStatRankKey}</p>
            <p class="text-white">Nouvelle Puissance: ${char.power}</p>
        `;

        // Message additionnel si le toggle était coché et le résultat n'est pas une cible
        if (statKeepBetterToggle.checked && !selectedTargetRanks.includes(newStatRankKey) && selectedTargetRanks.length > 0) {
            resultMessageContent += `<p class="text-yellow-300 text-sm">(Le rang obtenu "${newStatRankKey}" n'était pas une cible cochée, mais a été appliqué.)</p>`;
        } else if (statKeepBetterToggle.checked && selectedTargetRanks.includes(newStatRankKey)) {
             resultMessageContent += `<p class="text-green-300 text-sm">(Le rang obtenu "${newStatRankKey}" est une cible cochée !)</p>`;
        }


        resultElement.innerHTML = resultMessageContent + `<p class="text-white">1 Stat Chip utilisé.</p>`;
        
        const newStatRankOrder = statRanks[newStatRankKey]?.order || 0;
        const oldStatRankOrder = statRanks[oldStatRank]?.order || 0;

        if (animationsEnabled && newStatRankOrder > oldStatRankOrder ) {
            confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: ['#22c55e', '#facc15', '#f97316'] });
        } else if (animationsEnabled && newStatRankOrder < oldStatRankOrder && (oldStatRank === "SSS" || (statKeepBetterToggle.checked && selectedTargetRanks.includes(oldStatRank)) ) ) {
            // Peut-être une petite animation "négative" si on perd un rang SSS ou une cible
            // Pour l'instant, pas d'animation spécifique pour la perte.
        }
        
        if (soundEnabled) { /* play some sound */ }
        
        updateStatChangeTabDisplay(); 
        updateCharacterDisplay();
        updateItemDisplay();
        updateUI();
        scheduleSave();
    }

    function updateMaterialFarmDisplay() {
      const materialLevelListElement = document.getElementById("materiaux-level-list");
      if (!materialLevelListElement) {
          console.error("Élément 'materiaux-level-list' non trouvé !");
          return;
      }

      // Vider le contenu et appliquer le style de grille au conteneur principal
      materialLevelListElement.innerHTML = "";
      materialLevelListElement.className = "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-8 gap-y-4";

      if (materialFarmLevels.length === 0) {
          materialLevelListElement.innerHTML = "<p class='text-white col-span-full text-center'>Aucun niveau de farm de matériaux disponible.</p>";
          return;
      }

      // Grouper les niveaux par 'world' pour créer une colonne par monde
      const groupedByWorld = materialFarmLevels.reduce((acc, level) => {
          (acc[level.world] = acc[level.world] || []).push(level);
          return acc;
      }, {});

      // Itérer sur chaque groupe (monde) pour créer une colonne
      Object.entries(groupedByWorld).forEach(([worldName, levels]) => {
          const worldColumnDiv = document.createElement('div');
          
          const worldTitle = document.createElement('h3');
          worldTitle.className = 'text-xl text-white font-bold mb-4';
          worldTitle.textContent = `${worldName} - Farm`;
          worldColumnDiv.appendChild(worldTitle);

          const buttonsContainer = document.createElement('div');
          buttonsContainer.className = 'flex flex-col gap-4'; // Empiler les boutons verticalement dans la colonne
          
          levels.forEach(level => {
              const progress = storyProgress.find(p => p.id === level.id) || { unlocked: true, completed: false };
              const isDisabled = !progress.unlocked;
              const buttonText = level.name;

              // Extraire les noms des drops possibles pour l'affichage
              const itemDrops = Array.isArray(level.rewards.itemChance) 
                  ? level.rewards.itemChance.map(ic => ic.item).join(', ') 
                  : (level.rewards.itemChance?.item || 'N/A');

              const levelWrapper = document.createElement('div');
              levelWrapper.innerHTML = `
                  <button class="w-full bg-indigo-600 hover:bg-indigo-700 text-white py-2 px-4 rounded-lg transition-colors duration-200 ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}"
                          onclick="startLevel(${level.id})" ${isDisabled ? 'disabled' : ''}>
                      ${buttonText}
                  </button>
                  <div class="text-xs text-gray-300 px-2 mt-1">
                      <p>Ennemi: ${level.enemy.name} (Puissance: ${level.enemy.power})</p>
                      <p>Drop possible: ${itemDrops}</p>
                  </div>
              `;
              buttonsContainer.appendChild(levelWrapper);
          });

          worldColumnDiv.appendChild(buttonsContainer);
          materialLevelListElement.appendChild(worldColumnDiv);
      });
    }

    function updateTraitTabDisplay() {
        traitEssenceCountElement.textContent = inventory["Reroll Token"] || 0;
        const searchInput = document.getElementById("trait-char-search");
        const searchTerm = searchInput.value.toLowerCase();

        let char = null;
        if (currentTraitCharacterId) {
            char = ownedCharacters.find(c => c.id === currentTraitCharacterId);
        }

        // Gérer le message d'info qui pourrait être affiché dans resultElement
        clearTimeout(infoMsgTraitTimeoutId); 
        infoMsgTraitTimeoutId = null;
        let infoMsgContentForDisplay = ""; 

        // Afficher le personnage sélectionné pour l'onglet Traits
        if (char) {
            let currentTraitNameHtml = "Aucun trait actif.";
            let currentTraitDescriptionHtml = "";

            if (char.trait && char.trait.id && char.trait.grade > 0) {
                const traitDef = TRAIT_DEFINITIONS[char.trait.id];
                if (traitDef && traitDef.grades) {
                    const gradeDef = traitDef.grades.find(g => g.grade === char.trait.grade);
                    if (gradeDef) {
                        let traitNameDisplay = traitDef.name;
                        let nameHtmlClass = ""; // Sera utilisé pour le nom du trait
                        let descriptionHtmlClass = "text-xs text-gray-300"; // Classe par défaut

                        if (traitDef.gradeProbabilities && traitDef.gradeProbabilities.length > 0) {
                            traitNameDisplay += ` (Grade ${gradeDef.grade})`;
                        }
                        
                        if (traitDef.id === 'golder' && gradeDef.description === "+15% Gemmes & Pièces (Tous modes)") {
                            nameHtmlClass = 'class="text-gold-brilliant"';
                            descriptionHtmlClass = "text-xs text-gold-brilliant";
                        } else if (traitDef.id === 'monarch') {
                            // Vous pouvez ajouter un style spécial pour Monarch ici si désiré
                            // nameHtmlClass = 'class="text-purple-400 font-bold"'; // Exemple
                        }
                        currentTraitNameHtml = `<span ${nameHtmlClass}>${traitNameDisplay}</span>`;
                        currentTraitDescriptionHtml = `<p class="${descriptionHtmlClass}"><em>${gradeDef.description}</em></p>`;
                    }
                }
            }
            traitSelectedCharacterDisplayElement.innerHTML = `
                <div class="bg-gray-800 bg-opacity-50 p-3 rounded-lg border-2 ${getRarityBorderClass(char.rarity)} w-full max-w-xs mx-auto">
                    <img src="${char.image}" alt="${char.name}" class="w-full h-28 object-contain rounded mb-1">
                    <p class="${char.color} font-semibold text-center text-sm">${char.name} (${char.rarity})</p>
                    <p class="text-white text-center text-xs">Niv: ${char.level}, P: ${char.power}</p>
                    <p class="text-white text-center text-xs">Trait: ${currentTraitNameHtml}</p>
                    ${currentTraitDescriptionHtml}
                </div>
            `;
            
            // Logique pour le message d'info concernant les traits cibles
            const currentTraitId = char.trait?.id;
            const currentTraitGrade = char.trait?.grade;
            const currentTraitDef = currentTraitId ? TRAIT_DEFINITIONS[currentTraitId] : null;

            if (traitKeepBetterToggle.checked && currentTraitId && currentTraitGrade > 0 && currentTraitDef) {
                const selectedTargetCheckboxes = Array.from(traitTargetSelectionElement.querySelectorAll(".trait-target-checkbox:checked"));
                const selectedTargetValues = selectedTargetCheckboxes.map(cb => cb.value);
                
                let currentTraitValueForCheck = null;
                if (currentTraitDef.gradeProbabilities && currentTraitDef.gradeProbabilities.length > 0) { 
                    currentTraitValueForCheck = `${currentTraitId}_${currentTraitGrade}`;
                } else { 
                    currentTraitValueForCheck = currentTraitId;
                }

                if (selectedTargetValues.includes(currentTraitValueForCheck)) {
                    let traitNameDisplayInfo = currentTraitDef.name;
                    if (currentTraitDef.gradeProbabilities && currentTraitDef.gradeProbabilities.length > 0) {
                        traitNameDisplayInfo += ` G${currentTraitGrade}`;
                    }
                    infoMsgContentForDisplay = `Info: ${char.name} a le trait cible coché "${traitNameDisplayInfo}". "Appliquer Trait" demandera confirmation.`;
                }
            }
        } else { // Aucun personnage sélectionné
            traitSelectedCharacterDisplayElement.innerHTML = '<p class="text-gray-400">Aucun personnage sélectionné.</p>';
        }
        
        // Afficher le message d'info si pertinent et si les conditions le permettent
        if (infoMsgContentForDisplay && (inventory["Reroll Token"] || 0) >= APPLY_NEW_TRAIT_COST && char) {
            // Vérifier que le message actuel n'est pas déjà un message important d'une autre feature
            if (!resultElement.innerHTML.includes("appliqué") && 
                !resultElement.innerHTML.includes("remplacé") && 
                !resultElement.innerHTML.includes("enlevé") &&
                !resultElement.innerHTML.includes("Changement de Stat") &&
                !resultElement.innerHTML.includes("malédiction") &&
                !resultElement.innerHTML.includes("Info: Le personnage")) { // Évite de remplacer un message d'info de curse/stat
               resultElement.innerHTML = `<p class="text-blue-400">${infoMsgContentForDisplay}</p>`;
               infoMsgTraitTimeoutId = setTimeout(() => {
                   if (resultElement.innerHTML.includes(infoMsgContentForDisplay)) { // Vérifie si c'est TOUJOURS ce message
                        resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`;
                   }
                   infoMsgTraitTimeoutId = null;
               }, 7000);
           }
        } else if (resultElement.innerHTML.startsWith('<p class="text-blue-400">Info: ') && resultElement.innerHTML.includes("trait cible coché")) {
            // Si un message d'info de trait était là et n'est plus pertinent (ex: perso désélectionné)
            if (!infoMsgContentForDisplay && char === null) { // Uniquement si aucun nouveau message d'info et aucun perso
                if (!resultElement.innerHTML.includes("Changement de Stat") && !resultElement.innerHTML.includes("malédiction")) {
                     resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`;
                }
            }
        }


        // Grille de sélection des personnages
        traitCharacterSelectionGridElement.innerHTML = "";
        const availableCharacters = ownedCharacters.filter(c =>
            c.name.toLowerCase().includes(searchTerm)
        );

        if (availableCharacters.length === 0) {
            traitCharacterSelectionGridElement.innerHTML = `<p class="text-gray-400 col-span-full">${searchTerm ? 'Aucun personnage trouvé pour "' + searchTerm + '".' : 'Aucun personnage disponible.'}</p>`;
        } else {
            availableCharacters.sort((a, b) => b.power - a.power).forEach(c => {
                const charElement = document.createElement("div");
                charElement.className = `bg-gray-800 bg-opacity-50 p-2 rounded-lg transition transform hover:scale-105 cursor-pointer border-2
                    ${currentTraitCharacterId === c.id ? 'selected-for-trait' : (getRarityBorderClass(c.rarity) || 'border-gray-600 hover:border-gray-500')}`;

                let traitDisplayMini = '';
                if (c.trait && c.trait.id && c.trait.grade > 0) {
                    const tDef = TRAIT_DEFINITIONS[c.trait.id];
                    if (tDef) {
                        const gradeDefMini = tDef.grades.find(g => g.grade === c.trait.grade);
                        let traitNameMini = tDef.name;
                        let miniTextColorClass = 'text-emerald-400'; 
                        
                        if (tDef.id === 'golder' && gradeDefMini?.description === "+15% Gemmes & Pièces (Tous modes)") {
                           miniTextColorClass = 'text-gold-brilliant'; 
                        }

                        if (tDef.gradeProbabilities && tDef.gradeProbabilities.length > 0) { 
                            traitDisplayMini = `<p class="text-xs text-center ${miniTextColorClass}">${traitNameMini} G${c.trait.grade}</p>`;
                        } else { 
                            traitDisplayMini = `<p class="text-xs text-center ${miniTextColorClass}">${traitNameMini}</p>`;
                        }
                    }
                }

                charElement.innerHTML = `
                    <img src="${c.image}" alt="${c.name}" class="w-full h-20 object-contain rounded mb-1">
                    <p class="${c.rarity === 'Secret' ? 'text-secret' : c.color} font-semibold text-xs text-center">${c.name} ${c.locked ? '🔒' : ''}</p>
                    <p class="text-white text-xs text-center">P: ${c.power}</p>
                    ${traitDisplayMini}
                `;
                charElement.addEventListener("click", () => selectTraitCharacter(c.id));
                traitCharacterSelectionGridElement.appendChild(charElement);
            });
        }

        // Activer/désactiver les checkboxes cibles
        const checkboxesDisabledTrait = !traitKeepBetterToggle.checked;
        traitTargetSelectionElement.classList.toggle("trait-target-disabled", checkboxesDisabledTrait);
        traitTargetSelectionElement.querySelectorAll(".trait-target-checkbox").forEach(cb => {
            cb.disabled = checkboxesDisabledTrait;
            if (checkboxesDisabledTrait) {
                cb.checked = false; 
            }
        });
        
        displayTraitActions(char); // Mettre à jour les boutons d'action en fonction du personnage sélectionné
    }

    function populateTargetTraits() {
        traitTargetSelectionElement.innerHTML = "";
        Object.entries(TRAIT_DEFINITIONS)
            .sort(([,a], [,b]) => (a.order || 0) - (b.order || 0)) // Trier par 'order'
            .forEach(([traitId, traitDef]) => {
                if (traitDef.grades && traitDef.grades.length > 0) {
                    const isMultiGrade = traitDef.gradeProbabilities && traitDef.gradeProbabilities.length > 0;

                    if (isMultiGrade) { // Pour les traits multi-grades (Force, Fortune)
                        traitDef.grades.forEach(gradeDef => {
                            const uniqueValue = `${traitId}_${gradeDef.grade}`;
                            const label = document.createElement("label");
                            label.className = `flex items-center p-1.5 rounded hover:bg-gray-600 transition-colors duration-150`;
                            
                            let displayName = traitDef.name;
                            let nameClass = 'text-white';
                            // Actuellement, Golder est mono-grade. Si un trait multi-grade devenait brillant,
                            // une logique similaire à celle des mono-grades serait nécessaire ici.

                            label.innerHTML = `
                                <input type="checkbox" value="${uniqueValue}" class="trait-target-checkbox mr-2 h-4 w-4 text-emerald-400 border-gray-400 rounded focus:ring-transparent">
                                <img src="${traitDef.image || 'https://via.placeholder.com/16?text=T'}" alt="${displayName}" class="w-4 h-4 mr-1 object-contain">
                                <span class="text-xs ${nameClass}">${displayName} G${gradeDef.grade}</span>
                            `;
                            const checkbox = label.querySelector('.trait-target-checkbox');
                            checkbox.addEventListener('change', () => {
                                if (traitKeepBetterToggle.checked) {
                                    updateTraitTabDisplay(); 
                                }
                            });
                            traitTargetSelectionElement.appendChild(label);
                        });
                    } else { // Pour les traits à grade unique
                        const uniqueValue = traitId; 
                        const label = document.createElement("label");
                        label.className = `flex items-center p-1.5 rounded hover:bg-gray-600 transition-colors duration-150`;
                        
                        let displayName = traitDef.name;
                        let nameClass = 'text-white';
                        if (traitDef.id === 'golder' && traitDef.grades[0]?.description === "+15% Gemmes & Pièces (Tous modes)") {
                            nameClass = 'text-gold-brilliant';
                        } else if (traitDef.id === 'monarch') { 
                            // Exemple: si Monarch doit avoir un style spécial
                            // nameClass = 'text-purple-400 font-bold'; // ou une autre classe
                        }


                        label.innerHTML = `
                            <input type="checkbox" value="${uniqueValue}" class="trait-target-checkbox mr-2 h-4 w-4 text-emerald-400 border-gray-400 rounded focus:ring-transparent">
                            <img src="${traitDef.image || 'https://via.placeholder.com/16?text=T'}" alt="${displayName}" class="w-4 h-4 mr-1 object-contain">
                            <span class="text-xs ${nameClass}">${displayName}</span>
                        `;
                        const checkbox = label.querySelector('.trait-target-checkbox');
                        checkbox.addEventListener('change', () => {
                            if (traitKeepBetterToggle.checked) {
                                updateTraitTabDisplay();
                            }
                        });
                        traitTargetSelectionElement.appendChild(label);
                    }
                }
            });
    }

    function openTraitActionConfirmModal(message, callback) {
        traitActionConfirmMessageElement.textContent = message;
        traitConfirmationCallback = callback;
        traitActionConfirmModal.classList.remove("hidden");
        enableNoScroll();
    }

    function closeTraitActionConfirmModal() {
        traitActionConfirmModal.classList.add("hidden");
        traitConfirmationCallback = null;
        disableNoScroll();
    }


    function selectTraitCharacter(charId) {
        currentTraitCharacterId = (currentTraitCharacterId === charId) ? null : charId;
        updateTraitTabDisplay();
    }

    function displayTraitActions(character) {
        const actionsContainer = document.getElementById('trait-actions-container');
        actionsContainer.innerHTML = ""; 

        const actionsTitle = document.createElement('h3');
        actionsTitle.className = "text-lg text-white font-semibold mb-3";
        actionsTitle.textContent = "Actions :";
        actionsContainer.appendChild(actionsTitle);

        const buttonsFlexContainer = document.createElement('div');
        buttonsFlexContainer.className = "flex flex-col md:flex-row md:flex-wrap md:items-center gap-3";
        actionsContainer.appendChild(buttonsFlexContainer);

        const rerollTokenCount = inventory["Reroll Token"] || 0;
        const APPLY_NEW_TRAIT_COST = 1; // Coût pour appliquer/écraser un trait

        const isCharSelected = character !== null;
        // const hasActiveTrait = isCharSelected && character.trait && character.trait.id && character.trait.grade > 0; // Plus nécessaire pour la logique du bouton principal

        // --- Bouton principal : Toujours "Appliquer Trait Aléatoire" ---
        const primaryActionButton = document.createElement('button');
        primaryActionButton.id = "primary-trait-action-button";
        primaryActionButton.className = "font-bold py-2 px-4 rounded-lg transition transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed";
        
        // Le texte du bouton est toujours le même, indique juste le coût
        primaryActionButton.textContent = `Appliquer Trait Aléatoire (${APPLY_NEW_TRAIT_COST} Reroll Token)`;
        primaryActionButton.classList.add("bg-sky-500", "hover:bg-sky-600", "text-white");

        // Désactivé si pas de personnage sélectionné, pas assez de tokens, ou aucun trait défini dans le jeu
        primaryActionButton.disabled = !isCharSelected || rerollTokenCount < APPLY_NEW_TRAIT_COST || Object.keys(TRAIT_DEFINITIONS).length === 0;

        if (!isCharSelected) {
            primaryActionButton.title = "Sélectionnez un personnage";
        } else if (rerollTokenCount < APPLY_NEW_TRAIT_COST) {
            primaryActionButton.title = "Reroll Token insuffisants";
        } else if (Object.keys(TRAIT_DEFINITIONS).length === 0) {
            primaryActionButton.title = "Aucun trait n'est défini dans le jeu";
        }
        
        // L'action est toujours d'essayer d'appliquer un nouveau trait (qui écrasera l'ancien si existant)
        primaryActionButton.addEventListener('click', () => tryRandomTrait()); // On ne passe plus 'true' ou 'false'

        buttonsFlexContainer.appendChild(primaryActionButton);

        // Le bouton "Enlever le Trait" n'est plus créé.
    }

    function getRandomTraitIdByProbability() {
        const traitIds = Object.keys(TRAIT_DEFINITIONS);
        if (traitIds.length === 0) return null;

        let randomNumber = Math.random();
        let cumulativeProbability = 0;

        for (const traitId of traitIds) {
            const traitDef = TRAIT_DEFINITIONS[traitId];
            if (traitDef && typeof traitDef.probability === 'number') {
                cumulativeProbability += traitDef.probability;
                if (randomNumber <= cumulativeProbability) {
                    return traitId;
                }
            } else {
                console.warn(`Trait ${traitId} n'a pas de probabilité définie ou est mal configuré.`);
            }
        }
        // Fallback si la somme des probabilités n'est pas 1 ou en cas d'erreur
        console.warn("Fallback dans getRandomTraitIdByProbability - la somme des probabilités n'est peut-être pas 1 ou une erreur de configuration.");
        return traitIds[Math.floor(Math.random() * traitIds.length)];
    }

    async function tryRandomTrait() {
        if (!currentTraitCharacterId) {
            resultElement.innerHTML = '<p class="text-red-400">Aucun personnage sélectionné.</p>';
            return;
        }
        const charIndex = ownedCharacters.findIndex(c => c.id === currentTraitCharacterId);
        if (charIndex === -1) {
            resultElement.innerHTML = '<p class="text-red-400">Erreur: Personnage non trouvé.</p>';
            return;
        }
        const character = ownedCharacters[charIndex];

        const APPLY_COST = 1; 
        if ((inventory["Reroll Token"] || 0) < APPLY_COST) {
            resultElement.innerHTML = `<p class="text-red-400">Pas assez de Reroll Token (${APPLY_COST} requis).</p>`;
            return;
        }

        let needsConfirmation = false;
        let confirmMessage = "";
        const currentTraitId = character.trait?.id;
        const currentTraitGrade = character.trait?.grade;
        const currentTraitDef = currentTraitId ? TRAIT_DEFINITIONS[currentTraitId] : null;


        if (traitKeepBetterToggle.checked && currentTraitId && currentTraitGrade > 0 && currentTraitDef) {
            const selectedTargetCheckboxes = Array.from(traitTargetSelectionElement.querySelectorAll(".trait-target-checkbox:checked"));
            const selectedTargetValues = selectedTargetCheckboxes.map(cb => cb.value);
            
            let currentTraitValueForCheck = null;
            if (currentTraitDef.gradeProbabilities && currentTraitDef.gradeProbabilities.length > 0) { 
                currentTraitValueForCheck = `${currentTraitId}_${currentTraitGrade}`;
            } else { 
                currentTraitValueForCheck = currentTraitId;
            }

            if (selectedTargetValues.includes(currentTraitValueForCheck)) {
                needsConfirmation = true;
                let traitNameDisplay = currentTraitDef.name;
                if (currentTraitDef.gradeProbabilities && currentTraitDef.gradeProbabilities.length > 0) {
                    traitNameDisplay += ` G${currentTraitGrade}`;
                }
                confirmMessage = `Le personnage ${character.name} a déjà le trait cible "${traitNameDisplay}". Voulez-vous vraiment utiliser un Reroll Token pour tenter un autre trait ? Le nouveau trait obtenu sera appliqué.`;
            }
        }

        if (needsConfirmation) {
            const userConfirmed = await new Promise(resolve => {
                traitConfirmationCallback = (confirmed) => resolve(confirmed);
                openTraitActionConfirmModal(confirmMessage, traitConfirmationCallback); // Utilise la nouvelle modale
            });
            traitConfirmationCallback = null;

            if (!userConfirmed) {
                resultElement.innerHTML = `<p class="text-blue-400">Application de trait annulée. Aucun Reroll Token utilisé.</p>`;
                updateTraitTabDisplay();
                return;
            }
        }
        
        if ((inventory["Reroll Token"] || 0) < APPLY_COST) {
            resultElement.innerHTML = '<p class="text-red-500">Erreur : Plus de Reroll Tokens disponibles après confirmation.</p>';
            updateTraitTabDisplay();
            return;
        }

        inventory["Reroll Token"] -= APPLY_COST;

        missions.forEach(mission => {
            if (mission.type === "apply_trait" && !mission.completed) {
                mission.progress++;
            }
        });

        const randomTraitId = getRandomTraitIdByProbability();
        if (!randomTraitId) {
            resultElement.innerHTML = `<p class="text-yellow-400">Aucun trait n'a pu être tiré.</p>`;
            inventory["Reroll Token"] += APPLY_COST; 
            updateTraitTabDisplay();
            return;
        }

        const newTraitDef = TRAIT_DEFINITIONS[randomTraitId];
        if (!newTraitDef || !newTraitDef.grades || newTraitDef.grades.length === 0) {
            resultElement.innerHTML = `<p class="text-red-500">Erreur de configuration pour le trait ${randomTraitId}.</p>`;
            inventory["Reroll Token"] += APPLY_COST; 
            updateTraitTabDisplay();
            return;
        }

        const chosenGrade = getRandomGradeForTrait(newTraitDef);

        const oldTraitExisted = character.trait && character.trait.id && character.trait.grade > 0;
        const oldTraitName = oldTraitExisted && TRAIT_DEFINITIONS[character.trait.id] ? (TRAIT_DEFINITIONS[character.trait.id].name) : null;
        const oldTraitGrade = oldTraitExisted ? character.trait.grade : null;
        const oldTraitDef = oldTraitExisted && TRAIT_DEFINITIONS[character.trait.id] ? TRAIT_DEFINITIONS[character.trait.id] : null;

        character.trait = { id: randomTraitId, grade: chosenGrade.grade };
        recalculateCharacterPower(character);

        let message = "";
        if (oldTraitExisted && oldTraitName && oldTraitDef) {
            message = `<p class="text-orange-400">Trait ${oldTraitName}${oldTraitDef.gradeProbabilities && oldTraitDef.gradeProbabilities.length > 0 ? ` (Grade ${oldTraitGrade})` : ''} remplacé sur ${character.name}!</p>`;
        } else {
            message = `<p class="text-green-400">Trait aléatoire appliqué à ${character.name}!</p>`;
        }
        message += `<p class="text-white">Nouveau trait: ${newTraitDef.name}${newTraitDef.gradeProbabilities && newTraitDef.gradeProbabilities.length > 0 ? ` (Grade ${chosenGrade.grade})` : ''}.</p>`;
        message += `<p class="text-white">Effet: ${chosenGrade.description}</p>`;
        message += `<p class="text-white">Nouvelle Puissance: ${character.power}. Coût: ${APPLY_COST} Reroll Token.</p>`;
        resultElement.innerHTML = message;

        if (animationsEnabled) confetti({ particleCount: 80, spread: 60, origin: { y: 0.7 }, colors: ['#3B82F6', '#8B5CF6'] });
        
        updateTraitTabDisplay();
        updateCharacterDisplay();
        updateItemDisplay();
        updateUI();
        scheduleSave();
    }

    function upgradeSpecificTrait(traitIdToUpgrade) {
        // Cette fonction est appelée si le personnage a déjà le trait traitIdToUpgrade et qu'il n'est pas au max.
        if (!currentTraitCharacterId) { /* ... error ... */ return; }
        const charIndex = ownedCharacters.findIndex(c => c.id === currentTraitCharacterId);
        if (charIndex === -1) { /* ... error ... */ return; }
        const character = ownedCharacters[charIndex];

        if (!character.trait || character.trait.id !== traitIdToUpgrade || character.trait.level === 0) {
            resultElement.innerHTML = `<p class="text-red-400">Le personnage n'a pas ce trait actif ou une erreur s'est produite.</p>`;
            return;
        }

        const traitDef = TRAIT_DEFINITIONS[traitIdToUpgrade];
        if (!traitDef) { /* ... error ... */ return; }

        const currentLevel = character.trait.level;
        if (currentLevel >= traitDef.maxLevel) {
            resultElement.innerHTML = `<p class="text-yellow-400">${traitDef.name} est déjà au niveau maximum.</p>`;
            return;
        }

        const nextLevelInfo = traitDef.effectsPerLevel.find(e => e.level === currentLevel + 1);
        if (!nextLevelInfo) {
            resultElement.innerHTML = `<p class="text-red-500">Erreur de configuration pour le prochain niveau de ${traitDef.name}.</p>`;
            return;
        }

        if ((inventory["Reroll Token"] || 0) < nextLevelInfo.cost) {
            resultElement.innerHTML = `<p class="text-red-400">Pas assez de Reroll Token (${nextLevelInfo.cost} requis pour améliorer).</p>`;
            return;
        }

        inventory["Reroll Token"] -= nextLevelInfo.cost;
        character.trait.level++; // Incrémenter le niveau du trait existant
        recalculateCharacterPower(character);

        resultElement.innerHTML = `
            <p class="text-green-400">Trait ${traitDef.name} amélioré au Niv. ${character.trait.level} pour ${character.name}!</p>
            <p class="text-white">Effet: ${nextLevelInfo.description}</p>
            <p class="text-white">Nouvelle Puissance: ${character.power}. Coût: ${nextLevelInfo.cost} Essences.</p>
        `;

        if (animationsEnabled) confetti({ particleCount: 80, spread: 60, origin: { y: 0.7 }, colors: ['#10B981', '#6EE7B7'] });

        updateTraitTabDisplay();
        updateCharacterDisplay();
        updateItemDisplay();
        updateUI();
        scheduleSave();
    }

    function rerollTrait() {
        if (!currentTraitCharacterId) {
            resultElement.innerHTML = '<p class="text-red-400">Aucun personnage sélectionné.</p>';
            return;
        }
        const charIndex = ownedCharacters.findIndex(c => c.id === currentTraitCharacterId);
        if (charIndex === -1) {
            resultElement.innerHTML = '<p class="text-red-400">Erreur: Personnage non trouvé.</p>';
            return;
        }
        const character = ownedCharacters[charIndex];

        if (!character.trait || !character.trait.id || character.trait.grade === 0) { // MODIFIÉ: .grade
            resultElement.innerHTML = '<p class="text-yellow-400">Le personnage n\'a pas de trait actif à changer.</p>';
            return;
        }

        const REROLL_TRAIT_COST = 2;
        if ((inventory["Reroll Token"] || 0) < REROLL_TRAIT_COST) {
            resultElement.innerHTML = `<p class="text-red-400">Pas assez de Reroll Token (${REROLL_TRAIT_COST} requis pour changer).</p>`;
            return;
        }

        const currentTraitId = character.trait.id;
        const oldTraitName = TRAIT_DEFINITIONS[currentTraitId]?.name || "Trait Précédent";

        const availableNewTraitIds = Object.keys(TRAIT_DEFINITIONS).filter(id => id !== currentTraitId);

        if (availableNewTraitIds.length === 0 && Object.keys(TRAIT_DEFINITIONS).length <= 1) {
             resultElement.innerHTML = `<p class="text-yellow-400">Aucun autre type de trait disponible pour un changement. (Actuellement ${Object.keys(TRAIT_DEFINITIONS).length} trait(s) défini(s) au total)</p>`;
            return;
        }
        
        let randomNewTraitId;
        if (availableNewTraitIds.length > 0) {
            randomNewTraitId = availableNewTraitIds[Math.floor(Math.random() * availableNewTraitIds.length)];
        } else { // S'il n'y a pas d'AUTRE trait, on re-tire le même type de trait (mais potentiellement un grade différent)
            randomNewTraitId = currentTraitId;
        }


        inventory["Reroll Token"] -= REROLL_TRAIT_COST;
        
        const newTraitDef = TRAIT_DEFINITIONS[randomNewTraitId];
        if (!newTraitDef || !newTraitDef.grades || newTraitDef.grades.length === 0) {
            resultElement.innerHTML = `<p class="text-red-500">Erreur de configuration pour le nouveau trait ${randomNewTraitId}.</p>`;
            inventory["Reroll Token"] += REROLL_TRAIT_COST; // Rembourser
            updateTraitTabDisplay();
            return;
        }

        // Assigner un grade aléatoire (1, 2, ou 3) pour le nouveau trait basé sur ses probabilités
        const chosenGrade = getRandomGradeForTrait(newTraitDef); // MODIFIÉ ICI
        
        character.trait = { id: randomNewTraitId, grade: chosenGrade.grade };
        recalculateCharacterPower(character);

        let message = `<p class="text-green-400">Trait changé aléatoirement pour ${character.name}!</p>`;
        if (randomNewTraitId === currentTraitId) {
            message += `<p class="text-white">Le trait ${oldTraitName} a été re-tiré avec un nouveau Grade ${chosenGrade.grade}.</p>`;
        } else {
            message += `<p class="text-white">Ancien trait (${oldTraitName}) remplacé par ${newTraitDef.name} (Grade ${chosenGrade.grade}).</p>`;
        }
        message += `<p class="text-white">Effet: ${chosenGrade.description}</p>`;
        message += `<p class="text-white">Nouvelle Puissance: ${character.power}. Coût: ${REROLL_TRAIT_COST} Reroll Token.</p>`;
        resultElement.innerHTML = message;

        if (animationsEnabled) confetti({ particleCount: 80, spread: 60, origin: { y: 0.7 }, colors: ['#F97316', '#FDBA74'] });
        
        updateTraitTabDisplay();
        updateCharacterDisplay();
        updateItemDisplay();
        updateUI();
        scheduleSave();
    }


    function removeTrait() {
        if (!currentTraitCharacterId) { /* ... error ... */ return; }
        const charIndex = ownedCharacters.findIndex(c => c.id === currentTraitCharacterId);
        if (charIndex === -1) { /* ... error ... */ return; }
        const character = ownedCharacters[charIndex];

        if (!character.trait || !character.trait.id || character.trait.level === 0) {
            resultElement.innerHTML = `<p class="text-yellow-400">${character.name} n'a pas de trait actif à enlever.</p>`;
            return;
        }
        if ((inventory["Reroll Token"] || 0) < TRAIT_REMOVAL_COST) {
            resultElement.innerHTML = `<p class="text-red-400">Pas assez de Reroll Token pour enlever le trait (${TRAIT_REMOVAL_COST} requis).</p>`;
            return;
        }

        inventory["Reroll Token"] -= TRAIT_REMOVAL_COST;
        const removedTraitName = TRAIT_DEFINITIONS[character.trait.id]?.name || "Trait Inconnu";
        character.trait = { id: null, level: 0 };
        recalculateCharacterPower(character);

        resultElement.innerHTML = `
            <p class="text-orange-400">Le trait ${removedTraitName} a été enlevé de ${character.name}.</p>
            <p class="text-white">Nouvelle Puissance: ${character.power}. Coût: ${TRAIT_REMOVAL_COST} Reroll Token.</p>
        `;

        updateTraitTabDisplay();
        updateCharacterDisplay();
        updateItemDisplay();
        updateUI();
        scheduleSave();
    }

    function updateCurseTabDisplay() {
      cursedTokenCountElement.textContent = inventory["Cursed Token"] || 0;
      const searchInputCurse = document.getElementById("curse-char-search");
      const searchTermCurse = searchInputCurse.value.toLowerCase();

      // Afficher le personnage sélectionné pour la malédiction
      if (currentCurseCharacterId) {
        const char = ownedCharacters.find(c => c.id === currentCurseCharacterId);
        if (char) {
          let selectedCurseInfoHtml = ''; // HTML pour l'info de la malédiction du perso sélectionné
          if (char.curseEffect && char.curseEffect !== 0) {
              const basePowerForSelected = char.basePower * char.statModifier;
              let percentageChangeSelected = 0;
              if (basePowerForSelected !== 0) {
                   percentageChangeSelected = ((char.curseEffect / basePowerForSelected) * 100);
              } else if (char.basePower !== 0) {
                   percentageChangeSelected = ((char.curseEffect / char.basePower) * 100);
              }
              const displayPercentageSelected = percentageChangeSelected.toFixed(percentageChangeSelected % 1 === 0 ? 0 : (Math.abs(percentageChangeSelected) < 1 ? 2 : 1));
              const curseClassSelected = char.curseEffect > 0 ? 'text-green-400' : 'text-red-400';
              const signSelected = char.curseEffect > 0 ? '+' : '';
              selectedCurseInfoHtml = `<p class="text-white text-center">Curse: <span class="${curseClassSelected}">${signSelected}${displayPercentageSelected}%</span></p>`;
          }

          curseSelectedCharacterDisplayElement.innerHTML = `
            <div class="bg-gray-800 bg-opacity-50 p-4 rounded-lg border-2 ${getRarityBorderClass(char.rarity)} w-full max-w-xs mx-auto">
              <img src="${char.image}" alt="${char.name}" class="w-full h-32 object-contain rounded mb-2">
              <p class="${char.color} font-semibold text-center">${char.name} (<span class="${char.rarity === 'Mythic' ? 'rainbow-text' : ''}">${char.rarity}</span>, Niv. ${char.level})</p>
              <p class="text-white text-center">Puissance: ${char.power}</p>
              ${selectedCurseInfoHtml}
            </div>
          `;
        } else {
          curseSelectedCharacterDisplayElement.innerHTML = '<p class="text-gray-400">Personnage non trouvé.</p>';
          currentCurseCharacterId = null; 
        }
      } else {
        curseSelectedCharacterDisplayElement.innerHTML = '<p class="text-gray-400">Aucun personnage sélectionné.</p>';
      }

      // Remplir la grille de sélection des personnages
      curseCharacterSelectionGridElement.innerHTML = "";
      const availableCharacters = ownedCharacters.filter(char => 
          char.name.toLowerCase().includes(searchTermCurse)
      ); 

      if (availableCharacters.length === 0) {
        curseCharacterSelectionGridElement.innerHTML = `<p class="text-gray-400 col-span-full">${searchTermCurse ? 'Aucun personnage trouvé pour "' + searchTermCurse + '".' : 'Aucun personnage disponible pour la malédiction.'}</p>`;
      } else {
        availableCharacters.sort((a, b) => b.power - a.power).forEach(char => {
          const charElement = document.createElement("div");
          charElement.className = `bg-gray-800 bg-opacity-50 p-2 rounded-lg transition transform hover:scale-105 cursor-pointer border-2 ${
            currentCurseCharacterId === char.id ? 'selected-for-curse' : (getRarityBorderClass(char.rarity) || 'border-gray-600 hover:border-gray-500')
          }`; 
          
          let curseDisplayHtml = '';
            if (char.curseEffect && char.curseEffect !== 0) {
                const basePowerForCurseDisplay = (char.basePower || char.power) * (char.statModifier || 1); // Fallback pour basePower et statModifier
                let cursePercentage = 0;
                if (basePowerForCurseDisplay !== 0) {
                    cursePercentage = (char.curseEffect / basePowerForCurseDisplay) * 100;
                } else if ((char.basePower || char.power) !== 0) { 
                    cursePercentage = (char.curseEffect / (char.basePower || char.power)) * 100;
                }
                const displayCursePercentage = cursePercentage.toFixed(cursePercentage % 1 === 0 ? 0 : (Math.abs(cursePercentage) < 0.1 ? 2 : 1));
                const curseColor = char.curseEffect > 0 ? 'text-green-400' : 'text-red-400';
                const curseSign = char.curseEffect > 0 ? '+' : '';
                curseDisplayHtml = `, <span class="text-xs ${curseColor}">Curse: ${curseSign}${displayCursePercentage}%</span>`;
            }

          charElement.innerHTML = `
            <img src="${char.image}" alt="${char.name}" class="w-full h-24 object-contain rounded mb-1">
            <p class="${char.rarity === 'Secret' ? 'text-secret' : char.color} font-semibold text-xs text-center">${char.name} ${char.locked ? '🔒' : ''}</p>
            <p class="text-white text-xs text-center">
              <span class="${char.rarity === 'Mythic' ? 'rainbow-text' : (char.rarity === 'Secret' ? 'text-secret' : '')}">${char.rarity}</span>, 
              P: ${char.power}${curseDisplayHtml}
            </p>
          `;
          charElement.addEventListener("click", () => {
            selectCurseCharacter(char.id);
          });
          curseCharacterSelectionGridElement.appendChild(charElement);
        });
      }

      let disableApplyCurseButton = !currentCurseCharacterId || (inventory["Cursed Token"] || 0) < 1;
      
      if (currentCurseCharacterId && curseKeepBetterToggle.checked) {
          const char = ownedCharacters.find(c => c.id === currentCurseCharacterId);
          if (char) {
              const basePowerForCheck = (char.basePower || char.power) * (char.statModifier || 1);
              let currentCurseEffectPercentageForCheck = 0;
              if ((char.curseEffect || 0) !== 0 && basePowerForCheck !== 0) {
                  currentCurseEffectPercentageForCheck = ((char.curseEffect || 0) / basePowerForCheck) * 100;
              }

              const minTargetPercentageCheck = parseFloat(curseMinPercentageInput.value);

              if (currentCurseEffectPercentageForCheck >= minTargetPercentageCheck) {
                  // Le bouton reste actif, mais on informe l'utilisateur.
                  // La pop-up gérera la confirmation avant d'utiliser un token.
                  if ((inventory["Cursed Token"] || 0) >= 1 && resultElement.innerHTML.indexOf("malédiction cible") === -1) {
                      resultElement.innerHTML = `<p class="text-blue-400">Info: Le personnage ${char.name} a déjà un effet de malédiction (${currentCurseEffectPercentageForCheck.toFixed(1)}%) qui atteint ou dépasse votre cible. Utiliser "Apply Curse" demandera confirmation.</p>`;
                      setTimeout(() => {
                          if (resultElement.innerHTML.includes("Info: Le personnage")) {
                              resultElement.innerHTML = `<p class="text-white text-lg">Tire pour obtenir des personnages légendaires !</p>`;
                          }
                      }, 7000);
                  }
              }
          }
      }

      applyCurseButton.disabled = disableApplyCurseButton;
      applyCurseButton.classList.toggle("opacity-50", applyCurseButton.disabled);
      applyCurseButton.classList.toggle("cursor-not-allowed", applyCurseButton.disabled);
      
      curseMinPercentageInput.disabled = !curseKeepBetterToggle.checked;
      if (!curseKeepBetterToggle.checked) {
        curseMinPercentageInput.classList.add("opacity-50", "cursor-not-allowed");
      } else {
        curseMinPercentageInput.classList.remove("opacity-50", "cursor-not-allowed");
      }
    }

    // NOUVELLE FONCTION : selectCurseCharacter
    function selectCurseCharacter(id) {
      if (currentCurseCharacterId === id) { // Déselectionner si on clique sur le même
        currentCurseCharacterId = null;
      } else {
        currentCurseCharacterId = id;
      }
      updateCurseTabDisplay();
    }

    // NOUVELLE FONCTION : applyCurse
    async function applyCurse() {
      if (!currentCurseCharacterId) {
        resultElement.innerHTML = '<p class="text-red-400">Veuillez sélectionner un personnage !</p>';
        return;
      }
      if ((inventory["Cursed Token"] || 0) < 1) {
        resultElement.innerHTML = '<p class="text-red-400">Vous n\'avez pas de Cursed Tokens !</p>';
        return;
      }

      const charIndex = ownedCharacters.findIndex(c => c.id === currentCurseCharacterId);
      if (charIndex === -1) {
        resultElement.innerHTML = '<p class="text-red-400">Personnage sélectionné non trouvé !</p>';
        currentCurseCharacterId = null;
        updateCurseTabDisplay();
        return;
      }

      const char = ownedCharacters[charIndex];
      
      if (typeof char.basePower === 'undefined' || char.basePower <= 0) {
          char.basePower = char.power > (char.curseEffect || 0) ? char.power - (char.curseEffect || 0) : (char.power / (char.statModifier || 1));
          if (char.basePower <= 0) char.basePower = 50; // Ultime fallback
          console.warn(`basePower manquant ou invalide pour ${char.name}, recalculé à ${char.basePower}`);
          recalculateCharacterPower(char); // S'assurer que la puissance est à jour avant de maudire
      }
      if (typeof char.statModifier === 'undefined') {
          char.statModifier = statRanks[char.statRank]?.modifier || 1;
      }


      let needsCurseConfirmation = false;
      let curseConfirmMessage = "";
      const basePowerWithStatForCheck = char.basePower * char.statModifier;
      let currentCurseEffectPercentageForCheck = 0;

      if ((char.curseEffect || 0) !== 0 && basePowerWithStatForCheck !== 0) {
          currentCurseEffectPercentageForCheck = ((char.curseEffect || 0) / basePowerWithStatForCheck) * 100;
      }

      if (curseKeepBetterToggle.checked) {
        const minTargetPercentageCheck = parseFloat(curseMinPercentageInput.value);
        if (currentCurseEffectPercentageForCheck >= minTargetPercentageCheck) {
          needsCurseConfirmation = true;
          curseConfirmMessage = `Le personnage ${char.name} a déjà un effet de malédiction de ${currentCurseEffectPercentageForCheck.toFixed(1)}%, ce qui est supérieur ou égal à votre cible de ${minTargetPercentageCheck}%. Voulez-vous vraiment utiliser un Cursed Token pour tenter d'obtenir un autre effet ? La nouvelle malédiction sera appliquée quel que soit son effet.`;
        }
      }
      
      console.log(`[applyCurse] currentCurseEffectPercentageForCheck: ${currentCurseEffectPercentageForCheck.toFixed(1)}%, curseKeepBetterToggle.checked: ${curseKeepBetterToggle.checked}, needsCurseConfirmation: ${needsCurseConfirmation}`);

      if (needsCurseConfirmation) {
        console.log(`[applyCurse] Ouverture de la modale de confirmation de malédiction avec le message : "${curseConfirmMessage}"`);
        const userConfirmed = await new Promise(resolve => {
          curseConfirmationCallback = (confirmed) => resolve(confirmed);
          openCurseConfirmModal(curseConfirmMessage, curseConfirmationCallback);
        });
        curseConfirmationCallback = null;

        if (!userConfirmed) {
          resultElement.innerHTML = `<p class="text-blue-400">Application de la malédiction annulée. Aucun Cursed Token n'a été utilisé.</p>`;
          updateCurseTabDisplay();
          return; 
        }
      } else {
        console.log(`[applyCurse] Aucune confirmation de malédiction nécessaire.`);
      }
      
      if ((inventory["Cursed Token"] || 0) < 1) { 
           resultElement.innerHTML = '<p class="text-red-500">Erreur : Plus de Cursed Tokens disponibles pour cette tentative.</p>';
           updateCurseTabDisplay();
           return;
      }

      inventory["Cursed Token"]--; 

      missions.forEach(mission => {
          if (mission.type === "curse_char" && !mission.completed) {
              mission.progress++;
          }
      });

      const powerBeforeThisCurse = char.power; 
      // const currentCurseEffectValue = char.curseEffect || 0; // Plus utilisé directement pour la décision d'appliquer

      const basePowerWithStat = char.basePower * char.statModifier;
      // Générer un effet de malédiction entre -20% et +20% de la puissance de base (avant malédiction mais après stat rank)
      const percentageChangeRandom = (Math.random() * 0.40) - 0.20; // De -0.20 à +0.20
      const newPowerDeltaFromCurse = Math.round(basePowerWithStat * percentageChangeRandom);

      let newCurseEffectPercentage = 0;
      if (basePowerWithStat !== 0) {
          newCurseEffectPercentage = (newPowerDeltaFromCurse / basePowerWithStat) * 100;
      } else if (char.basePower !== 0) { // Fallback
          newCurseEffectPercentage = (newPowerDeltaFromCurse / char.basePower) * 100;
      }
      
      // La nouvelle malédiction est TOUJOURS appliquée si on arrive ici
      char.curseEffect = newPowerDeltaFromCurse;
      recalculateCharacterPower(char); 

      const displayPercentageForResult = newCurseEffectPercentage.toFixed(newCurseEffectPercentage % 1 === 0 ? 0 : (Math.abs(newCurseEffectPercentage) < 0.1 ? 2 : 1));
      const signForResult = newPowerDeltaFromCurse >= 0 ? '+' : '';

      resultElement.innerHTML = `
        <p class="text-green-400">${char.name} a été maudit !</p>
        <p class="text-white">Puissance avant cette malédiction: ${powerBeforeThisCurse}.</p>
        <p class="text-white">Effet de la nouvelle malédiction: <span class="${newPowerDeltaFromCurse >= 0 ? 'text-green-400' : 'text-red-400'}">${signForResult}${displayPercentageForResult}%</span>.</p>
        <p class="text-white">Nouvelle Puissance totale: ${char.power}.</p>
        <p class="text-white">1 Cursed Token utilisé.</p>
      `;
      if (animationsEnabled && Math.abs(newPowerDeltaFromCurse) > basePowerWithStat * 0.05) { // Confetti pour les changements notables
        confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 }, colors: ['#7F00FF', '#000000', '#DC143C'] });
      }
      
      if (soundEnabled) { /* curseSound.play(); */ } 

      updateCurseTabDisplay();
      updateCharacterDisplay(); 
      updateItemDisplay(); 
      updateUI();
      scheduleSave();
    }

    function openCurseConfirmModal(message, callback) {
        curseConfirmMessageElement.textContent = message;
        curseConfirmationCallback = callback; // Stocker la fonction à appeler après le choix
        curseConfirmContinueModal.classList.remove("hidden");
        enableNoScroll(); // Empêcher le défilement de l'arrière-plan
    }

    function closeCurseConfirmModal() {
        curseConfirmContinueModal.classList.add("hidden");
        curseConfirmationCallback = null; // Réinitialiser le callback
        disableNoScroll(); // Rétablir le défilement
    }

    function launchMiniGame(levelData, selectedTeam) {
        console.log("Lancement du mini-jeu avec le niveau:", levelData.name);

        // 1. Calculer les paramètres du jeu
        miniGameState.levelData = levelData;
        miniGameState.bossMaxHealth = levelData.enemy.power;
        miniGameState.bossCurrentHealth = levelData.enemy.power;
        miniGameState.damagePerClick = selectedTeam.reduce((sum, char) => sum + char.power, 0);
        miniGameState.timer = 30;
        miniGameState.isActive = false;

        // 2. Initialiser l'affichage
        document.getElementById('mini-game-title').textContent = levelData.name;
        document.getElementById('mini-game-boss-name').textContent = levelData.enemy.name;
        
        // NOUVELLE LIGNE : Met à jour dynamiquement l'image du boss
        document.getElementById('mini-game-boss-image').src = levelData.enemy.image || './images/default-boss.png'; // Utilise une image par défaut si non spécifiée

        miniGameTimerEl.textContent = miniGameState.timer;
        miniGameHealthBar.style.width = '100%';
        miniGameHealthText.textContent = `${miniGameState.bossCurrentHealth.toLocaleString()} / ${miniGameState.bossMaxHealth.toLocaleString()}`;

        // 3. Afficher le bon écran et la modale
        miniGameStartScreen.classList.remove('hidden');
        miniGameMainScreen.classList.add('hidden');
        miniGameResultScreen.classList.add('hidden');
        miniGameModal.classList.remove('hidden');
        enableNoScroll();
    }

    function startMiniGame() {
        console.log("Début du timer et du jeu.");
        miniGameState.isActive = true;

        miniGameStartScreen.classList.add('hidden');
        miniGameMainScreen.classList.remove('hidden');

        miniGameState.intervalId = setInterval(() => {
            miniGameState.timer--;
            miniGameTimerEl.textContent = miniGameState.timer;

            if (miniGameState.timer <= 0) {
                endMiniGame(false); // Défaite
            }
        }, 1000);
    }

    function handleBossClick(event) {
        if (!miniGameState.isActive) return;

        // Appliquer les dégâts
        miniGameState.bossCurrentHealth -= miniGameState.damagePerClick;

        // Effet visuel sur le boss
        miniGameBossImage.classList.add('hit');
        setTimeout(() => miniGameBossImage.classList.remove('hit'), 75);

        // Afficher un numéro de dégât flottant
        const damageNumber = document.createElement('div');
        damageNumber.className = 'damage-number';
        damageNumber.textContent = `-${miniGameState.damagePerClick.toLocaleString()}`;
        // Positionner le numéro aléatoirement autour du point de clic
        const rect = miniGameClickArea.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        damageNumber.style.left = `${x - 20}px`;
        damageNumber.style.top = `${y - 20}px`;
        miniGameDamageContainer.appendChild(damageNumber);
        // Nettoyer l'élément du DOM après l'animation
        setTimeout(() => damageNumber.remove(), 700);


        // Mettre à jour la barre de vie
        if (miniGameState.bossCurrentHealth <= 0) {
            miniGameState.bossCurrentHealth = 0;
            updateHealthBar();
            endMiniGame(true); // Victoire
        } else {
            updateHealthBar();
        }
    }

    function updateHealthBar() {
        const healthPercentage = (miniGameState.bossCurrentHealth / miniGameState.bossMaxHealth) * 100;
        miniGameHealthBar.style.width = `${healthPercentage}%`;
        miniGameHealthText.textContent = `${miniGameState.bossCurrentHealth.toLocaleString()} / ${miniGameState.bossMaxHealth.toLocaleString()}`;
    }

    function endMiniGame(isVictory) {
        clearInterval(miniGameState.intervalId);
        miniGameState.isActive = false;

        const resultTitleEl = document.getElementById('mini-game-result-title');
        const resultRewardsEl = document.getElementById('mini-game-result-rewards');
        
        if (isVictory) {
            resultTitleEl.textContent = "Victoire !";
            resultTitleEl.className = "text-4xl font-bold mb-4 text-green-400";

            // Appliquer les récompenses
            const rewards = miniGameState.levelData.rewards;
            addGems(rewards.gems);
            coins += rewards.coins;
            addExp(rewards.exp);
            
            let rewardText = `Vous avez gagné : +${rewards.gems} gemmes, +${rewards.coins} pièces, +${rewards.exp} EXP.`;

            // Gérer le drop d'objet
            if (rewards.itemChance && Math.random() < rewards.itemChance.probability) {
                const item = rewards.itemChance.item;
                const quantity = rewards.itemChance.minQuantity; // Pour la simplicité
                inventory[item] = (inventory[item] || 0) + quantity;
                rewardText += ` Et +${quantity} ${item} !`;
            }

            resultRewardsEl.textContent = rewardText;
            if (animationsEnabled) confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });

        } else {
            resultTitleEl.textContent = "Temps Écoulé !";
            resultTitleEl.className = "text-4xl font-bold mb-4 text-red-500";
            resultRewardsEl.textContent = "Vous n'avez pas réussi à vaincre le boss à temps. Améliorez votre équipe et réessayez !";
        }

        // Afficher l'écran de résultat
        miniGameMainScreen.classList.add('hidden');
        miniGameResultScreen.classList.remove('hidden');

        // Mettre à jour l'UI principale et sauvegarder
        updateCharacterDisplay();
        updateUI();
        saveProgress();
    }

    function closeMiniGame() {
        miniGameModal.classList.add('hidden');
        disableNoScroll();
        selectedBattleCharacters.clear(); // Vider la sélection après avoir fini
    }


    function openTraitProbabilitiesModal() {
        traitProbabilitiesContent.innerHTML = ""; // Vider le contenu précédent

        const introDiv = document.createElement("div");
        introDiv.className = "text-white mb-3 text-sm";
        introDiv.innerHTML = `
            <p>Ces probabilités s'appliquent lors de l'obtention d'un <strong>nouveau trait aléatoire via le bouton "Appliquer Trait Aléatoire"</strong> (coût: ${APPLY_NEW_TRAIT_COST} Reroll Token).</p>
            <p>Les probabilités ci-dessous indiquent la chance d'obtenir chaque <strong>type</strong> de trait. Pour les traits "Force" et "Fortune", le grade (1, 2, ou 3) est ensuite déterminé aléatoirement selon les probabilités spécifiques à ce grade (cliquez pour voir les détails). Les autres traits ont un effet unique.</p>
        `;
        traitProbabilitiesContent.appendChild(introDiv);

        const totalDefinedProbability = Object.values(TRAIT_DEFINITIONS).reduce((sum, traitDef) => sum + (traitDef.probability || 0), 0);
        let probabilitySumForDisplay = 0;

        Object.entries(TRAIT_DEFINITIONS).forEach(([traitId, traitDef]) => {
            if (traitDef.grades && traitDef.grades.length > 0) {
                const typePercentage = (traitDef.probability * 100).toFixed(traitDef.probability < 0.01 ? 2 : 1);
                probabilitySumForDisplay += traitDef.probability;

                const typeProbDiv = document.createElement("div");
                typeProbDiv.className = "p-2 bg-gray-700 rounded mb-2";

                let typeHtml = "";

                const isMultiGradeTrait = (traitId === "strength" || traitId === "fortune") && traitDef.gradeProbabilities && traitDef.gradeProbabilities.length > 0;

                if (isMultiGradeTrait) {
                    // ... (partie pour les traits multi-grades, inchangée)
                    typeHtml = `
                        <details class="cursor-pointer">
                            <summary class="flex justify-between items-center mb-1 list-none focus:outline-none group">
                                <span class="flex items-center">
                                    <img src="${traitDef.image || 'https://via.placeholder.com/24?text=T'}" alt="${traitDef.name}" class="w-6 h-6 mr-2 object-contain">
                                    <span class="text-white font-semibold group-hover:text-blue-300">${traitDef.name}</span>
                                    <svg class="w-4 h-4 ml-2 text-gray-400 group-open:rotate-90 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                                </span>
                                <span class="text-white">${typePercentage}%</span>
                            </summary>
                            <div class="pl-4 mt-1 border-l-2 border-gray-600 text-xs">`;

                    traitDef.gradeProbabilities.forEach(gp => {
                        const gradeDefDetails = traitDef.grades.find(g => g.grade === gp.grade);
                        typeHtml += `
                            <div class="flex justify-between items-center py-0.5">
                                <span class="text-gray-300">Grade ${gp.grade}${gradeDefDetails ? `: ${gradeDefDetails.description}` : ''}</span>
                                <span class="text-gray-300">${(gp.probability * 100).toFixed(0)}% de chance pour ce grade</span>
                            </div>
                        `;
                    });
                    typeHtml += `
                            </div>
                        </details>`;
                } else { // Trait à grade unique
                    typeHtml = `
                        <div class="flex justify-between items-center mb-1">
                            <span class="flex items-center">
                                <img src="${traitDef.image || 'https://via.placeholder.com/24?text=T'}" alt="${traitDef.name}" class="w-6 h-6 mr-2 object-contain">
                                <span class="text-white font-semibold">${traitDef.name}</span>
                            </span>
                            <span class="text-white">${typePercentage}%</span>
                        </div>`;

                    if (traitDef.grades && traitDef.grades.length > 0) {
                        const gradeDefDetails = traitDef.grades[0];
                        if (gradeDefDetails && gradeDefDetails.description) {
                            let textColorClass = 'text-gray-300'; // Couleur par défaut
                            // Vérifier si la description correspond à celle à mettre en surbrillance
                            if (gradeDefDetails.description === "+15% Gemmes & Pièces (Tous modes)") {
                                textColorClass = 'text-gold-brilliant'; // Utilise la nouvelle classe CSS
                            }
                            typeHtml += `
                                <div class="pl-4 border-l-2 border-gray-600 text-xs">
                                    <div class="py-0.5">
                                        <span class="${textColorClass}">Effet: ${gradeDefDetails.description}</span>
                                    </div>
                                </div>`;
                        }
                    }
                }

                typeProbDiv.innerHTML = typeHtml;
                traitProbabilitiesContent.appendChild(typeProbDiv);
            }
        });

        if (Math.abs(probabilitySumForDisplay - 1.0) > 0.001 && Object.keys(TRAIT_DEFINITIONS).length > 0) {
            const warningDiv = document.createElement("div");
            warningDiv.className = "mt-3 p-2 bg-yellow-700 text-yellow-200 text-xs rounded";
            warningDiv.textContent = `Attention : La somme des probabilités des types de traits est de ${(probabilitySumForDisplay * 100).toFixed(1)}%, ce qui n'est pas 100%. Les probabilités pourraient être normalisées ou imprévisibles.`;
            traitProbabilitiesContent.appendChild(warningDiv);
        }

        traitProbabilitiesModal.classList.remove("hidden");
        enableNoScroll();
    }

    function closeTraitProbabilitiesModal() {
        traitProbabilitiesModal.classList.add("hidden");
        disableNoScroll();
    }

    tabButtons.forEach(btn => {
      btn.addEventListener("click", () => showTab(btn.dataset.tab));
    });

    subtabButtons.forEach(btn => {
      btn.addEventListener("click", () => showSubTab(btn.dataset.subtab));
    });

    document.getElementById("battle-sort-criteria").addEventListener("change", () => {
      battleSortCriteria = document.getElementById("battle-sort-criteria").value;
      localStorage.setItem("battleSortCriteria", battleSortCriteria);
      updateCharacterSelectionDisplay();
    });

    pullWithGemsButton.addEventListener("click", () => {
      pullMethodModal.classList.add("hidden");
      document.body.classList.remove("no-scroll");
      executePull(false);
    });
    pullWithTicketButton.addEventListener("click", () => {
      pullMethodModal.classList.add("hidden");
      document.body.classList.remove("no-scroll");
      executePull(true);
    });
    curseKeepBetterToggle.addEventListener("change", () => {
        updateCurseTabDisplay(); // Mettre à jour l'affichage pour activer/désactiver l'input
    });
    document.getElementById("battle-search-name").addEventListener("input", (e) => {
      battleSearchName = e.target.value.toLowerCase();
      localStorage.setItem("battleSearchName", battleSearchName);
      updateCharacterSelectionDisplay();
    });
    document.getElementById("battle-filter-rarity").addEventListener("change", (e) => {
      battleFilterRarity = e.target.value;
      localStorage.setItem("battleFilterRarity", battleFilterRarity);
      updateCharacterSelectionDisplay();
    });
    // Filtres pour la modale de sélection de preset
    document.getElementById("preset-search-name").addEventListener("input", (e) => {
      presetSearchName = e.target.value.toLowerCase();
      localStorage.setItem("presetSearchName", presetSearchName);
      updatePresetSelectionDisplay();
    });
    document.getElementById("preset-filter-rarity").addEventListener("change", (e) => {
      presetFilterRarity = e.target.value;
      localStorage.setItem("presetFilterRarity", presetFilterRarity);
      updatePresetSelectionDisplay();
    });
    // Filtres pour la modale de fusion
    document.getElementById("fusion-search-name").addEventListener("input", (e) => {
      fusionSearchName = e.target.value.toLowerCase();
      localStorage.setItem("fusionSearchName", fusionSearchName);
      updateFusionSelectionDisplay();
    });
    document.getElementById("fusion-filter-rarity").addEventListener("change", (e) => {
      fusionFilterRarity = e.target.value;
      localStorage.setItem("fusionFilterRarity", fusionFilterRarity);
      updateFusionSelectionDisplay();
    });

    cancelPullMethodButton.addEventListener("click", cancelPullMethod);
    pullButton.addEventListener("click", pullCharacter);
    multiPullButton.addEventListener("click", multiPull);
    specialPullButton.addEventListener("click", specialPull);
    document.getElementById("special-multi-pull-button").addEventListener("click", specialMultiPull); 
    deleteButton.addEventListener("click", toggleDeleteMode);
    closeModalButton.addEventListener("click", closeModal);
    cancelSelectionButton.addEventListener("click", cancelSelection);
    confirmSelectionButton.addEventListener("click", confirmSelection);
    cancelFusionButton.addEventListener("click", cancelFusion);
    confirmFusionButton.addEventListener("click", confirmFusion);
    settingsButton.addEventListener("click", () => settingsModal.classList.remove("hidden"));
    saveSettingsButton.addEventListener("click", saveSettings);
    closeSettingsButton.addEventListener("click", () => settingsModal.classList.add("hidden"));
    resetGameButton.addEventListener("click", resetGame);
    confirmResetButton.addEventListener("click", confirmReset);
    cancelResetButton.addEventListener("click", cancelReset);
    cancelGiveItemsButton.addEventListener("click", cancelGiveItems);
    confirmGiveItemsButton.addEventListener("click", confirmGiveItems);
    cancelEvolutionButton.addEventListener("click", cancelEvolution);
    confirmEvolutionButton.addEventListener("click", confirmEvolution);
    document.getElementById("open-preset-modal-button").addEventListener("click", openPresetSelectionModal);
    document.getElementById("apply-stat-change-button").addEventListener("click", applyStatChange);
    document.getElementById("stat-change-search").addEventListener("input", updateStatChangeTabDisplay);
    document.getElementById("curse-char-search").addEventListener("input", updateCurseTabDisplay);
    statRankInfoButton.addEventListener("click", openStatRankProbabilitiesModal);
    closeStatRankProbabilitiesModalButton.addEventListener("click", closeStatRankProbabilitiesModal);
    autofuseSettingsButton.addEventListener("click", startAutofuse);
    cancelAutofuseButton.addEventListener("click", cancelAutofuse);
    confirmAutofuseButton.addEventListener("click", confirmAutofuse);
    traitCharSearchInput.addEventListener("input", updateTraitTabDisplay);
    document.getElementById("limit-break-char-search").addEventListener("input", updateLimitBreakTabDisplay);
    applyLimitBreakButton.addEventListener("click", applyLimitBreak);
    applyCurseButton.addEventListener("click", applyCurse);
    miniGameStartButton.addEventListener('click', startMiniGame);
    miniGameBossImage.addEventListener('click', handleBossClick);
    miniGameCloseButton.addEventListener('click', closeMiniGame);
    document.getElementById("character-selection-title").textContent = `Sélectionner ${currentMaxTeamSize} Personnage(s) pour le Combat`;

    // Ouvrir la modale
    infoButton.addEventListener("click", () => {
      probabilitiesModal.classList.remove("hidden");
      enableNoScroll();
      updateProbabilitiesDisplay(); // Ceci va créer l'élément #standard-banner-timer
      showProbTab("standard");

      // Démarrer le minuteur dynamique pour la bannière standard
      if (bannerTimerIntervalId) clearInterval(bannerTimerIntervalId); // Nettoyer un ancien intervalle au cas où
      bannerTimerIntervalId = setInterval(() => {
        // Toujours re-chercher le span dans le DOM car updateProbabilitiesDisplay peut le recréer
        const timerSpanInTitle = document.getElementById("standard-banner-timer-title");

        if (timerSpanInTitle && currentStandardBanner && currentStandardBanner.generatedAt) {
            const nextChangeTime = currentStandardBanner.generatedAt + TWO_HOURS_MS;
            let timeLeftMs = Math.max(0, nextChangeTime - Date.now());
            
            timerSpanInTitle.textContent = formatTime(timeLeftMs);

            if (timeLeftMs <= 0) {
                // Vérifier si la modale est visible et que l'onglet n'est pas caché
                if (!probabilitiesModal.classList.contains("hidden") && !document.hidden) {
                    console.log("Minuteur atteint 0. Régénération de la bannière et mise à jour de l'affichage.");
                    loadOrGenerateStandardBanner(); // Ceci met à jour currentStandardBanner.generatedAt
                    updateProbabilitiesDisplay(); // Ceci redessinera le H3 et son span de minuteur avec la nouvelle valeur.
                                                 // Le prochain tick de l'intervalle trouvera le *nouveau* span.
                }
            }
        } else if (timerSpanInTitle) {
            timerSpanInTitle.textContent = "Calcul...";
          }
      }, 1000);
    });

    // Fermer la modale
    closeProbabilitiesButton.addEventListener("click", () => {
      probabilitiesModal.classList.add("hidden");
      disableNoScroll();
      if (bannerTimerIntervalId) { // Effacer l'intervalle lorsque la modale est fermée
        clearInterval(bannerTimerIntervalId);
        bannerTimerIntervalId = null;
      }
    });

    // Gérer les onglets
    probTabButtons.forEach(btn => {
      btn.addEventListener("click", () => showProbTab(btn.dataset.tab));
    });

    Object.entries(autofuseRarityCheckboxes).forEach(([rarity, checkbox]) => {
      checkbox.addEventListener("change", () => selectAutofuseRarity(rarity, checkbox.checked));
    });

     curseConfirmYesButton.addEventListener("click", () => {
        if (curseConfirmationCallback) {
            curseConfirmationCallback(true); // L'utilisateur a confirmé
        }
        closeCurseConfirmModal();
    });

    curseConfirmNoButton.addEventListener("click", () => {
        if (curseConfirmationCallback) {
            curseConfirmationCallback(false); // L'utilisateur a annulé
        }
        closeCurseConfirmModal();
    });

    if (traitProbabilitiesInfoButton) { // Vérifier si l'élément existe (au cas où)
        traitProbabilitiesInfoButton.addEventListener("click", openTraitProbabilitiesModal);
    }
    if (closeTraitProbabilitiesModalButton) {
        closeTraitProbabilitiesModalButton.addEventListener("click", closeTraitProbabilitiesModal);
    }

    statKeepBetterToggle.addEventListener("change", updateStatChangeTabDisplay);
    
    statChangeConfirmYesButton.addEventListener("click", () => {
        if (statChangeConfirmationCallback) {
            statChangeConfirmationCallback(true);
        }
        closeStatChangeConfirmModal();
    });

    statChangeConfirmNoButton.addEventListener("click", () => {
        if (statChangeConfirmationCallback) {
            statChangeConfirmationCallback(false);
        }
        closeStatChangeConfirmModal();
    });

    traitKeepBetterToggle.addEventListener("change", () => {
        traitKeepBetterToggleState = traitKeepBetterToggle.checked; // Mettre à jour la variable globale si vous en avez une (optionnel ici)
        updateTraitTabDisplay(); // Mettre à jour pour activer/désactiver les checkboxes et le bouton
    });

    traitActionConfirmYesButton.addEventListener("click", () => {
        if (traitConfirmationCallback) {
            traitConfirmationCallback(true);
        }
        closeTraitActionConfirmModal();
    });

    traitActionConfirmNoButton.addEventListener("click", () => {
        if (traitConfirmationCallback) {
            traitConfirmationCallback(false);
        }
        closeTraitActionConfirmModal();
    });

    const inventoryFilterNameInput = document.getElementById("inventory-filter-name");
    if (inventoryFilterNameInput) {
        inventoryFilterNameInput.value = inventoryFilterName; // Initialiser avec la valeur sauvegardée
        inventoryFilterNameInput.addEventListener("input", (e) => {
            inventoryFilterName = e.target.value;
            localStorage.setItem("inventoryFilterName", inventoryFilterName);
            updateCharacterDisplay();
        });
    }

    const inventoryFilterRaritySelect = document.getElementById("inventory-filter-rarity");
    if (inventoryFilterRaritySelect) {
        inventoryFilterRaritySelect.value = inventoryFilterRarity; // Initialiser
        inventoryFilterRaritySelect.addEventListener("change", (e) => {
            inventoryFilterRarity = e.target.value;
            localStorage.setItem("inventoryFilterRarity", inventoryFilterRarity);
            updateCharacterDisplay();
        });
    }

    const inventorySortCriteriaSelect = document.getElementById("sort-criteria-secondary"); // L'ID HTML reste le même pour l'instant
      if (inventorySortCriteriaSelect) {
          inventorySortCriteriaSelect.value = sortCriteria; // Initialiser avec la valeur de sortCriteria (le tri principal)
          inventorySortCriteriaSelect.addEventListener("change", (e) => {
              sortCriteria = e.target.value; // Met à jour sortCriteria (le tri principal)
              localStorage.setItem("sortCriteria", sortCriteria); // Sauvegarde le tri principal
              updateCharacterDisplay();
          });
    }

    const inventoryFilterEvolvableCheckbox = document.getElementById("inventory-filter-evolvable");
    if (inventoryFilterEvolvableCheckbox) {
        inventoryFilterEvolvableCheckbox.checked = inventoryFilterEvolvable; // Initialiser
        inventoryFilterEvolvableCheckbox.addEventListener("change", (e) => {
            inventoryFilterEvolvable = e.target.checked;
            localStorage.setItem("inventoryFilterEvolvable", inventoryFilterEvolvable);
            updateCharacterDisplay();
        });
    }

    const inventoryFilterLimitBreakCheckbox = document.getElementById("inventory-filter-limitbreak");
    if (inventoryFilterLimitBreakCheckbox) {
        inventoryFilterLimitBreakCheckbox.checked = inventoryFilterLimitBreak; // Initialiser
        inventoryFilterLimitBreakCheckbox.addEventListener("change", (e) => {
            inventoryFilterLimitBreak = e.target.checked;
            localStorage.setItem("inventoryFilterLimitBreak", inventoryFilterLimitBreak);
            updateCharacterDisplay();
        });
    }

    const inventoryFilterCanReceiveExpCheckbox = document.getElementById("inventory-filter-canreceiveexp");
    if (inventoryFilterCanReceiveExpCheckbox) {
        inventoryFilterCanReceiveExpCheckbox.checked = inventoryFilterCanReceiveExp; // Initialiser
        inventoryFilterCanReceiveExpCheckbox.addEventListener("change", (e) => {
            inventoryFilterCanReceiveExp = e.target.checked;
            localStorage.setItem("inventoryFilterCanReceiveExp", inventoryFilterCanReceiveExp);
            updateCharacterDisplay();
        });
    }

    applyCurseButton.addEventListener("click", applyCurse);
    document.getElementById("load-preset-button").addEventListener("click", loadPreset);
    document.getElementById("confirm-preset").addEventListener("click", confirmPreset);
    document.getElementById("cancel-preset").addEventListener("click", cancelPreset);
    document.getElementById("preset-sort-criteria").addEventListener("change", () => {
      presetSortCriteria = document.getElementById("preset-sort-criteria").value;
      localStorage.setItem("presetSortCriteria", presetSortCriteria);
      updatePresetSelectionDisplay();
    });

    auth.onAuthStateChanged(user => {
        if (user) {
            // L'utilisateur est connecté
            currentUser = user;
            // Extraire le pseudo de l'email synthétique
            const username = user.email.split('@')[0];
            console.log("Utilisateur connecté:", username);

            // Afficher l'état de l'utilisateur et cacher les formulaires
            document.getElementById('user-email').textContent = username; // MODIFIÉ ICI
            authContainer.classList.add('hidden');
            userStatus.classList.remove('hidden');
            gameContainer.classList.remove('hidden');
            
            // Charger la progression du joueur
            if (!isGameInitialized) {
                loadProgress(user.uid);
            }

        } else {
            // L'utilisateur est déconnecté
            currentUser = null;
            console.log("Aucun utilisateur connecté.");

            // Cacher le jeu et le statut, afficher les formulaires
            isGameInitialized = false;
            gameContainer.classList.add('hidden');
            userStatus.classList.add('hidden');
            authContainer.classList.remove('hidden');
            document.getElementById('login-view').classList.remove('hidden');
            document.getElementById('signup-view').classList.add('hidden');
        }
    });

    // Initialiser l'interface d'authentification
    setupAuthUI();


    applySettings();
    if (shopOffers.length !== 3) {
      updateShopOffers();
    } else {
      updateShopDisplay();
    }
    if (missions.length !== 3) {
      updateMissionPool();
    } else {
      updateMissions();
    }
    updateTimer();
    updateCharacterDisplay();
    updateItemDisplay();
    updateUI();
    loadOrGenerateStandardBanner();
    if (!evolutionElement.classList.contains("hidden")) {
        const activeSubTabButton = document.querySelector('#evolution .subtab-button.border-blue-500');
        if (activeSubTabButton) {
            showSubTabEvolution(activeSubTabButton.dataset.subtab);
        } else {
            showSubTabEvolution("evolve-char"); // Défaut
        }
    } else {
        showTab("play"); // Onglet par défaut si rien d'autre n'est défini
    }
    populateTargetStatRanks();
    populateTargetTraits();
    window.addEventListener('beforeunload', (event) => {
        // La spécification requiert que returnValue soit défini pour certains navigateurs,
        // même si nous ne voulons pas afficher de message de confirmation.
        // On n'exécute que la sauvegarde.
        console.log("Événement beforeunload déclenché. Tentative de sauvegarde immédiate...");
        if (currentUser && isGameInitialized) { // Sauvegarde uniquement si une session de jeu est active
             _performSave();
        }
        // Note : Il n'est pas possible de garantir que la sauvegarde asynchrone aura le temps
        // de se terminer, mais c'est la meilleure tentative possible.
    });
  </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'939104e50fc0d0b6',t:'MTc0NjEyMDc1Ni4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>